name: 'GoSQLX SQL Validator'
description: 'Ultra-fast SQL validation, linting, and formatting with GoSQLX - 100x faster than SQLFluff'
author: 'GoSQLX Team'

branding:
  icon: 'check-circle'
  color: 'blue'

inputs:
  files:
    description: 'Glob pattern for SQL files to process (e.g., "**/*.sql", "queries/*.sql")'
    required: true
    default: '**/*.sql'

  validate:
    description: 'Enable SQL validation (syntax checking)'
    required: false
    default: 'true'

  lint:
    description: 'Enable SQL linting (best practices checking) - Advanced feature'
    required: false
    default: 'false'

  format-check:
    description: 'Check if SQL files are properly formatted (CI mode)'
    required: false
    default: 'false'

  fail-on-error:
    description: 'Fail the build when validation errors are found'
    required: false
    default: 'true'

  config:
    description: 'Path to GoSQLX config file (.gosqlx.yml or .gosqlx.yaml)'
    required: false
    default: ''

  dialect:
    description: 'SQL dialect: postgresql, mysql, sqlserver, oracle, sqlite (default: auto-detect)'
    required: false
    default: ''

  strict:
    description: 'Enable strict validation mode (more rigorous checks)'
    required: false
    default: 'false'

  show-stats:
    description: 'Display performance statistics after validation'
    required: false
    default: 'false'

  sarif-output:
    description: 'Generate SARIF output for GitHub Code Scanning (requires security-events: write permission)'
    required: false
    default: 'false'

  pr-comment:
    description: 'Post validation results as a PR comment (only works on pull_request events)'
    required: false
    default: 'false'

  pr-comment-compact:
    description: 'Use compact format for PR comments (limits to 5 errors max)'
    required: false
    default: 'false'

  gosqlx-version:
    description: 'GoSQLX version to use (default: latest)'
    required: false
    default: 'latest'

  working-directory:
    description: 'Working directory for SQL file operations'
    required: false
    default: '.'

outputs:
  validated-files:
    description: 'Number of files validated'
    value: ${{ steps.validate.outputs.validated-files }}

  invalid-files:
    description: 'Number of files with validation errors'
    value: ${{ steps.validate.outputs.invalid-files }}

  formatted-files:
    description: 'Number of files needing formatting (if format-check enabled)'
    value: ${{ steps.format-check.outputs.formatted-files }}

  validation-time:
    description: 'Total validation time in milliseconds'
    value: ${{ steps.validate.outputs.validation-time }}

runs:
  using: 'composite'
  steps:
    - name: Setup Go
      uses: actions/setup-go@0c52d547c9bc32b1aa3301fd7a9cb496313a4491  # v5.0.0
      with:
        go-version: '1.21'

    # Disable cache when testing in repository to always build from latest source
    # - name: Cache GoSQLX binary
    #   id: cache-gosqlx
    #   uses: actions/cache@v4
    #   with:
    #     path: ~/go/bin/gosqlx
    #     key: gosqlx-${{ inputs.gosqlx-version }}-${{ runner.os }}-${{ runner.arch }}-${{ github.sha }}

    - name: Install GoSQLX
      # if: steps.cache-gosqlx.outputs.cache-hit != 'true'
      shell: bash
      run: |
        # Check if we're in the GoSQLX repository (for testing)
        # When using "uses: ./", GITHUB_WORKSPACE contains the repo
        if [ -f "$GITHUB_WORKSPACE/go.mod" ] && grep -q "module github.com/ajitpratap0/GoSQLX" "$GITHUB_WORKSPACE/go.mod" 2>/dev/null; then
          echo "Building GoSQLX from source (local repository)..."
          cd "$GITHUB_WORKSPACE"
          mkdir -p "$HOME/go/bin"
          go build -o "$HOME/go/bin/gosqlx" ./cmd/gosqlx
          echo "GoSQLX built from source successfully"
        else
          # Validate gosqlx-version input (semver or 'latest')
          VERSION="${{ inputs.gosqlx-version }}"
          if [ "$VERSION" != "latest" ]; then
            if ! echo "$VERSION" | grep -qE '^v?[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+)?$'; then
              echo "::error::Invalid gosqlx-version format. Must be 'latest' or semver (e.g., v1.4.0)"
              exit 1
            fi
          fi

          if [ "$VERSION" = "latest" ]; then
            echo "Installing latest GoSQLX..."
            go install github.com/ajitpratap0/GoSQLX/cmd/gosqlx@latest
          else
            echo "Installing GoSQLX $VERSION..."
            go install github.com/ajitpratap0/GoSQLX/cmd/gosqlx@"$VERSION"
          fi
          echo "GoSQLX installed successfully"
        fi
        "$HOME/go/bin/gosqlx" --version

    - name: Verify GoSQLX installation
      shell: bash
      run: |
        if ! command -v "$HOME/go/bin/gosqlx" &> /dev/null; then
          echo "ERROR: GoSQLX installation failed"
          exit 1
        fi
        echo "GoSQLX version:"
        "$HOME/go/bin/gosqlx" --version

    - name: Find SQL files
      id: find-files
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        # Validate working-directory exists and is within repo
        WORKDIR="${{ inputs.working-directory }}"
        if [ ! -d "$WORKDIR" ]; then
          echo "::error::Working directory does not exist: $WORKDIR"
          exit 1
        fi

        # Ensure working directory is within the repository
        REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null || echo "$GITHUB_WORKSPACE")
        WORKDIR_ABS=$(cd "$WORKDIR" && pwd)
        if [[ "$WORKDIR_ABS" != "$REPO_ROOT"* ]]; then
          echo "::error::Working directory must be within repository: $WORKDIR_ABS"
          exit 1
        fi

        # Sanitize file pattern to prevent command injection
        PATTERN="${{ inputs.files }}"
        # Remove dangerous characters that could lead to command injection
        if echo "$PATTERN" | grep -qE '[;&|`$()]'; then
          echo "::error::File pattern contains invalid characters: $PATTERN"
          exit 1
        fi

        echo "Finding SQL files matching pattern: $PATTERN"

        # Use find to locate SQL files matching the pattern
        # Convert glob pattern to find-compatible pattern
        # Handle common glob patterns
        if [[ "$PATTERN" == "**/*.sql" ]]; then
          FILES=$(find . -type f -name "*.sql" 2>/dev/null | sort || true)
        elif [[ "$PATTERN" == "*.sql" ]]; then
          FILES=$(find . -maxdepth 1 -type f -name "*.sql" 2>/dev/null | sort || true)
        elif [[ "$PATTERN" =~ ^(.+)/\*\*/(.+)$ ]]; then
          # Handle patterns like "dir/**/*.sql" - extract base dir and file pattern
          BASE_DIR="${BASH_REMATCH[1]}"
          FILE_PATTERN="${BASH_REMATCH[2]}"
          FILES=$(find "./$BASE_DIR" -type f -name "$FILE_PATTERN" 2>/dev/null | sort || true)
        else
          # Custom pattern without ** - try direct find with escaped pattern
          FILES=$(find . -type f -path "./$PATTERN" 2>/dev/null | sort || true)
        fi

        if [ -z "$FILES" ]; then
          echo "WARNING: No SQL files found matching pattern: ${{ inputs.files }}"
          echo "file-count=0" >> $GITHUB_OUTPUT
          exit 0
        fi

        FILE_COUNT=$(echo "$FILES" | wc -l)
        echo "Found $FILE_COUNT SQL file(s)"
        echo "$FILES" | head -10
        if [ $FILE_COUNT -gt 10 ]; then
          echo "... and $((FILE_COUNT - 10)) more files"
        fi

        # Save file list for later steps
        echo "$FILES" > /tmp/gosqlx-files.txt
        echo "file-count=$FILE_COUNT" >> $GITHUB_OUTPUT

    - name: Validate SQL files
      id: validate
      if: inputs.validate == 'true' && steps.find-files.outputs.file-count != '0'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "::group::SQL Validation"

        # Build validation command
        CMD="$HOME/go/bin/gosqlx validate"

        # Add config if provided
        if [ -n "${{ inputs.config }}" ]; then
          if [ -f "${{ inputs.config }}" ]; then
            echo "Using config file: ${{ inputs.config }}"
            export GOSQLX_CONFIG="${{ inputs.config }}"
          else
            echo "::warning::Config file not found: ${{ inputs.config }}"
          fi
        fi

        # Add dialect if provided (with validation)
        DIALECT="${{ inputs.dialect }}"
        if [ -n "$DIALECT" ]; then
          # Validate dialect is one of the allowed values
          if [[ "$DIALECT" =~ ^(postgresql|mysql|sqlserver|oracle|sqlite)$ ]]; then
            CMD="$CMD --dialect $DIALECT"
          else
            echo "::warning::Invalid dialect '$DIALECT', skipping dialect flag"
          fi
        fi

        # Add strict mode if enabled
        if [ "${{ inputs.strict }}" = "true" ]; then
          CMD="$CMD --strict"
        fi

        # Add stats if enabled
        if [ "${{ inputs.show-stats }}" = "true" ]; then
          CMD="$CMD --stats"
        fi

        # Add verbose output for GitHub Actions
        CMD="$CMD --verbose"

        # Read files and validate
        START_TIME=$(date +%s%3N)
        VALIDATED=0
        INVALID=0

        while IFS= read -r file; do
          # Sanitize file path for display
          SAFE_FILE="${file//[^a-zA-Z0-9\/._-]/}"
          echo "Validating: $file"

          # Use quoted variable to prevent word splitting
          if $CMD "$file" 2>&1; then
            echo "âœ“ Valid: $file"
            VALIDATED=$((VALIDATED + 1))
          else
            echo "âœ— Invalid: $file"
            echo "::error file=$SAFE_FILE::SQL validation failed"
            INVALID=$((INVALID + 1))
          fi
        done < /tmp/gosqlx-files.txt

        END_TIME=$(date +%s%3N)
        DURATION=$((END_TIME - START_TIME))

        echo "::endgroup::"

        # Output summary
        echo "::notice::Validation complete: $VALIDATED valid, $INVALID invalid files (${DURATION}ms)"

        # Set outputs
        echo "validated-files=$VALIDATED" >> $GITHUB_OUTPUT
        echo "invalid-files=$INVALID" >> $GITHUB_OUTPUT
        echo "validation-time=$DURATION" >> $GITHUB_OUTPUT

        # Create job summary
        echo "## SQL Validation Results" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
        echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
        echo "| Files Validated | $VALIDATED |" >> $GITHUB_STEP_SUMMARY
        echo "| Validation Errors | $INVALID |" >> $GITHUB_STEP_SUMMARY
        echo "| Duration | ${DURATION}ms |" >> $GITHUB_STEP_SUMMARY
        echo "| Throughput | $(awk "BEGIN {printf \"%.2f\", $VALIDATED * 1000 / $DURATION}") files/sec |" >> $GITHUB_STEP_SUMMARY

        # Fail if there are invalid files and fail-on-error is true
        if [ $INVALID -gt 0 ] && [ "${{ inputs.fail-on-error }}" = "true" ]; then
          echo "::error::Validation failed with $INVALID invalid file(s)"
          exit 1
        fi

    - name: Generate SARIF output
      id: sarif
      if: inputs.sarif-output == 'true' && steps.find-files.outputs.file-count != '0'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "::group::Generate SARIF Report"

        # Build validation command with SARIF output
        CMD="$HOME/go/bin/gosqlx validate --output-format sarif --output-file gosqlx-results.sarif"

        # Add config if provided
        if [ -n "${{ inputs.config }}" ]; then
          if [ -f "${{ inputs.config }}" ]; then
            export GOSQLX_CONFIG="${{ inputs.config }}"
          fi
        fi

        # Add dialect if provided
        DIALECT="${{ inputs.dialect }}"
        if [ -n "$DIALECT" ] && [[ "$DIALECT" =~ ^(postgresql|mysql|sqlserver|oracle|sqlite)$ ]]; then
          CMD="$CMD --dialect $DIALECT"
        fi

        # Add strict mode if enabled
        if [ "${{ inputs.strict }}" = "true" ]; then
          CMD="$CMD --strict"
        fi

        # Read files and run validation to generate SARIF
        cat /tmp/gosqlx-files.txt | tr '\n' ' ' | xargs $CMD || true

        # Check if SARIF file was created
        if [ -f "gosqlx-results.sarif" ]; then
          echo "âœ“ SARIF report generated: gosqlx-results.sarif"
          echo "sarif-file=gosqlx-results.sarif" >> $GITHUB_OUTPUT
        else
          echo "::warning::SARIF report generation failed"
        fi

        echo "::endgroup::"

    - name: Upload SARIF to GitHub Code Scanning
      if: inputs.sarif-output == 'true' && steps.sarif.outputs.sarif-file != ''
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: ${{ inputs.working-directory }}/gosqlx-results.sarif
        category: gosqlx-sql-validation

    - name: Post PR Comment
      id: pr-comment
      if: inputs.pr-comment == 'true' && github.event_name == 'pull_request' && steps.validate.conclusion != 'skipped'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        GH_TOKEN: ${{ github.token }}
      run: |
        echo "::group::Generate PR Comment"

        # Create a temporary Go program to format the validation results as a PR comment
        cat > /tmp/format_comment.go << 'SCRIPT_EOF'
        package main

        import (
            "encoding/json"
            "fmt"
            "os"
            "strings"
            "time"
        )

        type FileValidationResult struct {
            Path  string
            Valid bool
            Size  int64
            Error *string
        }

        type ValidationResult struct {
            TotalFiles   int
            ValidFiles   int
            InvalidFiles int
            TotalBytes   int64
            Duration     string
            Files        []FileValidationResult
        }

        func formatPRComment(result *ValidationResult, compact bool) string {
            var sb strings.Builder

            duration, _ := time.ParseDuration(result.Duration)

            if compact {
                if result.InvalidFiles == 0 {
                    sb.WriteString("## âœ… GoSQLX: All SQL files valid\n\n")
                    sb.WriteString(fmt.Sprintf("Validated **%d** file(s) in **%v**\n", result.ValidFiles, duration))
                } else {
                    sb.WriteString(fmt.Sprintf("## âŒ GoSQLX: Found issues in %d/%d files\n\n", result.InvalidFiles, result.TotalFiles))
                    errorCount := 0
                    maxErrors := 5
                    for _, file := range result.Files {
                        if file.Error != nil && errorCount < maxErrors {
                            sb.WriteString(fmt.Sprintf("- âŒ `%s`: %s\n", file.Path, *file.Error))
                            errorCount++
                        }
                    }
                    if result.InvalidFiles > maxErrors {
                        sb.WriteString(fmt.Sprintf("\n*...and %d more error(s). Run locally for full details.*\n", result.InvalidFiles-maxErrors))
                    }
                }
                sb.WriteString("\n---\n")
                sb.WriteString(fmt.Sprintf("â±ï¸ %v", duration))
                if result.TotalFiles > 0 && duration.Seconds() > 0 {
                    throughput := float64(result.TotalFiles) / duration.Seconds()
                    sb.WriteString(fmt.Sprintf(" | ðŸš€ %.1f files/sec", throughput))
                }
            } else {
                sb.WriteString("## ðŸ” GoSQLX SQL Validation Results\n\n")
                if result.InvalidFiles == 0 {
                    sb.WriteString("### âœ… All SQL files are valid!\n\n")
                    sb.WriteString(fmt.Sprintf("**%d** file(s) validated successfully in **%v**\n\n", result.ValidFiles, duration))
                } else {
                    sb.WriteString(fmt.Sprintf("### âŒ Found issues in %d file(s)\n\n", result.InvalidFiles))
                }
                sb.WriteString("| Metric | Value |\n|--------|-------|\n")
                sb.WriteString(fmt.Sprintf("| Total Files | %d |\n", result.TotalFiles))
                sb.WriteString(fmt.Sprintf("| âœ… Valid | %d |\n", result.ValidFiles))
                sb.WriteString(fmt.Sprintf("| âŒ Invalid | %d |\n", result.InvalidFiles))
                sb.WriteString(fmt.Sprintf("| â±ï¸ Duration | %v |\n", duration))
                if result.TotalFiles > 0 && duration.Seconds() > 0 {
                    throughput := float64(result.TotalFiles) / duration.Seconds()
                    sb.WriteString(fmt.Sprintf("| ðŸš€ Throughput | %.1f files/sec |\n", throughput))
                }
                sb.WriteString("\n")
                if result.InvalidFiles > 0 {
                    sb.WriteString("### ðŸ“‹ Validation Errors\n\n")
                    for _, file := range result.Files {
                        if file.Error != nil {
                            sb.WriteString(fmt.Sprintf("#### âŒ `%s`\n\n```\n%s\n```\n\n", file.Path, *file.Error))
                        }
                    }
                }
                sb.WriteString("---\n*Powered by [GoSQLX](https://github.com/ajitpratap0/GoSQLX) - Ultra-fast SQL validation (100x faster than SQLFluff)*\n")
            }
            return sb.String()
        }

        func main() {
            var result ValidationResult
            if err := json.NewDecoder(os.Stdin).Decode(&result); err != nil {
                fmt.Fprintf(os.Stderr, "Error decoding JSON: %v\n", err)
                os.Exit(1)
            }
            compact := len(os.Args) > 1 && os.Args[1] == "compact"
            fmt.Print(formatPRComment(&result, compact))
        }
        SCRIPT_EOF

        # Create JSON from validation results
        cat > /tmp/validation_results.json << JSON_EOF
        {
          "TotalFiles": ${{ steps.validate.outputs.validated-files || 0 }} + ${{ steps.validate.outputs.invalid-files || 0 }},
          "ValidFiles": ${{ steps.validate.outputs.validated-files || 0 }},
          "InvalidFiles": ${{ steps.validate.outputs.invalid-files || 0 }},
          "Duration": "${{ steps.validate.outputs.validation-time || 0 }}ms",
          "Files": []
        }
        JSON_EOF

        # Format the compact argument
        COMPACT_ARG=""
        if [ "${{ inputs.pr-comment-compact }}" = "true" ]; then
          COMPACT_ARG="compact"
        fi

        # Generate comment using Go script
        COMMENT_BODY=$(go run /tmp/format_comment.go $COMPACT_ARG < /tmp/validation_results.json)

        # Post comment to PR using gh CLI
        echo "$COMMENT_BODY" | gh pr comment ${{ github.event.pull_request.number }} --body-file -

        echo "âœ“ Posted validation results to PR #${{ github.event.pull_request.number }}"
        echo "::endgroup::"

    - name: Check SQL formatting
      id: format-check
      if: inputs.format-check == 'true' && steps.find-files.outputs.file-count != '0'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "::group::SQL Format Check"

        NEEDS_FORMATTING=0

        while IFS= read -r file; do
          echo "Checking format: $file"

          if ! "$HOME/go/bin/gosqlx" format --check "$file" 2>&1; then
            echo "âœ— Needs formatting: $file"
            echo "::warning file=$file::File needs formatting"
            NEEDS_FORMATTING=$((NEEDS_FORMATTING + 1))
          else
            echo "âœ“ Properly formatted: $file"
          fi
        done < /tmp/gosqlx-files.txt

        echo "::endgroup::"

        # Set output
        echo "formatted-files=$NEEDS_FORMATTING" >> $GITHUB_OUTPUT

        # Add to summary
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Format Check" >> $GITHUB_STEP_SUMMARY
        echo "Files needing formatting: $NEEDS_FORMATTING" >> $GITHUB_STEP_SUMMARY

        # Fail if files need formatting and fail-on-error is true
        if [ $NEEDS_FORMATTING -gt 0 ] && [ "${{ inputs.fail-on-error }}" = "true" ]; then
          echo "::error::$NEEDS_FORMATTING file(s) need formatting"
          exit 1
        fi

    - name: Run SQL linting
      id: lint
      if: inputs.lint == 'true' && steps.find-files.outputs.file-count != '0'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "::group::SQL Linting"
        echo "::notice::Advanced linting features are in development (Phase 4)"
        echo "::notice::Currently performing basic analysis..."

        LINT_ISSUES=0

        while IFS= read -r file; do
          echo "Analyzing: $file"

          # Use analyze command for basic linting
          if "$HOME/go/bin/gosqlx" analyze --all "$file" 2>&1; then
            echo "âœ“ No issues: $file"
          else
            echo "âš  Issues found: $file"
            LINT_ISSUES=$((LINT_ISSUES + 1))
          fi
        done < /tmp/gosqlx-files.txt

        echo "::endgroup::"

        # Add to summary
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Linting Results" >> $GITHUB_STEP_SUMMARY
        echo "Files with lint issues: $LINT_ISSUES" >> $GITHUB_STEP_SUMMARY

        # Note: Linting is advisory, doesn't fail build
        if [ $LINT_ISSUES -gt 0 ]; then
          echo "::warning::$LINT_ISSUES file(s) have linting suggestions"
        fi

    - name: Cleanup
      if: always()
      shell: bash
      run: |
        rm -f /tmp/gosqlx-files.txt
