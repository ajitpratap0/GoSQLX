name: 'GoSQLX SQL Validator'
description: 'Ultra-fast SQL validation, linting, and formatting with GoSQLX - 100x faster than SQLFluff'
author: 'GoSQLX Team'

branding:
  icon: 'check-circle'
  color: 'blue'

inputs:
  files:
    description: 'Glob pattern for SQL files to process (e.g., "**/*.sql", "queries/*.sql")'
    required: true
    default: '**/*.sql'

  validate:
    description: 'Enable SQL validation (syntax checking)'
    required: false
    default: 'true'

  lint:
    description: 'Enable SQL linting (best practices checking) - Advanced feature'
    required: false
    default: 'false'

  format-check:
    description: 'Check if SQL files are properly formatted (CI mode)'
    required: false
    default: 'false'

  fail-on-error:
    description: 'Fail the build when validation errors are found'
    required: false
    default: 'true'

  config:
    description: 'Path to GoSQLX config file (.gosqlx.yml or .gosqlx.yaml)'
    required: false
    default: ''

  dialect:
    description: 'SQL dialect: postgresql, mysql, sqlserver, oracle, sqlite (default: auto-detect)'
    required: false
    default: ''

  strict:
    description: 'Enable strict validation mode (more rigorous checks)'
    required: false
    default: 'false'

  show-stats:
    description: 'Display performance statistics after validation'
    required: false
    default: 'false'

  gosqlx-version:
    description: 'GoSQLX version to use (default: latest)'
    required: false
    default: 'latest'

  working-directory:
    description: 'Working directory for SQL file operations'
    required: false
    default: '.'

outputs:
  validated-files:
    description: 'Number of files validated'
    value: ${{ steps.validate.outputs.validated-files }}

  invalid-files:
    description: 'Number of files with validation errors'
    value: ${{ steps.validate.outputs.invalid-files }}

  formatted-files:
    description: 'Number of files needing formatting (if format-check enabled)'
    value: ${{ steps.format-check.outputs.formatted-files }}

  validation-time:
    description: 'Total validation time in milliseconds'
    value: ${{ steps.validate.outputs.validation-time }}

runs:
  using: 'composite'
  steps:
    - name: Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.19'

    - name: Cache GoSQLX binary
      id: cache-gosqlx
      uses: actions/cache@v4
      with:
        path: ~/go/bin/gosqlx
        key: gosqlx-${{ inputs.gosqlx-version }}-${{ runner.os }}-${{ runner.arch }}

    - name: Install GoSQLX
      if: steps.cache-gosqlx.outputs.cache-hit != 'true'
      shell: bash
      run: |
        if [ "${{ inputs.gosqlx-version }}" = "latest" ]; then
          echo "Installing latest GoSQLX..."
          go install github.com/ajitpratap0/GoSQLX/cmd/gosqlx@latest
        else
          echo "Installing GoSQLX ${{ inputs.gosqlx-version }}..."
          go install github.com/ajitpratap0/GoSQLX/cmd/gosqlx@${{ inputs.gosqlx-version }}
        fi
        echo "GoSQLX installed successfully"
        ~/go/bin/gosqlx --version

    - name: Verify GoSQLX installation
      shell: bash
      run: |
        if ! command -v ~/go/bin/gosqlx &> /dev/null; then
          echo "ERROR: GoSQLX installation failed"
          exit 1
        fi
        echo "GoSQLX version:"
        ~/go/bin/gosqlx --version

    - name: Find SQL files
      id: find-files
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "Finding SQL files matching pattern: ${{ inputs.files }}"

        # Use find to locate SQL files matching the pattern
        # Convert glob pattern to find-compatible pattern
        PATTERN="${{ inputs.files }}"

        # Handle common glob patterns
        if [[ "$PATTERN" == "**/*.sql" ]]; then
          FILES=$(find . -type f -name "*.sql" | sort)
        elif [[ "$PATTERN" == "*.sql" ]]; then
          FILES=$(find . -maxdepth 1 -type f -name "*.sql" | sort)
        else
          # Custom pattern - try direct find
          FILES=$(find . -type f -path "$PATTERN" | sort)
        fi

        if [ -z "$FILES" ]; then
          echo "WARNING: No SQL files found matching pattern: ${{ inputs.files }}"
          echo "file-count=0" >> $GITHUB_OUTPUT
          exit 0
        fi

        FILE_COUNT=$(echo "$FILES" | wc -l)
        echo "Found $FILE_COUNT SQL file(s)"
        echo "$FILES" | head -10
        if [ $FILE_COUNT -gt 10 ]; then
          echo "... and $((FILE_COUNT - 10)) more files"
        fi

        # Save file list for later steps
        echo "$FILES" > /tmp/gosqlx-files.txt
        echo "file-count=$FILE_COUNT" >> $GITHUB_OUTPUT

    - name: Validate SQL files
      id: validate
      if: inputs.validate == 'true' && steps.find-files.outputs.file-count != '0'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "::group::SQL Validation"

        # Build validation command
        CMD="~/go/bin/gosqlx validate"

        # Add config if provided
        if [ -n "${{ inputs.config }}" ]; then
          if [ -f "${{ inputs.config }}" ]; then
            echo "Using config file: ${{ inputs.config }}"
            export GOSQLX_CONFIG="${{ inputs.config }}"
          else
            echo "::warning::Config file not found: ${{ inputs.config }}"
          fi
        fi

        # Add dialect if provided
        if [ -n "${{ inputs.dialect }}" ]; then
          CMD="$CMD --dialect ${{ inputs.dialect }}"
        fi

        # Add strict mode if enabled
        if [ "${{ inputs.strict }}" = "true" ]; then
          CMD="$CMD --strict"
        fi

        # Add stats if enabled
        if [ "${{ inputs.show-stats }}" = "true" ]; then
          CMD="$CMD --stats"
        fi

        # Add verbose output for GitHub Actions
        CMD="$CMD --verbose"

        # Read files and validate
        START_TIME=$(date +%s%3N)
        VALIDATED=0
        INVALID=0

        while IFS= read -r file; do
          echo "Validating: $file"

          if $CMD "$file" 2>&1; then
            echo "✓ Valid: $file"
            VALIDATED=$((VALIDATED + 1))
          else
            echo "✗ Invalid: $file"
            echo "::error file=$file::SQL validation failed"
            INVALID=$((INVALID + 1))
          fi
        done < /tmp/gosqlx-files.txt

        END_TIME=$(date +%s%3N)
        DURATION=$((END_TIME - START_TIME))

        echo "::endgroup::"

        # Output summary
        echo "::notice::Validation complete: $VALIDATED valid, $INVALID invalid files (${DURATION}ms)"

        # Set outputs
        echo "validated-files=$VALIDATED" >> $GITHUB_OUTPUT
        echo "invalid-files=$INVALID" >> $GITHUB_OUTPUT
        echo "validation-time=$DURATION" >> $GITHUB_OUTPUT

        # Create job summary
        echo "## SQL Validation Results" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
        echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
        echo "| Files Validated | $VALIDATED |" >> $GITHUB_STEP_SUMMARY
        echo "| Validation Errors | $INVALID |" >> $GITHUB_STEP_SUMMARY
        echo "| Duration | ${DURATION}ms |" >> $GITHUB_STEP_SUMMARY
        echo "| Throughput | $(awk "BEGIN {printf \"%.2f\", $VALIDATED * 1000 / $DURATION}") files/sec |" >> $GITHUB_STEP_SUMMARY

        # Fail if there are invalid files and fail-on-error is true
        if [ $INVALID -gt 0 ] && [ "${{ inputs.fail-on-error }}" = "true" ]; then
          echo "::error::Validation failed with $INVALID invalid file(s)"
          exit 1
        fi

    - name: Check SQL formatting
      id: format-check
      if: inputs.format-check == 'true' && steps.find-files.outputs.file-count != '0'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "::group::SQL Format Check"

        NEEDS_FORMATTING=0

        while IFS= read -r file; do
          echo "Checking format: $file"

          if ! ~/go/bin/gosqlx format --check "$file" 2>&1; then
            echo "✗ Needs formatting: $file"
            echo "::warning file=$file::File needs formatting"
            NEEDS_FORMATTING=$((NEEDS_FORMATTING + 1))
          else
            echo "✓ Properly formatted: $file"
          fi
        done < /tmp/gosqlx-files.txt

        echo "::endgroup::"

        # Set output
        echo "formatted-files=$NEEDS_FORMATTING" >> $GITHUB_OUTPUT

        # Add to summary
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Format Check" >> $GITHUB_STEP_SUMMARY
        echo "Files needing formatting: $NEEDS_FORMATTING" >> $GITHUB_STEP_SUMMARY

        # Fail if files need formatting and fail-on-error is true
        if [ $NEEDS_FORMATTING -gt 0 ] && [ "${{ inputs.fail-on-error }}" = "true" ]; then
          echo "::error::$NEEDS_FORMATTING file(s) need formatting"
          exit 1
        fi

    - name: Run SQL linting
      id: lint
      if: inputs.lint == 'true' && steps.find-files.outputs.file-count != '0'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "::group::SQL Linting"
        echo "::notice::Advanced linting features are in development (Phase 4)"
        echo "::notice::Currently performing basic analysis..."

        LINT_ISSUES=0

        while IFS= read -r file; do
          echo "Analyzing: $file"

          # Use analyze command for basic linting
          if ~/go/bin/gosqlx analyze --all "$file" 2>&1; then
            echo "✓ No issues: $file"
          else
            echo "⚠ Issues found: $file"
            LINT_ISSUES=$((LINT_ISSUES + 1))
          fi
        done < /tmp/gosqlx-files.txt

        echo "::endgroup::"

        # Add to summary
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Linting Results" >> $GITHUB_STEP_SUMMARY
        echo "Files with lint issues: $LINT_ISSUES" >> $GITHUB_STEP_SUMMARY

        # Note: Linting is advisory, doesn't fail build
        if [ $LINT_ISSUES -gt 0 ]; then
          echo "::warning::$LINT_ISSUES file(s) have linting suggestions"
        fi

    - name: Cleanup
      if: always()
      shell: bash
      run: |
        rm -f /tmp/gosqlx-files.txt
