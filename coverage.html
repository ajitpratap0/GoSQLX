
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ajitpratap0/GoSQLX/examples/cmd/example.go (6.1%)</option>
				
				<option value="file1">github.com/ajitpratap0/GoSQLX/examples/sql-formatter/main.go (0.0%)</option>
				
				<option value="file2">github.com/ajitpratap0/GoSQLX/examples/sql-validator/main.go (0.0%)</option>
				
				<option value="file3">github.com/ajitpratap0/GoSQLX/pkg/metrics/metrics.go (98.7%)</option>
				
				<option value="file4">github.com/ajitpratap0/GoSQLX/pkg/models/location.go (0.0%)</option>
				
				<option value="file5">github.com/ajitpratap0/GoSQLX/pkg/models/token_helpers.go (0.0%)</option>
				
				<option value="file6">github.com/ajitpratap0/GoSQLX/pkg/models/token_type.go (0.0%)</option>
				
				<option value="file7">github.com/ajitpratap0/GoSQLX/pkg/models/token_with_span.go (0.0%)</option>
				
				<option value="file8">github.com/ajitpratap0/GoSQLX/pkg/models/tokenizer_error.go (0.0%)</option>
				
				<option value="file9">github.com/ajitpratap0/GoSQLX/pkg/sql/ast/alter.go (0.0%)</option>
				
				<option value="file10">github.com/ajitpratap0/GoSQLX/pkg/sql/ast/ast.go (12.3%)</option>
				
				<option value="file11">github.com/ajitpratap0/GoSQLX/pkg/sql/ast/attached_token.go (0.0%)</option>
				
				<option value="file12">github.com/ajitpratap0/GoSQLX/pkg/sql/ast/create_table_builder.go (0.0%)</option>
				
				<option value="file13">github.com/ajitpratap0/GoSQLX/pkg/sql/ast/data_loading.go (0.0%)</option>
				
				<option value="file14">github.com/ajitpratap0/GoSQLX/pkg/sql/ast/data_type.go (0.0%)</option>
				
				<option value="file15">github.com/ajitpratap0/GoSQLX/pkg/sql/ast/data_type_utils.go (0.0%)</option>
				
				<option value="file16">github.com/ajitpratap0/GoSQLX/pkg/sql/ast/dml.go (0.0%)</option>
				
				<option value="file17">github.com/ajitpratap0/GoSQLX/pkg/sql/ast/function.go (33.3%)</option>
				
				<option value="file18">github.com/ajitpratap0/GoSQLX/pkg/sql/ast/object.go (33.3%)</option>
				
				<option value="file19">github.com/ajitpratap0/GoSQLX/pkg/sql/ast/operator.go (0.0%)</option>
				
				<option value="file20">github.com/ajitpratap0/GoSQLX/pkg/sql/ast/pool.go (43.2%)</option>
				
				<option value="file21">github.com/ajitpratap0/GoSQLX/pkg/sql/ast/span.go (0.0%)</option>
				
				<option value="file22">github.com/ajitpratap0/GoSQLX/pkg/sql/ast/trigger.go (76.7%)</option>
				
				<option value="file23">github.com/ajitpratap0/GoSQLX/pkg/sql/ast/types.go (0.0%)</option>
				
				<option value="file24">github.com/ajitpratap0/GoSQLX/pkg/sql/ast/value.go (63.5%)</option>
				
				<option value="file25">github.com/ajitpratap0/GoSQLX/pkg/sql/ast/visitor.go (76.5%)</option>
				
				<option value="file26">github.com/ajitpratap0/GoSQLX/pkg/sql/keywords/categories.go (30.4%)</option>
				
				<option value="file27">github.com/ajitpratap0/GoSQLX/pkg/sql/keywords/compound.go (0.0%)</option>
				
				<option value="file28">github.com/ajitpratap0/GoSQLX/pkg/sql/keywords/dialect.go (100.0%)</option>
				
				<option value="file29">github.com/ajitpratap0/GoSQLX/pkg/sql/keywords/dml.go (0.0%)</option>
				
				<option value="file30">github.com/ajitpratap0/GoSQLX/pkg/sql/keywords/keywords.go (74.3%)</option>
				
				<option value="file31">github.com/ajitpratap0/GoSQLX/pkg/sql/keywords/operations.go (0.0%)</option>
				
				<option value="file32">github.com/ajitpratap0/GoSQLX/pkg/sql/keywords/reserved.go (100.0%)</option>
				
				<option value="file33">github.com/ajitpratap0/GoSQLX/pkg/sql/models/token_types.go (0.0%)</option>
				
				<option value="file34">github.com/ajitpratap0/GoSQLX/pkg/sql/monitor/monitor.go (98.6%)</option>
				
				<option value="file35">github.com/ajitpratap0/GoSQLX/pkg/sql/parser/alter.go (0.0%)</option>
				
				<option value="file36">github.com/ajitpratap0/GoSQLX/pkg/sql/parser/parser.go (75.0%)</option>
				
				<option value="file37">github.com/ajitpratap0/GoSQLX/pkg/sql/token/pool.go (0.0%)</option>
				
				<option value="file38">github.com/ajitpratap0/GoSQLX/pkg/sql/token/token.go (0.0%)</option>
				
				<option value="file39">github.com/ajitpratap0/GoSQLX/pkg/sql/tokenizer/buffer.go (0.0%)</option>
				
				<option value="file40">github.com/ajitpratap0/GoSQLX/pkg/sql/tokenizer/error.go (0.0%)</option>
				
				<option value="file41">github.com/ajitpratap0/GoSQLX/pkg/sql/tokenizer/pool.go (91.7%)</option>
				
				<option value="file42">github.com/ajitpratap0/GoSQLX/pkg/sql/tokenizer/position.go (47.4%)</option>
				
				<option value="file43">github.com/ajitpratap0/GoSQLX/pkg/sql/tokenizer/string_literal.go (0.0%)</option>
				
				<option value="file44">github.com/ajitpratap0/GoSQLX/pkg/sql/tokenizer/tokenizer.go (67.1%)</option>
				
				<option value="file45">github.com/ajitpratap0/GoSQLX/pkg/sql/tokenizer/unicode.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"

        "github.com/ajitpratap0/GoSQLX/pkg/models"
        "github.com/ajitpratap0/GoSQLX/pkg/sql/tokenizer"
)

// Example demonstrates the Unicode support and proper resource management in the SQL tokenizer
func Example() ([]models.TokenWithSpan, error) <span class="cov8" title="1">{
        // Sample SQL query with Unicode identifiers and string literals
        // This demonstrates the tokenizer's ability to handle Japanese characters
        query := `
                SELECT
                        "名前" as name,
                        "年齢" as age,
                        COUNT(*) as order_count
                FROM "ユーザー" u
                JOIN "注文" o ON u.id = o.user_id
                WHERE
                        u."国" = '日本'
                        AND u."都市" = '東京'
                        AND o."価格" &gt; 1000
                GROUP BY "名前", "年齢"
                HAVING COUNT(*) &gt; 5
                ORDER BY order_count DESC;
        `

        // Get a tokenizer from the pool for proper resource management
        t := tokenizer.GetTokenizer()
        defer tokenizer.PutTokenizer(t) // Always return to pool when done

        // Tokenize the query - this returns the actual tokens produced by the tokenizer
        tokens, err := t.Tokenize([]byte(query))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error tokenizing query: %v", err)
        }</span>

        // Return the actual tokens, not hardcoded expectations
        <span class="cov8" title="1">return tokens, nil</span>
}

func main() <span class="cov0" title="0">{
        fmt.Println("GoSQLX Tokenizer Example - Unicode SQL Tokenization")
        fmt.Println("===================================================")

        // Demonstrate the main example
        fmt.Println("\n1. Basic Unicode SQL Tokenization:")
        fmt.Println("-----------------------------------")
        tokens, err := Example()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("Successfully tokenized SQL query into %d tokens\n\n", len(tokens))

        // Show a sample of tokens (not all to keep output manageable)
        fmt.Println("Sample Token Details (first 15 tokens):")
        fmt.Println("Type                     | Value                    | Position")
        fmt.Println("-------------------------|--------------------------|----------------")

        count := 0
        for _, token := range tokens </span><span class="cov0" title="0">{
                if token.Token.Type == models.TokenTypeEOF </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">position := fmt.Sprintf("Line %d, Col %d", token.Start.Line, token.Start.Column)
                typeName := getTokenTypeName(token.Token.Type)
                fmt.Printf("%-24s | %-24q | %s\n", typeName, token.Token.Value, position)

                count++
                if count &gt;= 15 </span><span class="cov0" title="0">{
                        fmt.Printf("\n... and %d more tokens\n", len(tokens)-count-1) // -1 for EOF
                        break</span>
                }
        }

        // Demonstrate additional features
        <span class="cov0" title="0">fmt.Println("\n2. Error Handling Example:")
        fmt.Println("--------------------------")
        demonstrateErrorHandling()

        fmt.Println("\n3. Resource Management Example:")
        fmt.Println("--------------------------------")
        demonstrateResourceManagement()

        // Educational summary
        fmt.Println("\n4. Key Features Demonstrated:")
        fmt.Println("------------------------------")
        fmt.Println("✓ Unicode character support (Japanese SQL identifiers and strings)")
        fmt.Println("✓ Proper quoted identifier handling with double quotes")
        fmt.Println("✓ Single-quoted string literals")
        fmt.Println("✓ Complex SQL construct recognition (GROUP BY, ORDER BY, etc.)")
        fmt.Println("✓ Efficient resource management using object pools")
        fmt.Println("✓ Position tracking for error reporting and debugging")
        fmt.Println("✓ Comprehensive error handling for malformed SQL")

        fmt.Println("\n5. Performance Characteristics:")
        fmt.Println("--------------------------------")
        fmt.Println("• Up to 2.5M operations/second")
        fmt.Println("• 60-80% memory reduction with object pooling")
        fmt.Println("• Zero-copy tokenization")
        fmt.Println("• Race-free concurrent usage")</span>
}

// demonstrateErrorHandling shows how the tokenizer handles malformed SQL
func demonstrateErrorHandling() <span class="cov0" title="0">{
        malformedSQL := `SELECT "unclosed_quote FROM table;`

        t := tokenizer.GetTokenizer()
        defer tokenizer.PutTokenizer(t)

        _, err := t.Tokenize([]byte(malformedSQL))
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("✓ Properly caught error in malformed SQL: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("✗ No error detected (unexpected)")
        }</span>
}

// demonstrateResourceManagement shows the importance of proper cleanup
func demonstrateResourceManagement() <span class="cov0" title="0">{
        fmt.Println("Processing multiple queries efficiently using pooled tokenizers:")

        queries := []string{
                `SELECT * FROM users;`,
                `INSERT INTO logs (message) VALUES ('test');`,
                `UPDATE settings SET value = 42 WHERE key = 'count';`,
                `DELETE FROM sessions WHERE expired = true;`,
        }

        for i, query := range queries </span><span class="cov0" title="0">{
                // Get tokenizer from pool
                t := tokenizer.GetTokenizer()

                tokens, err := t.Tokenize([]byte(query))
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("  Query %d error: %v\n", i+1, err)
                        tokenizer.PutTokenizer(t) // Still return to pool on error
                        continue</span>
                }

                <span class="cov0" title="0">fmt.Printf("  ✓ Query %d: Successfully tokenized into %d tokens\n", i+1, len(tokens))

                // Return to pool when done
                tokenizer.PutTokenizer(t)</span>
        }

        <span class="cov0" title="0">fmt.Println("✓ All tokenizers returned to pool for reuse")</span>
}

// getTokenTypeName returns a human-readable name for the token type
func getTokenTypeName(tokenType models.TokenType) string <span class="cov0" title="0">{
        switch tokenType </span>{
        case models.TokenTypeEOF:<span class="cov0" title="0">
                return "EOF"</span>
        case models.TokenTypeIdentifier:<span class="cov0" title="0">
                return "IDENTIFIER"</span>
        case models.TokenTypeNumber:<span class="cov0" title="0">
                return "NUMBER"</span>
        case models.TokenTypeString:<span class="cov0" title="0">
                return "STRING"</span>
        case models.TokenTypeSingleQuotedString:<span class="cov0" title="0">
                return "SINGLE_QUOTED_STRING"</span>
        case models.TokenTypeDoubleQuotedString:<span class="cov0" title="0">
                return "DOUBLE_QUOTED_STRING"</span>
        case models.TokenTypeSelect:<span class="cov0" title="0">
                return "SELECT"</span>
        case models.TokenTypeFrom:<span class="cov0" title="0">
                return "FROM"</span>
        case models.TokenTypeWhere:<span class="cov0" title="0">
                return "WHERE"</span>
        case models.TokenTypeJoin:<span class="cov0" title="0">
                return "JOIN"</span>
        case models.TokenTypeOn:<span class="cov0" title="0">
                return "ON"</span>
        case models.TokenTypeAnd:<span class="cov0" title="0">
                return "AND"</span>
        case models.TokenTypeOr:<span class="cov0" title="0">
                return "OR"</span>
        case models.TokenTypeAs:<span class="cov0" title="0">
                return "AS"</span>
        case models.TokenTypeGroupBy:<span class="cov0" title="0">
                return "GROUP BY"</span>
        case models.TokenTypeOrderBy:<span class="cov0" title="0">
                return "ORDER BY"</span>
        case models.TokenTypeHaving:<span class="cov0" title="0">
                return "HAVING"</span>
        case models.TokenTypeCount:<span class="cov0" title="0">
                return "COUNT"</span>
        case models.TokenTypeDesc:<span class="cov0" title="0">
                return "DESC"</span>
        case models.TokenTypeComma:<span class="cov0" title="0">
                return "COMMA"</span>
        case models.TokenTypeSemicolon:<span class="cov0" title="0">
                return "SEMICOLON"</span>
        case models.TokenTypeLParen:<span class="cov0" title="0">
                return "LPAREN"</span>
        case models.TokenTypeRParen:<span class="cov0" title="0">
                return "RPAREN"</span>
        case models.TokenTypePeriod:<span class="cov0" title="0">
                return "PERIOD"</span>
        case models.TokenTypeEq:<span class="cov0" title="0">
                return "EQ"</span>
        case models.TokenTypeGt:<span class="cov0" title="0">
                return "GT"</span>
        case models.TokenTypeMul:<span class="cov0" title="0">
                return "MUL"</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("TOKEN_%d", tokenType)</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "flag"
        "fmt"
        "os"
        "strings"

        "github.com/ajitpratap0/GoSQLX/pkg/sql/tokenizer"
)

func main() <span class="cov0" title="0">{
        var (
                input   = flag.String("input", "", "Input SQL file")
                output  = flag.String("output", "", "Output file (default: stdout)")
                indent  = flag.Int("indent", 2, "Indentation spaces")
                upper   = flag.Bool("upper", true, "Uppercase keywords")
                compact = flag.Bool("compact", false, "Compact format")
        )
        flag.Parse()

        if *input == "" &amp;&amp; flag.NArg() == 0 </span><span class="cov0" title="0">{
                fmt.Println("SQL Formatter - Format SQL queries using GoSQLX")
                fmt.Println("\nUsage:")
                fmt.Println("  sql-formatter -input query.sql")
                fmt.Println("  sql-formatter -input query.sql -output formatted.sql")
                fmt.Println("  sql-formatter \"SELECT * FROM users\"")
                fmt.Println("\nOptions:")
                flag.PrintDefaults()
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">var sql string
        if *input != "" </span><span class="cov0" title="0">{
                content, err := os.ReadFile(*input)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error reading file: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">sql = string(content)</span>
        } else<span class="cov0" title="0"> {
                sql = strings.Join(flag.Args(), " ")
        }</span>

        <span class="cov0" title="0">formatted, err := formatSQL(sql, FormatOptions{
                IndentSize: *indent,
                Uppercase:  *upper,
                Compact:    *compact,
        })

        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error formatting SQL: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if *output != "" </span><span class="cov0" title="0">{
                err = os.WriteFile(*output, []byte(formatted), 0644)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error writing output: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">fmt.Printf("Formatted SQL written to %s\n", *output)</span>
        } else<span class="cov0" title="0"> {
                fmt.Println(formatted)
        }</span>
}

type FormatOptions struct {
        IndentSize int
        Uppercase  bool
        Compact    bool
}

func formatSQL(sql string, opts FormatOptions) (string, error) <span class="cov0" title="0">{
        // Tokenize
        tkz := tokenizer.GetTokenizer()
        defer tokenizer.PutTokenizer(tkz)

        tokens, err := tkz.Tokenize([]byte(sql))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("tokenization failed: %w", err)
        }</span>

        <span class="cov0" title="0">if len(tokens) == 0 </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">var result strings.Builder
        indentLevel := 0
        newLine := true
        // lastWasKeyword := false  // Removed: unused variable

        // Keywords that increase indent - removed as unused
        // indentKeywords := map[string]bool{
        //         "SELECT": true, "FROM": true, "WHERE": true,
        //         "GROUP": true, "HAVING": true, "ORDER": true,
        //         "JOIN": true, "LEFT": true, "RIGHT": true,
        //         "INNER": true, "OUTER": true, "ON": true,
        // }

        // Keywords that should be on new line
        newLineKeywords := map[string]bool{
                "SELECT": true, "FROM": true, "WHERE": true,
                "GROUP": true, "HAVING": true, "ORDER": true,
                "JOIN": true, "LEFT": true, "RIGHT": true,
                "INNER": true, "OUTER": true, "LIMIT": true,
                "UNION": true, "INTERSECT": true, "EXCEPT": true,
        }

        for i, token := range tokens </span><span class="cov0" title="0">{
                value := string(token.Token.Value)
                upperValue := strings.ToUpper(value)

                // Check if it's a keyword
                isKeyword := isKeyword(upperValue)

                // Handle formatting
                if !opts.Compact </span><span class="cov0" title="0">{
                        // Check if we need a new line
                        if isKeyword &amp;&amp; newLineKeywords[upperValue] &amp;&amp; i &gt; 0 </span><span class="cov0" title="0">{
                                result.WriteString("\n")
                                newLine = true
                        }</span>

                        // Add indentation
                        <span class="cov0" title="0">if newLine &amp;&amp; !opts.Compact </span><span class="cov0" title="0">{
                                result.WriteString(strings.Repeat(" ", indentLevel*opts.IndentSize))
                                newLine = false
                        }</span>
                }

                // Write the token
                <span class="cov0" title="0">if isKeyword &amp;&amp; opts.Uppercase </span><span class="cov0" title="0">{
                        result.WriteString(upperValue)
                }</span> else<span class="cov0" title="0"> {
                        result.WriteString(value)
                }</span>

                // Add space after token (except for last token or special characters)
                <span class="cov0" title="0">if i &lt; len(tokens)-1 </span><span class="cov0" title="0">{
                        nextValue := string(tokens[i+1].Token.Value)
                        if !isSpecialChar(value) &amp;&amp; !isSpecialChar(nextValue) </span><span class="cov0" title="0">{
                                result.WriteString(" ")
                        }</span>
                }

                // lastWasKeyword = isKeyword  // Removed: unused variable
        }

        <span class="cov0" title="0">return result.String(), nil</span>
}

func isKeyword(word string) bool <span class="cov0" title="0">{
        keywords := []string{
                "SELECT", "FROM", "WHERE", "AND", "OR", "NOT",
                "INSERT", "INTO", "VALUES", "UPDATE", "SET",
                "DELETE", "CREATE", "TABLE", "INDEX", "VIEW",
                "ALTER", "DROP", "JOIN", "LEFT", "RIGHT",
                "INNER", "OUTER", "ON", "AS", "GROUP", "BY",
                "HAVING", "ORDER", "LIMIT", "OFFSET", "UNION",
                "ALL", "DISTINCT", "CASE", "WHEN", "THEN",
                "ELSE", "END", "NULL", "IS", "IN", "EXISTS",
                "BETWEEN", "LIKE", "ASC", "DESC",
        }

        for _, k := range keywords </span><span class="cov0" title="0">{
                if k == word </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func isSpecialChar(s string) bool <span class="cov0" title="0">{
        return s == "(" || s == ")" || s == "," || s == ";" || s == "."
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "bufio"
        "flag"
        "fmt"
        "io"
        "os"
        "strings"

        "github.com/ajitpratap0/GoSQLX/pkg/sql/parser"
        "github.com/ajitpratap0/GoSQLX/pkg/sql/token"
        "github.com/ajitpratap0/GoSQLX/pkg/sql/tokenizer"
)

func main() <span class="cov0" title="0">{
        var (
                file    = flag.String("file", "", "SQL file to validate")
                query   = flag.String("query", "", "SQL query to validate")
                dialect = flag.String("dialect", "postgres", "SQL dialect (postgres, mysql, mssql, oracle, sqlite)")
                verbose = flag.Bool("verbose", false, "Show detailed output")
        )
        flag.Parse()

        if *file == "" &amp;&amp; *query == "" </span><span class="cov0" title="0">{
                fmt.Println("SQL Validator - Validate SQL syntax using GoSQLX")
                fmt.Println("\nUsage:")
                fmt.Println("  sql-validator -query \"SELECT * FROM users\"")
                fmt.Println("  sql-validator -file queries.sql")
                fmt.Println("  cat queries.sql | sql-validator")
                fmt.Println("\nOptions:")
                flag.PrintDefaults()
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">var input string
        if *file != "" </span><span class="cov0" title="0">{
                content, err := os.ReadFile(*file)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error reading file: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">input = string(content)</span>
        } else<span class="cov0" title="0"> if *query != "" </span><span class="cov0" title="0">{
                input = *query
        }</span> else<span class="cov0" title="0"> {
                // Read from stdin
                reader := bufio.NewReader(os.Stdin)
                content, err := io.ReadAll(reader)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error reading stdin: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">input = string(content)</span>
        }

        // Split by semicolon for multiple queries
        <span class="cov0" title="0">queries := splitQueries(input)

        fmt.Printf("Validating %d SQL %s using %s dialect...\n",
                len(queries),
                pluralize("query", len(queries)),
                *dialect)

        errors := 0
        warnings := 0

        for i, query := range queries </span><span class="cov0" title="0">{
                if strings.TrimSpace(query) == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if *verbose </span><span class="cov0" title="0">{
                        fmt.Printf("\n--- Query %d ---\n", i+1)
                        fmt.Println(truncate(query, 100))
                }</span>

                <span class="cov0" title="0">result := validateSQL(query, *dialect, *verbose)

                if result.Error != nil </span><span class="cov0" title="0">{
                        errors++
                        fmt.Printf("❌ Query %d: INVALID\n", i+1)
                        fmt.Printf("   Error: %v\n", result.Error)
                        if result.Line &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("   Location: Line %d, Column %d\n", result.Line, result.Column)
                        }</span>
                } else<span class="cov0" title="0"> {
                        fmt.Printf("✅ Query %d: VALID\n", i+1)
                        if *verbose </span><span class="cov0" title="0">{
                                fmt.Printf("   Type: %s\n", result.StatementType)
                                fmt.Printf("   Tokens: %d\n", result.TokenCount)
                                if len(result.Tables) &gt; 0 </span><span class="cov0" title="0">{
                                        fmt.Printf("   Tables: %s\n", strings.Join(result.Tables, ", "))
                                }</span>
                        }
                }

                <span class="cov0" title="0">if len(result.Warnings) &gt; 0 </span><span class="cov0" title="0">{
                        warnings += len(result.Warnings)
                        for _, warning := range result.Warnings </span><span class="cov0" title="0">{
                                fmt.Printf("   ⚠️  Warning: %s\n", warning)
                        }</span>
                }
        }

        // Summary
        <span class="cov0" title="0">fmt.Printf("\n=== Summary ===\n")
        fmt.Printf("Total queries: %d\n", len(queries))
        fmt.Printf("Valid: %d\n", len(queries)-errors)
        fmt.Printf("Invalid: %d\n", errors)
        if warnings &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Warnings: %d\n", warnings)
        }</span>

        <span class="cov0" title="0">if errors &gt; 0 </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}

type ValidationResult struct {
        Valid         bool
        Error         error
        Line          int
        Column        int
        StatementType string
        TokenCount    int
        Tables        []string
        Warnings      []string
}

func validateSQL(sql string, dialect string, verbose bool) ValidationResult <span class="cov0" title="0">{
        result := ValidationResult{Valid: true}

        // Get tokenizer
        tkz := tokenizer.GetTokenizer()
        defer tokenizer.PutTokenizer(tkz)

        // Tokenize
        tokens, err := tkz.Tokenize([]byte(sql))
        if err != nil </span><span class="cov0" title="0">{
                result.Valid = false
                result.Error = err
                // Try to extract position from error
                if tokErr, ok := err.(*tokenizer.TokenizerError); ok </span><span class="cov0" title="0">{
                        result.Line = tokErr.Location.Line
                        result.Column = tokErr.Location.Column
                }</span>
                <span class="cov0" title="0">return result</span>
        }

        <span class="cov0" title="0">result.TokenCount = len(tokens)

        // Parse
        p := parser.NewParser()
        defer p.Release()

        // Convert tokens for parser
        parserTokens := make([]token.Token, len(tokens))
        for i, t := range tokens </span><span class="cov0" title="0">{
                parserTokens[i] = token.Token{
                        Type:    token.Type(t.Token.Value), // Use the value as the type string
                        Literal: string(t.Token.Value),
                }
        }</span>

        <span class="cov0" title="0">ast, err := p.Parse(parserTokens)
        if err != nil </span><span class="cov0" title="0">{
                result.Valid = false
                result.Error = err
                return result
        }</span>

        // Extract metadata
        <span class="cov0" title="0">if ast != nil </span><span class="cov0" title="0">{
                result.StatementType = detectStatementType(parserTokens)
                result.Tables = extractTableNames(parserTokens)
                result.Warnings = checkForWarnings(parserTokens, dialect)
        }</span>

        <span class="cov0" title="0">return result</span>
}

func detectStatementType(tokens []token.Token) string <span class="cov0" title="0">{
        if len(tokens) == 0 </span><span class="cov0" title="0">{
                return "UNKNOWN"
        }</span>

        <span class="cov0" title="0">switch strings.ToUpper(tokens[0].Literal) </span>{
        case "SELECT":<span class="cov0" title="0">
                return "SELECT"</span>
        case "INSERT":<span class="cov0" title="0">
                return "INSERT"</span>
        case "UPDATE":<span class="cov0" title="0">
                return "UPDATE"</span>
        case "DELETE":<span class="cov0" title="0">
                return "DELETE"</span>
        case "CREATE":<span class="cov0" title="0">
                if len(tokens) &gt; 1 </span><span class="cov0" title="0">{
                        return "CREATE " + strings.ToUpper(tokens[1].Literal)
                }</span>
                <span class="cov0" title="0">return "CREATE"</span>
        case "ALTER":<span class="cov0" title="0">
                return "ALTER"</span>
        case "DROP":<span class="cov0" title="0">
                return "DROP"</span>
        default:<span class="cov0" title="0">
                return "OTHER"</span>
        }
}

func extractTableNames(tokens []token.Token) []string <span class="cov0" title="0">{
        tables := []string{}
        fromNext := false
        joinNext := false

        for _, token := range tokens </span><span class="cov0" title="0">{
                upper := strings.ToUpper(token.Literal)
                if upper == "FROM" || upper == "INTO" || upper == "UPDATE" </span><span class="cov0" title="0">{
                        fromNext = true
                }</span> else<span class="cov0" title="0"> if upper == "JOIN" </span><span class="cov0" title="0">{
                        joinNext = true
                }</span> else<span class="cov0" title="0"> if fromNext || joinNext </span><span class="cov0" title="0">{
                        if token.Type != "" </span><span class="cov0" title="0">{ // Identifier (non-empty type)
                                tables = append(tables, token.Literal)
                                fromNext = false
                                joinNext = false
                        }</span>
                }
        }

        <span class="cov0" title="0">return tables</span>
}

func checkForWarnings(tokens []token.Token, dialect string) []string <span class="cov0" title="0">{
        warnings := []string{}

        // Check for dialect-specific issues
        for _, token := range tokens </span><span class="cov0" title="0">{
                upper := strings.ToUpper(token.Literal)

                // MySQL-specific
                if dialect != "mysql" &amp;&amp; strings.Contains(token.Literal, "`") </span><span class="cov0" title="0">{
                        warnings = append(warnings, "Backtick identifiers are MySQL-specific")
                }</span>

                // PostgreSQL-specific
                <span class="cov0" title="0">if dialect != "postgres" &amp;&amp; (upper == "RETURNING" || upper == "ARRAY") </span><span class="cov0" title="0">{
                        warnings = append(warnings, fmt.Sprintf("%s is PostgreSQL-specific", upper))
                }</span>

                // SQL Server-specific
                <span class="cov0" title="0">if dialect != "mssql" &amp;&amp; strings.HasPrefix(token.Literal, "[") </span><span class="cov0" title="0">{
                        warnings = append(warnings, "Bracket identifiers are SQL Server-specific")
                }</span>
        }

        <span class="cov0" title="0">return warnings</span>
}

func splitQueries(input string) []string <span class="cov0" title="0">{
        // Simple split by semicolon (doesn't handle semicolons in strings)
        queries := strings.Split(input, ";")
        result := []string{}

        for _, q := range queries </span><span class="cov0" title="0">{
                trimmed := strings.TrimSpace(q)
                if trimmed != "" </span><span class="cov0" title="0">{
                        result = append(result, trimmed)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

func truncate(s string, maxLen int) string <span class="cov0" title="0">{
        s = strings.ReplaceAll(s, "\n", " ")
        s = strings.ReplaceAll(s, "\t", " ")
        if len(s) &lt;= maxLen </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">return s[:maxLen] + "..."</span>
}

func pluralize(word string, count int) string <span class="cov0" title="0">{
        if count == 1 </span><span class="cov0" title="0">{
                return word
        }</span>
        <span class="cov0" title="0">return word + "s"</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package metrics provides production performance monitoring for GoSQLX
package metrics

import (
        "sync"
        "sync/atomic"
        "time"
)

// Metrics collects runtime performance data for GoSQLX operations
type Metrics struct {
        // Tokenization metrics
        tokenizeOperations int64 // Total tokenization operations
        tokenizeErrors     int64 // Total tokenization errors
        tokenizeDuration   int64 // Total tokenization time in nanoseconds
        lastTokenizeTime   int64 // Last tokenization timestamp

        // Memory metrics
        poolGets   int64 // Total pool retrievals
        poolPuts   int64 // Total pool returns
        poolMisses int64 // Pool misses (had to create new)

        // Query size metrics
        minQuerySize    int64 // Minimum query size processed
        maxQuerySize    int64 // Maximum query size processed
        totalQueryBytes int64 // Total bytes of SQL processed

        // Error tracking
        errorsByType map[string]int64
        errorsMutex  sync.RWMutex

        // Configuration
        enabled   bool
        startTime time.Time
}

// Global metrics instance
var globalMetrics = &amp;Metrics{
        enabled:      false,
        errorsByType: make(map[string]int64),
        startTime:    time.Now(),
        minQuerySize: -1, // -1 means not set yet
}

// Enable activates metrics collection
func Enable() <span class="cov8" title="1">{
        globalMetrics.enabled = true
        globalMetrics.startTime = time.Now()
}</span>

// Disable deactivates metrics collection
func Disable() <span class="cov8" title="1">{
        globalMetrics.enabled = false
}</span>

// IsEnabled returns whether metrics collection is active
func IsEnabled() bool <span class="cov8" title="1">{
        return globalMetrics.enabled
}</span>

// RecordTokenization records a tokenization operation
func RecordTokenization(duration time.Duration, querySize int, err error) <span class="cov8" title="1">{
        if !globalMetrics.enabled </span><span class="cov8" title="1">{
                return
        }</span>

        // Record operation
        <span class="cov8" title="1">atomic.AddInt64(&amp;globalMetrics.tokenizeOperations, 1)
        atomic.AddInt64(&amp;globalMetrics.tokenizeDuration, int64(duration))
        atomic.StoreInt64(&amp;globalMetrics.lastTokenizeTime, time.Now().UnixNano())

        // Record query size
        atomic.AddInt64(&amp;globalMetrics.totalQueryBytes, int64(querySize))

        // Update min/max query sizes
        currentMin := atomic.LoadInt64(&amp;globalMetrics.minQuerySize)
        if currentMin == -1 || int64(querySize) &lt; currentMin </span><span class="cov8" title="1">{
                atomic.StoreInt64(&amp;globalMetrics.minQuerySize, int64(querySize))
        }</span>

        <span class="cov8" title="1">currentMax := atomic.LoadInt64(&amp;globalMetrics.maxQuerySize)
        if int64(querySize) &gt; currentMax </span><span class="cov8" title="1">{
                atomic.StoreInt64(&amp;globalMetrics.maxQuerySize, int64(querySize))
        }</span>

        // Record errors
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                atomic.AddInt64(&amp;globalMetrics.tokenizeErrors, 1)

                // Record error by type
                errorType := err.Error()
                globalMetrics.errorsMutex.Lock()
                globalMetrics.errorsByType[errorType]++
                globalMetrics.errorsMutex.Unlock()
        }</span>
}

// RecordPoolGet records a tokenizer pool retrieval
func RecordPoolGet(fromPool bool) <span class="cov8" title="1">{
        if !globalMetrics.enabled </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">atomic.AddInt64(&amp;globalMetrics.poolGets, 1)
        if !fromPool </span><span class="cov8" title="1">{
                atomic.AddInt64(&amp;globalMetrics.poolMisses, 1)
        }</span>
}

// RecordPoolPut records a tokenizer pool return
func RecordPoolPut() <span class="cov8" title="1">{
        if !globalMetrics.enabled </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">atomic.AddInt64(&amp;globalMetrics.poolPuts, 1)</span>
}

// Stats represents current performance statistics
type Stats struct {
        // Basic counts
        TokenizeOperations int64   `json:"tokenize_operations"`
        TokenizeErrors     int64   `json:"tokenize_errors"`
        ErrorRate          float64 `json:"error_rate"`

        // Performance metrics
        AverageDuration     time.Duration `json:"average_duration"`
        OperationsPerSecond float64       `json:"operations_per_second"`

        // Memory/Pool metrics
        PoolGets     int64   `json:"pool_gets"`
        PoolPuts     int64   `json:"pool_puts"`
        PoolBalance  int64   `json:"pool_balance"`
        PoolMissRate float64 `json:"pool_miss_rate"`

        // Query size metrics
        MinQuerySize        int64   `json:"min_query_size"`
        MaxQuerySize        int64   `json:"max_query_size"`
        AverageQuerySize    float64 `json:"average_query_size"`
        TotalBytesProcessed int64   `json:"total_bytes_processed"`

        // Timing
        Uptime            time.Duration `json:"uptime"`
        LastOperationTime time.Time     `json:"last_operation_time"`

        // Error breakdown
        ErrorsByType map[string]int64 `json:"errors_by_type"`
}

// GetStats returns current performance statistics
func GetStats() Stats <span class="cov8" title="1">{
        if !globalMetrics.enabled </span><span class="cov8" title="1">{
                return Stats{}
        }</span>

        <span class="cov8" title="1">operations := atomic.LoadInt64(&amp;globalMetrics.tokenizeOperations)
        errors := atomic.LoadInt64(&amp;globalMetrics.tokenizeErrors)
        duration := atomic.LoadInt64(&amp;globalMetrics.tokenizeDuration)
        poolGets := atomic.LoadInt64(&amp;globalMetrics.poolGets)
        poolPuts := atomic.LoadInt64(&amp;globalMetrics.poolPuts)
        poolMisses := atomic.LoadInt64(&amp;globalMetrics.poolMisses)
        minSize := atomic.LoadInt64(&amp;globalMetrics.minQuerySize)
        maxSize := atomic.LoadInt64(&amp;globalMetrics.maxQuerySize)
        totalBytes := atomic.LoadInt64(&amp;globalMetrics.totalQueryBytes)
        lastOpTime := atomic.LoadInt64(&amp;globalMetrics.lastTokenizeTime)

        stats := Stats{
                TokenizeOperations:  operations,
                TokenizeErrors:      errors,
                PoolGets:            poolGets,
                PoolPuts:            poolPuts,
                PoolBalance:         poolGets - poolPuts,
                MinQuerySize:        minSize,
                MaxQuerySize:        maxSize,
                TotalBytesProcessed: totalBytes,
                Uptime:              time.Since(globalMetrics.startTime),
        }

        // Calculate rates and averages
        if operations &gt; 0 </span><span class="cov8" title="1">{
                stats.ErrorRate = float64(errors) / float64(operations)
                stats.AverageDuration = time.Duration(duration / operations)
                stats.AverageQuerySize = float64(totalBytes) / float64(operations)

                // Operations per second
                uptime := time.Since(globalMetrics.startTime).Seconds()
                if uptime &gt; 0 </span><span class="cov8" title="1">{
                        stats.OperationsPerSecond = float64(operations) / uptime
                }</span>
        }

        <span class="cov8" title="1">if poolGets &gt; 0 </span><span class="cov8" title="1">{
                stats.PoolMissRate = float64(poolMisses) / float64(poolGets)
        }</span>

        <span class="cov8" title="1">if lastOpTime &gt; 0 </span><span class="cov8" title="1">{
                stats.LastOperationTime = time.Unix(0, lastOpTime)
        }</span>

        // Copy error breakdown
        <span class="cov8" title="1">globalMetrics.errorsMutex.RLock()
        stats.ErrorsByType = make(map[string]int64)
        for errorType, count := range globalMetrics.errorsByType </span><span class="cov8" title="1">{
                stats.ErrorsByType[errorType] = count
        }</span>
        <span class="cov8" title="1">globalMetrics.errorsMutex.RUnlock()

        return stats</span>
}

// Reset clears all metrics (useful for testing)
func Reset() <span class="cov8" title="1">{
        atomic.StoreInt64(&amp;globalMetrics.tokenizeOperations, 0)
        atomic.StoreInt64(&amp;globalMetrics.tokenizeErrors, 0)
        atomic.StoreInt64(&amp;globalMetrics.tokenizeDuration, 0)
        atomic.StoreInt64(&amp;globalMetrics.lastTokenizeTime, 0)
        atomic.StoreInt64(&amp;globalMetrics.poolGets, 0)
        atomic.StoreInt64(&amp;globalMetrics.poolPuts, 0)
        atomic.StoreInt64(&amp;globalMetrics.poolMisses, 0)
        atomic.StoreInt64(&amp;globalMetrics.minQuerySize, -1)
        atomic.StoreInt64(&amp;globalMetrics.maxQuerySize, 0)
        atomic.StoreInt64(&amp;globalMetrics.totalQueryBytes, 0)

        globalMetrics.errorsMutex.Lock()
        globalMetrics.errorsByType = make(map[string]int64)
        globalMetrics.errorsMutex.Unlock()

        globalMetrics.startTime = time.Now()
}</span>

// LogStats logs current statistics (useful for debugging)
func LogStats() Stats <span class="cov0" title="0">{
        return GetStats()
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package models

// Location represents a position in the source code using 1-based indexing.
// Both Line and Column are 1-based to match SQL standards.
type Location struct {
        Line   int
        Column int
}

// Span represents a range in the source code
type Span struct {
        Start Location
        End   Location
}

// NewSpan creates a new span from start to end locations
func NewSpan(start, end Location) Span <span class="cov0" title="0">{
        return Span{Start: start, End: end}
}</span>

// Empty returns an empty span
func EmptySpan() Span <span class="cov0" title="0">{
        return Span{}
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package models

// NewToken creates a new Token with the given type and value
func NewToken(tokenType TokenType, value string) Token <span class="cov0" title="0">{
        return Token{
                Type:  tokenType,
                Value: value,
        }
}</span>

// NewTokenWithSpan creates a new TokenWithSpan with the given type, value, and location
func NewTokenWithSpan(tokenType TokenType, value string, start, end Location) TokenWithSpan <span class="cov0" title="0">{
        return TokenWithSpan{
                Token: Token{
                        Type:  tokenType,
                        Value: value,
                },
                Start: start,
                End:   end,
        }
}</span>

// NewEOFToken creates a new EOF token with span
func NewEOFToken(pos Location) TokenWithSpan <span class="cov0" title="0">{
        return TokenWithSpan{
                Token: Token{
                        Type:  TokenTypeEOF,
                        Value: "",
                },
                Start: pos,
                End:   pos,
        }
}</span>

// TokenAtLocation creates a new TokenWithSpan from a Token and location
func TokenAtLocation(token Token, start, end Location) TokenWithSpan <span class="cov0" title="0">{
        return TokenWithSpan{
                Token: token,
                Start: start,
                End:   end,
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package models

// TokenType represents the type of a SQL token
type TokenType int

// Token type constants with explicit values to avoid collisions
const (
        // Special tokens
        TokenTypeEOF     TokenType = 0
        TokenTypeUnknown TokenType = 1

        // Basic token types (10-29)
        TokenTypeWord        TokenType = 10
        TokenTypeNumber      TokenType = 11
        TokenTypeChar        TokenType = 12
        TokenTypeWhitespace  TokenType = 13
        TokenTypeIdentifier  TokenType = 14
        TokenTypePlaceholder TokenType = 15

        // String literals (30-49)
        TokenTypeString                   TokenType = 30 // Generic string type
        TokenTypeSingleQuotedString       TokenType = 31
        TokenTypeDoubleQuotedString       TokenType = 32
        TokenTypeTripleSingleQuotedString TokenType = 33
        TokenTypeTripleDoubleQuotedString TokenType = 34
        TokenTypeDollarQuotedString       TokenType = 35
        TokenTypeByteStringLiteral        TokenType = 36
        TokenTypeNationalStringLiteral    TokenType = 37
        TokenTypeEscapedStringLiteral     TokenType = 38
        TokenTypeUnicodeStringLiteral     TokenType = 39
        TokenTypeHexStringLiteral         TokenType = 40

        // Operators and punctuation (50-99)
        TokenTypeOperator        TokenType = 50 // Generic operator
        TokenTypeComma           TokenType = 51
        TokenTypeEq              TokenType = 52
        TokenTypeDoubleEq        TokenType = 53
        TokenTypeNeq             TokenType = 54
        TokenTypeLt              TokenType = 55
        TokenTypeGt              TokenType = 56
        TokenTypeLtEq            TokenType = 57
        TokenTypeGtEq            TokenType = 58
        TokenTypeSpaceship       TokenType = 59
        TokenTypePlus            TokenType = 60
        TokenTypeMinus           TokenType = 61
        TokenTypeMul             TokenType = 62
        TokenTypeDiv             TokenType = 63
        TokenTypeDuckIntDiv      TokenType = 64
        TokenTypeMod             TokenType = 65
        TokenTypeStringConcat    TokenType = 66
        TokenTypeLParen          TokenType = 67
        TokenTypeLeftParen       TokenType = 67 // Alias for compatibility
        TokenTypeRParen          TokenType = 68
        TokenTypeRightParen      TokenType = 68 // Alias for compatibility
        TokenTypePeriod          TokenType = 69
        TokenTypeDot             TokenType = 69 // Alias for compatibility
        TokenTypeColon           TokenType = 70
        TokenTypeDoubleColon     TokenType = 71
        TokenTypeAssignment      TokenType = 72
        TokenTypeSemicolon       TokenType = 73
        TokenTypeBackslash       TokenType = 74
        TokenTypeLBracket        TokenType = 75
        TokenTypeRBracket        TokenType = 76
        TokenTypeAmpersand       TokenType = 77
        TokenTypePipe            TokenType = 78
        TokenTypeCaret           TokenType = 79
        TokenTypeLBrace          TokenType = 80
        TokenTypeRBrace          TokenType = 81
        TokenTypeRArrow          TokenType = 82
        TokenTypeSharp           TokenType = 83
        TokenTypeTilde           TokenType = 84
        TokenTypeExclamationMark TokenType = 85
        TokenTypeAtSign          TokenType = 86
        TokenTypeQuestion        TokenType = 87

        // Compound operators (100-149)
        TokenTypeTildeAsterisk                      TokenType = 100
        TokenTypeExclamationMarkTilde               TokenType = 101
        TokenTypeExclamationMarkTildeAsterisk       TokenType = 102
        TokenTypeDoubleTilde                        TokenType = 103
        TokenTypeDoubleTildeAsterisk                TokenType = 104
        TokenTypeExclamationMarkDoubleTilde         TokenType = 105
        TokenTypeExclamationMarkDoubleTildeAsterisk TokenType = 106
        TokenTypeShiftLeft                          TokenType = 107
        TokenTypeShiftRight                         TokenType = 108
        TokenTypeOverlap                            TokenType = 109
        TokenTypeDoubleExclamationMark              TokenType = 110
        TokenTypeCaretAt                            TokenType = 111
        TokenTypePGSquareRoot                       TokenType = 112
        TokenTypePGCubeRoot                         TokenType = 113
        TokenTypeArrow                              TokenType = 114
        TokenTypeLongArrow                          TokenType = 115
        TokenTypeHashArrow                          TokenType = 116
        TokenTypeHashLongArrow                      TokenType = 117
        TokenTypeAtArrow                            TokenType = 118
        TokenTypeArrowAt                            TokenType = 119
        TokenTypeHashMinus                          TokenType = 120
        TokenTypeAtQuestion                         TokenType = 121
        TokenTypeAtAt                               TokenType = 122
        TokenTypeQuestionAnd                        TokenType = 123
        TokenTypeQuestionPipe                       TokenType = 124
        TokenTypeCustomBinaryOperator               TokenType = 125

        // SQL Keywords (200-399)
        TokenTypeKeyword TokenType = 200 // Generic keyword
        TokenTypeSelect  TokenType = 201
        TokenTypeFrom    TokenType = 202
        TokenTypeWhere   TokenType = 203
        TokenTypeJoin    TokenType = 204
        TokenTypeInner   TokenType = 205
        TokenTypeLeft    TokenType = 206
        TokenTypeRight   TokenType = 207
        TokenTypeOuter   TokenType = 208
        TokenTypeOn      TokenType = 209
        TokenTypeAs      TokenType = 210
        TokenTypeAnd     TokenType = 211
        TokenTypeOr      TokenType = 212
        TokenTypeNot     TokenType = 213
        TokenTypeIn      TokenType = 214
        TokenTypeLike    TokenType = 215
        TokenTypeBetween TokenType = 216
        TokenTypeIs      TokenType = 217
        TokenTypeNull    TokenType = 218
        TokenTypeTrue    TokenType = 219
        TokenTypeFalse   TokenType = 220
        TokenTypeCase    TokenType = 221
        TokenTypeWhen    TokenType = 222
        TokenTypeThen    TokenType = 223
        TokenTypeElse    TokenType = 224
        TokenTypeEnd     TokenType = 225
        TokenTypeGroup   TokenType = 226
        TokenTypeBy      TokenType = 227
        TokenTypeHaving  TokenType = 228
        TokenTypeOrder   TokenType = 229
        TokenTypeAsc     TokenType = 230
        TokenTypeDesc    TokenType = 231
        TokenTypeLimit   TokenType = 232
        TokenTypeOffset  TokenType = 233

        // Aggregate functions (250-269)
        TokenTypeCount TokenType = 250
        TokenTypeSum   TokenType = 251
        TokenTypeAvg   TokenType = 252
        TokenTypeMin   TokenType = 253
        TokenTypeMax   TokenType = 254

        // Compound keywords (270-299)
        TokenTypeGroupBy   TokenType = 270
        TokenTypeOrderBy   TokenType = 271
        TokenTypeLeftJoin  TokenType = 272
        TokenTypeRightJoin TokenType = 273
        TokenTypeInnerJoin TokenType = 274
        TokenTypeOuterJoin TokenType = 275
)

// String returns a string representation of the token type
func (t TokenType) String() string <span class="cov0" title="0">{
        switch t </span>{
        case TokenTypeEOF:<span class="cov0" title="0">
                return "EOF"</span>
        case TokenTypeUnknown:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        case TokenTypeWord:<span class="cov0" title="0">
                return "WORD"</span>
        case TokenTypeNumber:<span class="cov0" title="0">
                return "NUMBER"</span>
        case TokenTypeChar:<span class="cov0" title="0">
                return "CHAR"</span>
        case TokenTypeWhitespace:<span class="cov0" title="0">
                return "WHITESPACE"</span>
        case TokenTypeIdentifier:<span class="cov0" title="0">
                return "IDENTIFIER"</span>
        case TokenTypePlaceholder:<span class="cov0" title="0">
                return "PLACEHOLDER"</span>
        case TokenTypeString, TokenTypeSingleQuotedString:<span class="cov0" title="0">
                return "STRING"</span>
        case TokenTypeDoubleQuotedString:<span class="cov0" title="0">
                return "DOUBLE_QUOTED_STRING"</span>
        case TokenTypeOperator:<span class="cov0" title="0">
                return "OPERATOR"</span>
        case TokenTypeComma:<span class="cov0" title="0">
                return "COMMA"</span>
        case TokenTypeEq:<span class="cov0" title="0">
                return "EQ"</span>
        case TokenTypeLParen:<span class="cov0" title="0">
                return "LPAREN"</span>
        case TokenTypeRParen:<span class="cov0" title="0">
                return "RPAREN"</span>
        case TokenTypePeriod:<span class="cov0" title="0">
                return "PERIOD"</span>
        case TokenTypeSemicolon:<span class="cov0" title="0">
                return "SEMICOLON"</span>
        case TokenTypeKeyword:<span class="cov0" title="0">
                return "KEYWORD"</span>
        case TokenTypeSelect:<span class="cov0" title="0">
                return "SELECT"</span>
        case TokenTypeFrom:<span class="cov0" title="0">
                return "FROM"</span>
        case TokenTypeWhere:<span class="cov0" title="0">
                return "WHERE"</span>
        case TokenTypeAnd:<span class="cov0" title="0">
                return "AND"</span>
        case TokenTypeOr:<span class="cov0" title="0">
                return "OR"</span>
        default:<span class="cov0" title="0">
                return "TOKEN"</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package models

// TokenWithSpan represents a token with its location in the source code
type TokenWithSpan struct {
        Token Token
        Start Location
        End   Location
}

// WrapToken wraps a token with an empty location
func WrapToken(token Token) TokenWithSpan <span class="cov0" title="0">{
        emptyLoc := Location{}
        return TokenWithSpan{Token: token, Start: emptyLoc, End: emptyLoc}
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package models

// TokenizerError represents an error during tokenization
type TokenizerError struct {
        Message  string
        Location Location
}

func (e TokenizerError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package ast

import (
        "fmt"
)

// IndexType represents the indexing method used by an index
type IndexType int

const (
        BTree IndexType = iota
        Hash
)

func (t IndexType) String() string <span class="cov0" title="0">{
        switch t </span>{
        case BTree:<span class="cov0" title="0">
                return "BTREE"</span>
        case Hash:<span class="cov0" title="0">
                return "HASH"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// IndexOption represents MySQL index options
type IndexOption struct {
        Type    IndexOptionType
        Using   *IndexType // Used for Using
        Comment string     // Used for Comment
}

type IndexOptionType int

const (
        UsingIndex IndexOptionType = iota
        CommentIndex
)

func (opt *IndexOption) String() string <span class="cov0" title="0">{
        switch opt.Type </span>{
        case UsingIndex:<span class="cov0" title="0">
                return fmt.Sprintf("USING %s", opt.Using)</span>
        case CommentIndex:<span class="cov0" title="0">
                return fmt.Sprintf("COMMENT '%s'", opt.Comment)</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

// NullsDistinctOption represents Postgres unique index nulls handling
type NullsDistinctOption int

const (
        NullsDistinctNone NullsDistinctOption = iota
        NullsDistinct
        NullsNotDistinct
)

func (opt NullsDistinctOption) String() string <span class="cov0" title="0">{
        switch opt </span>{
        case NullsDistinct:<span class="cov0" title="0">
                return "NULLS DISTINCT"</span>
        case NullsNotDistinct:<span class="cov0" title="0">
                return "NULLS NOT DISTINCT"</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

// AlterStatement represents an ALTER statement
type AlterStatement struct {
        Type      AlterType
        Name      string // Name of the object being altered
        Operation AlterOperation
}

func (a *AlterStatement) statementNode()      {<span class="cov0" title="0">}</span>
func (a AlterStatement) TokenLiteral() string <span class="cov0" title="0">{ return "ALTER" }</span>
func (a AlterStatement) Children() []Node <span class="cov0" title="0">{
        if a.Operation != nil </span><span class="cov0" title="0">{
                return []Node{a.Operation}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// AlterType represents the type of object being altered
type AlterType int

const (
        AlterTypeTable AlterType = iota
        AlterTypeRole
        AlterTypePolicy
        AlterTypeConnector
)

// AlterOperation represents the operation to be performed
type AlterOperation interface {
        Node
        alterOperationNode()
}

// AlterTableOperation represents operations that can be performed on a table
type AlterTableOperation struct {
        Type             AlterTableOpType
        ColumnKeyword    bool                  // Used for AddColumn
        IfNotExists      bool                  // Used for AddColumn, AddPartition
        IfExists         bool                  // Used for DropColumn, DropConstraint, DropPartition
        ColumnDef        *ColumnDef            // Used for AddColumn
        ColumnPosition   *ColumnPosition       // Used for AddColumn, ChangeColumn, ModifyColumn
        Constraint       *TableConstraint      // Used for AddConstraint
        ProjectionName   *Ident                // Used for AddProjection, DropProjection
        ProjectionSelect *Select               // Used for AddProjection
        PartitionName    *Ident                // Used for MaterializeProjection, ClearProjection
        OldColumnName    *Ident                // Used for RenameColumn
        NewColumnName    *Ident                // Used for RenameColumn
        TableName        ObjectName            // Used for RenameTable
        NewTableName     ObjectName            // Used for RenameTable
        OldPartitions    []*Expression         // Used for RenamePartitions
        NewPartitions    []*Expression         // Used for RenamePartitions
        Partitions       []*Partition          // Used for AddPartitions
        DropBehavior     DropBehavior          // Used for DropColumn, DropConstraint
        ConstraintName   *Ident                // Used for DropConstraint
        OldName          *Ident                // Used for RenameConstraint
        NewName          *Ident                // Used for RenameConstraint
        ColumnName       *Ident                // Used for AlterColumn
        AlterColumnOp    *AlterColumnOperation // Used for AlterColumn
        CascadeDrops     bool                  // Used for DropColumn, DropConstraint
}

func (a *AlterTableOperation) alterOperationNode() {<span class="cov0" title="0">}</span>
func (a AlterTableOperation) TokenLiteral() string <span class="cov0" title="0">{ return "ALTER TABLE" }</span>
func (a AlterTableOperation) Children() []Node <span class="cov0" title="0">{
        var children []Node
        if a.ColumnDef != nil </span><span class="cov0" title="0">{
                children = append(children, a.ColumnDef)
        }</span>
        <span class="cov0" title="0">if a.Constraint != nil </span><span class="cov0" title="0">{
                children = append(children, a.Constraint)
        }</span>
        <span class="cov0" title="0">if a.ProjectionSelect != nil </span><span class="cov0" title="0">{
                children = append(children, a.ProjectionSelect)
        }</span>
        <span class="cov0" title="0">if a.AlterColumnOp != nil </span><span class="cov0" title="0">{
                children = append(children, a.AlterColumnOp)
        }</span>
        <span class="cov0" title="0">return children</span>
}

// AlterTableOpType represents the type of table alteration
type AlterTableOpType int

const (
        AddConstraint AlterTableOpType = iota
        AddColumn
        AddProjection
        AlterColumn
        ChangeColumn
        ClearProjection
        DropColumn
        DropConstraint
        DropPartition
        DropProjection
        MaterializeProjection
        ModifyColumn
        RenameColumn
        RenameConstraint
        RenamePartitions
        RenameTable
)

// RoleOption represents an option in ROLE statement
type RoleOption struct {
        Name  string
        Type  RoleOptionType
        Value interface{} // Can be bool or Expression depending on Type
}

type RoleOptionType int

const (
        BypassRLS RoleOptionType = iota
        ConnectionLimit
        CreateDB
        CreateRole
        Inherit
        Login
        Password
        Replication
        SuperUser
        ValidUntil
)

func (opt *RoleOption) String() string <span class="cov0" title="0">{
        switch opt.Type </span>{
        case BypassRLS:<span class="cov0" title="0">
                if opt.Value.(bool) </span><span class="cov0" title="0">{
                        return "BYPASSRLS"
                }</span>
                <span class="cov0" title="0">return "NOBYPASSRLS"</span>
        case ConnectionLimit:<span class="cov0" title="0">
                return fmt.Sprintf("CONNECTION LIMIT %v", opt.Value)</span>
        case CreateDB:<span class="cov0" title="0">
                if opt.Value.(bool) </span><span class="cov0" title="0">{
                        return "CREATEDB"
                }</span>
                <span class="cov0" title="0">return "NOCREATEDB"</span>
        case CreateRole:<span class="cov0" title="0">
                if opt.Value.(bool) </span><span class="cov0" title="0">{
                        return "CREATEROLE"
                }</span>
                <span class="cov0" title="0">return "NOCREATEROLE"</span>
        case Inherit:<span class="cov0" title="0">
                if opt.Value.(bool) </span><span class="cov0" title="0">{
                        return "INHERIT"
                }</span>
                <span class="cov0" title="0">return "NOINHERIT"</span>
        case Login:<span class="cov0" title="0">
                if opt.Value.(bool) </span><span class="cov0" title="0">{
                        return "LOGIN"
                }</span>
                <span class="cov0" title="0">return "NOLOGIN"</span>
        case Password:<span class="cov0" title="0">
                if opt.Value == nil </span><span class="cov0" title="0">{
                        return "PASSWORD NULL"
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("PASSWORD %v", opt.Value)</span>
        case Replication:<span class="cov0" title="0">
                if opt.Value.(bool) </span><span class="cov0" title="0">{
                        return "REPLICATION"
                }</span>
                <span class="cov0" title="0">return "NOREPLICATION"</span>
        case SuperUser:<span class="cov0" title="0">
                if opt.Value.(bool) </span><span class="cov0" title="0">{
                        return "SUPERUSER"
                }</span>
                <span class="cov0" title="0">return "NOSUPERUSER"</span>
        case ValidUntil:<span class="cov0" title="0">
                return fmt.Sprintf("VALID UNTIL %v", opt.Value)</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

// AlterRoleOperation represents operations that can be performed on a role
type AlterRoleOperation struct {
        Type        AlterRoleOpType
        NewName     string
        Options     []RoleOption
        MemberName  string
        ConfigName  string
        ConfigValue Expression
        InDatabase  string
}

func (a *AlterRoleOperation) alterOperationNode() {<span class="cov0" title="0">}</span>
func (a AlterRoleOperation) TokenLiteral() string <span class="cov0" title="0">{ return "ALTER ROLE" }</span>
func (a AlterRoleOperation) Children() []Node <span class="cov0" title="0">{
        var children []Node
        if a.ConfigValue != nil </span><span class="cov0" title="0">{
                children = append(children, a.ConfigValue)
        }</span>
        <span class="cov0" title="0">return children</span>
}

// AlterRoleOpType represents the type of role alteration
type AlterRoleOpType int

const (
        RenameRole AlterRoleOpType = iota
        AddMember
        DropMember
        SetConfig
        ResetConfig
        WithOptions
)

// AlterPolicyOperation represents operations that can be performed on a policy
type AlterPolicyOperation struct {
        Type      AlterPolicyOpType
        NewName   string
        To        []string
        Using     Expression
        WithCheck Expression
}

func (a *AlterPolicyOperation) alterOperationNode() {<span class="cov0" title="0">}</span>
func (a AlterPolicyOperation) TokenLiteral() string <span class="cov0" title="0">{ return "ALTER POLICY" }</span>
func (a AlterPolicyOperation) Children() []Node <span class="cov0" title="0">{
        var children []Node
        if a.Using != nil </span><span class="cov0" title="0">{
                children = append(children, a.Using)
        }</span>
        <span class="cov0" title="0">if a.WithCheck != nil </span><span class="cov0" title="0">{
                children = append(children, a.WithCheck)
        }</span>
        <span class="cov0" title="0">return children</span>
}

// AlterPolicyOpType represents the type of policy alteration
type AlterPolicyOpType int

const (
        RenamePolicy AlterPolicyOpType = iota
        ModifyPolicy
)

// AlterConnectorOperation represents operations that can be performed on a connector
type AlterConnectorOperation struct {
        Properties map[string]string
        URL        string
        Owner      *AlterConnectorOwner
}

func (a *AlterConnectorOperation) alterOperationNode() {<span class="cov0" title="0">}</span>
func (a AlterConnectorOperation) TokenLiteral() string <span class="cov0" title="0">{ return "ALTER CONNECTOR" }</span>
func (a AlterConnectorOperation) Children() []Node     <span class="cov0" title="0">{ return nil }</span>

// AlterConnectorOwner represents the new owner of a connector
type AlterConnectorOwner struct {
        IsUser bool
        Name   string
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package ast provides Abstract Syntax Tree (AST) node definitions for SQL statements.
// It includes comprehensive support for DDL and DML operations, Common Table Expressions (CTEs),
// set operations, and window functions, with object pooling for performance optimization.
//
// Phase 2 Features (v1.2.0+):
//   - WithClause and CommonTableExpr for CTE support
//   - SetOperation for UNION, EXCEPT, INTERSECT operations
//   - Recursive CTE support with proper AST representation
//   - Integration with all statement types
//
// Phase 2.5 Features (v1.3.0+):
//   - WindowSpec for window function specifications
//   - WindowFrame and WindowFrameBound for frame clauses
//   - Enhanced FunctionCall with Over field for window functions
//   - Complete window function AST integration
package ast

import "fmt"

// Node represents any node in the AST
type Node interface {
        TokenLiteral() string
        Children() []Node
}

// Statement represents a SQL statement
type Statement interface {
        Node
        statementNode()
}

// Expression represents a SQL expression
type Expression interface {
        Node
        expressionNode()
}

// WithClause represents a WITH clause in a SQL statement.
// It supports both simple and recursive Common Table Expressions (CTEs).
// Phase 2 Complete: Full parser integration with all statement types.
type WithClause struct {
        Recursive bool
        CTEs      []*CommonTableExpr
}

func (w *WithClause) statementNode()      {<span class="cov0" title="0">}</span>
func (w WithClause) TokenLiteral() string <span class="cov0" title="0">{ return "WITH" }</span>
func (w WithClause) Children() []Node <span class="cov0" title="0">{
        children := make([]Node, len(w.CTEs))
        for i, cte := range w.CTEs </span><span class="cov0" title="0">{
                children[i] = cte
        }</span>
        <span class="cov0" title="0">return children</span>
}

// CommonTableExpr represents a single Common Table Expression in a WITH clause.
// It supports optional column specifications and any statement type as the CTE query.
// Phase 2 Complete: Full parser support with column specifications.
type CommonTableExpr struct {
        Name         string
        Columns      []string
        Statement    Statement
        Materialized *bool // TODO: Add MATERIALIZED/NOT MATERIALIZED parsing support
}

func (c *CommonTableExpr) statementNode()      {<span class="cov0" title="0">}</span>
func (c CommonTableExpr) TokenLiteral() string <span class="cov0" title="0">{ return c.Name }</span>
func (c CommonTableExpr) Children() []Node <span class="cov0" title="0">{
        return []Node{c.Statement}
}</span>

// SetOperation represents set operations (UNION, EXCEPT, INTERSECT) between two statements.
// It supports the ALL modifier (e.g., UNION ALL) and proper left-associative parsing.
// Phase 2 Complete: Full parser support with left-associative precedence.
type SetOperation struct {
        Left     Statement
        Operator string // UNION, EXCEPT, INTERSECT
        Right    Statement
        All      bool // UNION ALL vs UNION
}

func (s *SetOperation) statementNode()      {<span class="cov0" title="0">}</span>
func (s SetOperation) TokenLiteral() string <span class="cov0" title="0">{ return s.Operator }</span>
func (s SetOperation) Children() []Node <span class="cov0" title="0">{
        return []Node{s.Left, s.Right}
}</span>

// JoinClause represents a JOIN clause in SQL
type JoinClause struct {
        Type      string // INNER, LEFT, RIGHT, FULL
        Left      TableReference
        Right     TableReference
        Condition Expression
}

func (j *JoinClause) expressionNode()     {<span class="cov0" title="0">}</span>
func (j JoinClause) TokenLiteral() string <span class="cov0" title="0">{ return j.Type + " JOIN" }</span>
func (j JoinClause) Children() []Node <span class="cov0" title="0">{
        children := []Node{&amp;j.Left, &amp;j.Right}
        if j.Condition != nil </span><span class="cov0" title="0">{
                children = append(children, j.Condition)
        }</span>
        <span class="cov0" title="0">return children</span>
}

// TableReference represents a table in FROM clause
type TableReference struct {
        Name  string
        Alias string
}

func (t *TableReference) statementNode()      {<span class="cov0" title="0">}</span>
func (t TableReference) TokenLiteral() string <span class="cov0" title="0">{ return t.Name }</span>
func (t TableReference) Children() []Node     <span class="cov0" title="0">{ return nil }</span>

// WindowSpec represents a window specification
type WindowSpec struct {
        Name        string
        PartitionBy []Expression
        OrderBy     []Expression
        FrameClause *WindowFrame
}

func (w *WindowSpec) statementNode()      {<span class="cov0" title="0">}</span>
func (w WindowSpec) TokenLiteral() string <span class="cov0" title="0">{ return "WINDOW" }</span>
func (w WindowSpec) Children() []Node <span class="cov0" title="0">{
        children := make([]Node, 0)
        children = append(children, nodifyExpressions(w.PartitionBy)...)
        children = append(children, nodifyExpressions(w.OrderBy)...)
        if w.FrameClause != nil </span><span class="cov0" title="0">{
                children = append(children, w.FrameClause)
        }</span>
        <span class="cov0" title="0">return children</span>
}

// WindowFrame represents window frame clause
type WindowFrame struct {
        Type  string // ROWS, RANGE
        Start WindowFrameBound
        End   *WindowFrameBound
}

func (w *WindowFrame) statementNode()      {<span class="cov0" title="0">}</span>
func (w WindowFrame) TokenLiteral() string <span class="cov0" title="0">{ return w.Type }</span>
func (w WindowFrame) Children() []Node     <span class="cov0" title="0">{ return nil }</span>

// WindowFrameBound represents window frame bound
type WindowFrameBound struct {
        Type  string // CURRENT ROW, UNBOUNDED PRECEDING, etc.
        Value Expression
}

// SelectStatement represents a SELECT SQL statement
type SelectStatement struct {
        With      *WithClause
        Distinct  bool
        Columns   []Expression
        From      []TableReference
        TableName string // Added for pool operations
        Joins     []JoinClause
        Where     Expression
        GroupBy   []Expression
        Having    Expression
        Windows   []WindowSpec
        OrderBy   []Expression
        Limit     *int
        Offset    *int
}

func (s *SelectStatement) statementNode()      {<span class="cov0" title="0">}</span>
func (s SelectStatement) TokenLiteral() string <span class="cov8" title="1">{ return "SELECT" }</span>

func (s SelectStatement) Children() []Node <span class="cov8" title="1">{
        children := make([]Node, 0)
        if s.With != nil </span><span class="cov0" title="0">{
                children = append(children, s.With)
        }</span>
        <span class="cov8" title="1">children = append(children, nodifyExpressions(s.Columns)...)
        for _, from := range s.From </span><span class="cov0" title="0">{
                children = append(children, &amp;from)
        }</span>
        <span class="cov8" title="1">for _, join := range s.Joins </span><span class="cov0" title="0">{
                children = append(children, &amp;join)
        }</span>
        <span class="cov8" title="1">if s.Where != nil </span><span class="cov8" title="1">{
                children = append(children, s.Where)
        }</span>
        <span class="cov8" title="1">children = append(children, nodifyExpressions(s.GroupBy)...)
        if s.Having != nil </span><span class="cov0" title="0">{
                children = append(children, s.Having)
        }</span>
        <span class="cov8" title="1">for _, window := range s.Windows </span><span class="cov0" title="0">{
                children = append(children, &amp;window)
        }</span>
        <span class="cov8" title="1">children = append(children, nodifyExpressions(s.OrderBy)...)
        return children</span>
}

// Helper function to convert []Expression to []Node
func nodifyExpressions(exprs []Expression) []Node <span class="cov8" title="1">{
        nodes := make([]Node, len(exprs))
        for i, expr := range exprs </span><span class="cov8" title="1">{
                nodes[i] = expr
        }</span>
        <span class="cov8" title="1">return nodes</span>
}

// Identifier represents a column or table name
type Identifier struct {
        Name  string
        Table string // Optional table qualifier
}

func (i *Identifier) expressionNode()     {<span class="cov0" title="0">}</span>
func (i Identifier) TokenLiteral() string <span class="cov8" title="1">{ return i.Name }</span>
func (i Identifier) Children() []Node     <span class="cov8" title="1">{ return nil }</span>

// FunctionCall represents a function call expression
type FunctionCall struct {
        Name      string
        Arguments []Expression // Renamed from Args for consistency
        Over      *WindowSpec  // For window functions
        Distinct  bool
        Filter    Expression // WHERE clause for aggregate functions
}

func (f *FunctionCall) expressionNode()     {<span class="cov0" title="0">}</span>
func (f FunctionCall) TokenLiteral() string <span class="cov0" title="0">{ return f.Name }</span>
func (f FunctionCall) Children() []Node <span class="cov0" title="0">{
        children := nodifyExpressions(f.Arguments)
        if f.Over != nil </span><span class="cov0" title="0">{
                children = append(children, f.Over)
        }</span>
        <span class="cov0" title="0">if f.Filter != nil </span><span class="cov0" title="0">{
                children = append(children, f.Filter)
        }</span>
        <span class="cov0" title="0">return children</span>
}

// CaseExpression represents a CASE expression
type CaseExpression struct {
        Value       Expression // Optional CASE value
        WhenClauses []WhenClause
        ElseClause  Expression
}

func (c *CaseExpression) expressionNode()     {<span class="cov0" title="0">}</span>
func (c CaseExpression) TokenLiteral() string <span class="cov0" title="0">{ return "CASE" }</span>
func (c CaseExpression) Children() []Node <span class="cov0" title="0">{
        children := make([]Node, 0)
        if c.Value != nil </span><span class="cov0" title="0">{
                children = append(children, c.Value)
        }</span>
        <span class="cov0" title="0">for _, when := range c.WhenClauses </span><span class="cov0" title="0">{
                children = append(children, &amp;when)
        }</span>
        <span class="cov0" title="0">if c.ElseClause != nil </span><span class="cov0" title="0">{
                children = append(children, c.ElseClause)
        }</span>
        <span class="cov0" title="0">return children</span>
}

// WhenClause represents WHEN ... THEN ... in CASE expression
type WhenClause struct {
        Condition Expression
        Result    Expression
}

func (w *WhenClause) expressionNode()     {<span class="cov0" title="0">}</span>
func (w WhenClause) TokenLiteral() string <span class="cov0" title="0">{ return "WHEN" }</span>
func (w WhenClause) Children() []Node <span class="cov0" title="0">{
        return []Node{w.Condition, w.Result}
}</span>

// ExistsExpression represents EXISTS (subquery)
type ExistsExpression struct {
        Subquery Statement
}

func (e *ExistsExpression) expressionNode()     {<span class="cov0" title="0">}</span>
func (e ExistsExpression) TokenLiteral() string <span class="cov0" title="0">{ return "EXISTS" }</span>
func (e ExistsExpression) Children() []Node <span class="cov0" title="0">{
        return []Node{e.Subquery}
}</span>

// InExpression represents expr IN (values)
type InExpression struct {
        Expr Expression
        List []Expression
        Not  bool
}

func (i *InExpression) expressionNode()     {<span class="cov0" title="0">}</span>
func (i InExpression) TokenLiteral() string <span class="cov0" title="0">{ return "IN" }</span>
func (i InExpression) Children() []Node <span class="cov0" title="0">{
        children := []Node{i.Expr}
        children = append(children, nodifyExpressions(i.List)...)
        return children
}</span>

// BetweenExpression represents expr BETWEEN lower AND upper
type BetweenExpression struct {
        Expr  Expression
        Lower Expression
        Upper Expression
        Not   bool
}

func (b *BetweenExpression) expressionNode()     {<span class="cov0" title="0">}</span>
func (b BetweenExpression) TokenLiteral() string <span class="cov0" title="0">{ return "BETWEEN" }</span>
func (b BetweenExpression) Children() []Node <span class="cov0" title="0">{
        return []Node{b.Expr, b.Lower, b.Upper}
}</span>

// BinaryExpression represents operations like WHERE column = value
type BinaryExpression struct {
        Left     Expression
        Operator string
        Right    Expression
        Not      bool                  // For NOT (expr)
        CustomOp *CustomBinaryOperator // For PostgreSQL custom operators
}

func (b *BinaryExpression) expressionNode() {<span class="cov0" title="0">}</span>

func (b *BinaryExpression) TokenLiteral() string <span class="cov8" title="1">{
        if b.CustomOp != nil </span><span class="cov0" title="0">{
                return b.CustomOp.String()
        }</span>
        <span class="cov8" title="1">return b.Operator</span>
}

func (b BinaryExpression) Children() []Node <span class="cov8" title="1">{ return []Node{b.Left, b.Right} }</span>

// LiteralValue represents a literal value in SQL
type LiteralValue struct {
        Value interface{}
        Type  string // INTEGER, FLOAT, STRING, BOOLEAN, NULL, etc.
}

func (l *LiteralValue) expressionNode()     {<span class="cov0" title="0">}</span>
func (l LiteralValue) TokenLiteral() string <span class="cov0" title="0">{ return fmt.Sprintf("%v", l.Value) }</span>
func (l LiteralValue) Children() []Node     <span class="cov0" title="0">{ return nil }</span>

// ListExpression represents a list of expressions (1, 2, 3)
type ListExpression struct {
        Values []Expression
}

func (l *ListExpression) expressionNode()     {<span class="cov0" title="0">}</span>
func (l ListExpression) TokenLiteral() string <span class="cov0" title="0">{ return "LIST" }</span>
func (l ListExpression) Children() []Node     <span class="cov0" title="0">{ return nodifyExpressions(l.Values) }</span>

// UnaryExpression represents operations like NOT expr
type UnaryExpression struct {
        Operator UnaryOperator
        Expr     Expression
}

func (u *UnaryExpression) expressionNode() {<span class="cov0" title="0">}</span>

func (u *UnaryExpression) TokenLiteral() string <span class="cov0" title="0">{
        return u.Operator.String()
}</span>

func (u UnaryExpression) Children() []Node <span class="cov0" title="0">{ return []Node{u.Expr} }</span>

// CastExpression represents CAST(expr AS type)
type CastExpression struct {
        Expr Expression
        Type string
}

func (c *CastExpression) expressionNode()     {<span class="cov0" title="0">}</span>
func (c CastExpression) TokenLiteral() string <span class="cov0" title="0">{ return "CAST" }</span>
func (c CastExpression) Children() []Node     <span class="cov0" title="0">{ return []Node{c.Expr} }</span>

// ExtractExpression represents EXTRACT(field FROM source)
type ExtractExpression struct {
        Field  string
        Source Expression
}

func (e *ExtractExpression) expressionNode()     {<span class="cov0" title="0">}</span>
func (e ExtractExpression) TokenLiteral() string <span class="cov0" title="0">{ return "EXTRACT" }</span>
func (e ExtractExpression) Children() []Node     <span class="cov0" title="0">{ return []Node{e.Source} }</span>

// PositionExpression represents POSITION(substr IN str)
type PositionExpression struct {
        Substr Expression
        Str    Expression
}

func (p *PositionExpression) expressionNode()     {<span class="cov0" title="0">}</span>
func (p PositionExpression) TokenLiteral() string <span class="cov0" title="0">{ return "POSITION" }</span>
func (p PositionExpression) Children() []Node     <span class="cov0" title="0">{ return []Node{p.Substr, p.Str} }</span>

// SubstringExpression represents SUBSTRING(str FROM start [FOR length])
type SubstringExpression struct {
        Str    Expression
        Start  Expression
        Length Expression
}

func (s *SubstringExpression) expressionNode()     {<span class="cov0" title="0">}</span>
func (s SubstringExpression) TokenLiteral() string <span class="cov0" title="0">{ return "SUBSTRING" }</span>
func (s SubstringExpression) Children() []Node <span class="cov0" title="0">{
        children := []Node{s.Str, s.Start}
        if s.Length != nil </span><span class="cov0" title="0">{
                children = append(children, s.Length)
        }</span>
        <span class="cov0" title="0">return children</span>
}

// InsertStatement represents an INSERT SQL statement
type InsertStatement struct {
        With       *WithClause
        TableName  string
        Columns    []Expression
        Values     []Expression
        Query      *SelectStatement // For INSERT ... SELECT
        Returning  []Expression
        OnConflict *OnConflict
}

func (i *InsertStatement) statementNode()      {<span class="cov0" title="0">}</span>
func (i InsertStatement) TokenLiteral() string <span class="cov0" title="0">{ return "INSERT" }</span>

func (i InsertStatement) Children() []Node <span class="cov0" title="0">{
        children := make([]Node, 0)
        if i.With != nil </span><span class="cov0" title="0">{
                children = append(children, i.With)
        }</span>
        <span class="cov0" title="0">children = append(children, nodifyExpressions(i.Columns)...)
        children = append(children, nodifyExpressions(i.Values)...)
        if i.Query != nil </span><span class="cov0" title="0">{
                children = append(children, i.Query)
        }</span>
        <span class="cov0" title="0">children = append(children, nodifyExpressions(i.Returning)...)
        if i.OnConflict != nil </span><span class="cov0" title="0">{
                children = append(children, i.OnConflict)
        }</span>
        <span class="cov0" title="0">return children</span>
}

// OnConflict represents ON CONFLICT DO UPDATE/NOTHING clause
type OnConflict struct {
        Target     []Expression // Target columns
        Constraint string       // Optional constraint name
        Action     OnConflictAction
}

func (o *OnConflict) expressionNode()     {<span class="cov0" title="0">}</span>
func (o OnConflict) TokenLiteral() string <span class="cov0" title="0">{ return "ON CONFLICT" }</span>
func (o OnConflict) Children() []Node <span class="cov0" title="0">{
        children := nodifyExpressions(o.Target)
        if o.Action.DoUpdate != nil </span><span class="cov0" title="0">{
                for _, update := range o.Action.DoUpdate </span><span class="cov0" title="0">{
                        children = append(children, &amp;update)
                }</span>
        }
        <span class="cov0" title="0">return children</span>
}

// OnConflictAction represents DO UPDATE/NOTHING in ON CONFLICT clause
type OnConflictAction struct {
        DoNothing bool
        DoUpdate  []UpdateExpression
        Where     Expression
}

// UpsertClause represents INSERT ... ON DUPLICATE KEY UPDATE
type UpsertClause struct {
        Updates []UpdateExpression
}

func (u *UpsertClause) expressionNode()     {<span class="cov0" title="0">}</span>
func (u UpsertClause) TokenLiteral() string <span class="cov0" title="0">{ return "ON DUPLICATE KEY UPDATE" }</span>
func (u UpsertClause) Children() []Node <span class="cov0" title="0">{
        children := make([]Node, len(u.Updates))
        for i, update := range u.Updates </span><span class="cov0" title="0">{
                children[i] = &amp;update
        }</span>
        <span class="cov0" title="0">return children</span>
}

// Values represents VALUES clause
type Values struct {
        Rows [][]Expression
}

func (v *Values) statementNode()      {<span class="cov0" title="0">}</span>
func (v Values) TokenLiteral() string <span class="cov0" title="0">{ return "VALUES" }</span>
func (v Values) Children() []Node <span class="cov0" title="0">{
        children := make([]Node, 0)
        for _, row := range v.Rows </span><span class="cov0" title="0">{
                children = append(children, nodifyExpressions(row)...)
        }</span>
        <span class="cov0" title="0">return children</span>
}

// UpdateStatement represents an UPDATE SQL statement
type UpdateStatement struct {
        With        *WithClause
        TableName   string
        Alias       string
        Updates     []UpdateExpression // Keep for backward compatibility
        Assignments []UpdateExpression // New field for consistency with span.go
        From        []TableReference
        Where       Expression
        Returning   []Expression
}

func (u *UpdateStatement) statementNode()      {<span class="cov0" title="0">}</span>
func (u UpdateStatement) TokenLiteral() string <span class="cov0" title="0">{ return "UPDATE" }</span>

func (u UpdateStatement) Children() []Node <span class="cov0" title="0">{
        children := make([]Node, 0)
        if u.With != nil </span><span class="cov0" title="0">{
                children = append(children, u.With)
        }</span>
        <span class="cov0" title="0">for _, update := range u.Updates </span><span class="cov0" title="0">{
                children = append(children, &amp;update)
        }</span>
        <span class="cov0" title="0">for _, assignment := range u.Assignments </span><span class="cov0" title="0">{
                children = append(children, &amp;assignment)
        }</span>
        <span class="cov0" title="0">for _, from := range u.From </span><span class="cov0" title="0">{
                children = append(children, &amp;from)
        }</span>
        <span class="cov0" title="0">if u.Where != nil </span><span class="cov0" title="0">{
                children = append(children, u.Where)
        }</span>
        <span class="cov0" title="0">children = append(children, nodifyExpressions(u.Returning)...)
        return children</span>
}

// CreateTableStatement represents a CREATE TABLE statement
type CreateTableStatement struct {
        IfNotExists bool
        Temporary   bool
        Name        string
        Columns     []ColumnDef
        Constraints []TableConstraint
        Inherits    []string
        PartitionBy *PartitionBy
        Options     []TableOption
}

func (c *CreateTableStatement) statementNode()      {<span class="cov0" title="0">}</span>
func (c CreateTableStatement) TokenLiteral() string <span class="cov0" title="0">{ return "CREATE TABLE" }</span>
func (c CreateTableStatement) Children() []Node <span class="cov0" title="0">{
        children := make([]Node, 0)
        for _, col := range c.Columns </span><span class="cov0" title="0">{
                children = append(children, &amp;col)
        }</span>
        <span class="cov0" title="0">for _, constraint := range c.Constraints </span><span class="cov0" title="0">{
                children = append(children, &amp;constraint)
        }</span>
        <span class="cov0" title="0">if c.PartitionBy != nil </span><span class="cov0" title="0">{
                children = append(children, c.PartitionBy)
        }</span>
        <span class="cov0" title="0">return children</span>
}

// ColumnDef represents a column definition in CREATE TABLE
type ColumnDef struct {
        Name        string
        Type        string
        Constraints []ColumnConstraint
}

func (c *ColumnDef) expressionNode()     {<span class="cov0" title="0">}</span>
func (c ColumnDef) TokenLiteral() string <span class="cov0" title="0">{ return c.Name }</span>
func (c ColumnDef) Children() []Node <span class="cov0" title="0">{
        children := make([]Node, len(c.Constraints))
        for i, constraint := range c.Constraints </span><span class="cov0" title="0">{
                children[i] = &amp;constraint
        }</span>
        <span class="cov0" title="0">return children</span>
}

// ColumnConstraint represents a column constraint
type ColumnConstraint struct {
        Type          string // NOT NULL, UNIQUE, PRIMARY KEY, etc.
        Default       Expression
        References    *ReferenceDefinition
        Check         Expression
        AutoIncrement bool
}

func (c *ColumnConstraint) expressionNode()     {<span class="cov0" title="0">}</span>
func (c ColumnConstraint) TokenLiteral() string <span class="cov0" title="0">{ return c.Type }</span>
func (c ColumnConstraint) Children() []Node <span class="cov0" title="0">{
        children := make([]Node, 0)
        if c.Default != nil </span><span class="cov0" title="0">{
                children = append(children, c.Default)
        }</span>
        <span class="cov0" title="0">if c.References != nil </span><span class="cov0" title="0">{
                children = append(children, c.References)
        }</span>
        <span class="cov0" title="0">if c.Check != nil </span><span class="cov0" title="0">{
                children = append(children, c.Check)
        }</span>
        <span class="cov0" title="0">return children</span>
}

// TableConstraint represents a table constraint
type TableConstraint struct {
        Name       string
        Type       string // PRIMARY KEY, UNIQUE, FOREIGN KEY, CHECK
        Columns    []string
        References *ReferenceDefinition
        Check      Expression
}

func (t *TableConstraint) expressionNode()     {<span class="cov0" title="0">}</span>
func (t TableConstraint) TokenLiteral() string <span class="cov0" title="0">{ return t.Type }</span>
func (t TableConstraint) Children() []Node <span class="cov0" title="0">{
        children := make([]Node, 0)
        if t.References != nil </span><span class="cov0" title="0">{
                children = append(children, t.References)
        }</span>
        <span class="cov0" title="0">if t.Check != nil </span><span class="cov0" title="0">{
                children = append(children, t.Check)
        }</span>
        <span class="cov0" title="0">return children</span>
}

// ReferenceDefinition represents a REFERENCES clause
type ReferenceDefinition struct {
        Table    string
        Columns  []string
        OnDelete string
        OnUpdate string
        Match    string
}

func (r *ReferenceDefinition) expressionNode()     {<span class="cov0" title="0">}</span>
func (r ReferenceDefinition) TokenLiteral() string <span class="cov0" title="0">{ return "REFERENCES" }</span>
func (r ReferenceDefinition) Children() []Node     <span class="cov0" title="0">{ return nil }</span>

// PartitionBy represents a PARTITION BY clause
type PartitionBy struct {
        Type     string // RANGE, LIST, HASH
        Columns  []string
        Boundary []Expression
}

func (p *PartitionBy) expressionNode()     {<span class="cov0" title="0">}</span>
func (p PartitionBy) TokenLiteral() string <span class="cov0" title="0">{ return "PARTITION BY" }</span>
func (p PartitionBy) Children() []Node     <span class="cov0" title="0">{ return nodifyExpressions(p.Boundary) }</span>

// TableOption represents table options like ENGINE, CHARSET, etc.
type TableOption struct {
        Name  string
        Value string
}

func (t *TableOption) expressionNode()     {<span class="cov0" title="0">}</span>
func (t TableOption) TokenLiteral() string <span class="cov0" title="0">{ return t.Name }</span>
func (t TableOption) Children() []Node     <span class="cov0" title="0">{ return nil }</span>

// UpdateExpression represents a column=value expression in UPDATE
type UpdateExpression struct {
        Column Expression
        Value  Expression
}

func (u *UpdateExpression) expressionNode()     {<span class="cov0" title="0">}</span>
func (u UpdateExpression) TokenLiteral() string <span class="cov0" title="0">{ return "=" }</span>
func (u UpdateExpression) Children() []Node     <span class="cov0" title="0">{ return []Node{u.Column, u.Value} }</span>

// DeleteStatement represents a DELETE SQL statement
type DeleteStatement struct {
        With      *WithClause
        TableName string
        Alias     string
        Using     []TableReference
        Where     Expression
        Returning []Expression
}

func (d *DeleteStatement) statementNode()      {<span class="cov0" title="0">}</span>
func (d DeleteStatement) TokenLiteral() string <span class="cov0" title="0">{ return "DELETE" }</span>

func (d DeleteStatement) Children() []Node <span class="cov0" title="0">{
        children := make([]Node, 0)
        if d.With != nil </span><span class="cov0" title="0">{
                children = append(children, d.With)
        }</span>
        <span class="cov0" title="0">for _, using := range d.Using </span><span class="cov0" title="0">{
                children = append(children, &amp;using)
        }</span>
        <span class="cov0" title="0">if d.Where != nil </span><span class="cov0" title="0">{
                children = append(children, d.Where)
        }</span>
        <span class="cov0" title="0">children = append(children, nodifyExpressions(d.Returning)...)
        return children</span>
}

// AlterTableStatement represents an ALTER TABLE statement
type AlterTableStatement struct {
        Table   string
        Actions []AlterTableAction
}

func (a *AlterTableStatement) statementNode()      {<span class="cov0" title="0">}</span>
func (a AlterTableStatement) TokenLiteral() string <span class="cov0" title="0">{ return "ALTER TABLE" }</span>
func (a AlterTableStatement) Children() []Node <span class="cov0" title="0">{
        children := make([]Node, len(a.Actions))
        for i, action := range a.Actions </span><span class="cov0" title="0">{
                children[i] = &amp;action
        }</span>
        <span class="cov0" title="0">return children</span>
}

// AlterTableAction represents an action in ALTER TABLE
type AlterTableAction struct {
        Type       string // ADD COLUMN, DROP COLUMN, MODIFY COLUMN, etc.
        ColumnName string
        ColumnDef  *ColumnDef
        Constraint *TableConstraint
}

func (a *AlterTableAction) expressionNode()     {<span class="cov0" title="0">}</span>
func (a AlterTableAction) TokenLiteral() string <span class="cov0" title="0">{ return a.Type }</span>
func (a AlterTableAction) Children() []Node <span class="cov0" title="0">{
        children := make([]Node, 0)
        if a.ColumnDef != nil </span><span class="cov0" title="0">{
                children = append(children, a.ColumnDef)
        }</span>
        <span class="cov0" title="0">if a.Constraint != nil </span><span class="cov0" title="0">{
                children = append(children, a.Constraint)
        }</span>
        <span class="cov0" title="0">return children</span>
}

// CreateIndexStatement represents a CREATE INDEX statement
type CreateIndexStatement struct {
        Unique      bool
        IfNotExists bool
        Name        string
        Table       string
        Columns     []IndexColumn
        Using       string
        Where       Expression
}

func (c *CreateIndexStatement) statementNode()      {<span class="cov0" title="0">}</span>
func (c CreateIndexStatement) TokenLiteral() string <span class="cov0" title="0">{ return "CREATE INDEX" }</span>
func (c CreateIndexStatement) Children() []Node <span class="cov0" title="0">{
        children := make([]Node, 0)
        for _, col := range c.Columns </span><span class="cov0" title="0">{
                children = append(children, &amp;col)
        }</span>
        <span class="cov0" title="0">if c.Where != nil </span><span class="cov0" title="0">{
                children = append(children, c.Where)
        }</span>
        <span class="cov0" title="0">return children</span>
}

// IndexColumn represents a column in an index definition
type IndexColumn struct {
        Column    string
        Collate   string
        Direction string // ASC, DESC
        NullsLast bool
}

func (i *IndexColumn) expressionNode()     {<span class="cov0" title="0">}</span>
func (i IndexColumn) TokenLiteral() string <span class="cov0" title="0">{ return i.Column }</span>
func (i IndexColumn) Children() []Node     <span class="cov0" title="0">{ return nil }</span>

// AST represents the root of the Abstract Syntax Tree
type AST struct {
        Statements []Statement
}

func (a AST) TokenLiteral() string <span class="cov0" title="0">{ return "" }</span>

func (a AST) Children() []Node <span class="cov8" title="1">{
        children := make([]Node, len(a.Statements))
        for i, stmt := range a.Statements </span><span class="cov8" title="1">{
                children[i] = stmt
        }</span>
        <span class="cov8" title="1">return children</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package ast

import (
        "fmt"
        "hash"
)

// AttachedToken is a wrapper over TokenWithSpan that ignores the token and source
// location in comparisons and hashing.
//
// This type is used when the token and location is not relevant for semantics,
// but is still needed for accurate source location tracking.
//
// Note: ALL AttachedTokens are equal.
//
// Examples:
//
// Same token, different location are equal:
//
//        // commas @ line 1, column 10
//        tok1 := NewTokenWithSpan(
//            Token{Type: Comma},
//            Span{Start: Location{Line: 1, Column: 10}, End: Location{Line: 1, Column: 11}},
//        )
//        // commas @ line 2, column 20
//        tok2 := NewTokenWithSpan(
//            Token{Type: Comma},
//            Span{Start: Location{Line: 2, Column: 20}, End: Location{Line: 2, Column: 21}},
//        )
//
//        // token with locations are *not* equal
//        fmt.Println(tok1 != tok2) // true
//        // attached tokens are equal
//        fmt.Println(AttachedToken{tok1} == AttachedToken{tok2}) // true
//
// Different token, different location are equal:
//
//        // commas @ line 1, column 10
//        tok1 := NewTokenWithSpan(
//            Token{Type: Comma},
//            Span{Start: Location{Line: 1, Column: 10}, End: Location{Line: 1, Column: 11}},
//        )
//        // period @ line 2, column 20
//        tok2 := NewTokenWithSpan(
//            Token{Type: Period},
//            Span{Start: Location{Line: 2, Column: 20}, End: Location{Line: 2, Column: 21}},
//        )
//
//        // token with locations are *not* equal
//        fmt.Println(tok1 != tok2) // true
//        // attached tokens are equal
//        fmt.Println(AttachedToken{tok1} == AttachedToken{tok2}) // true
type AttachedToken struct {
        Token TokenWithSpan
}

// NewAttachedToken creates a new AttachedToken from a TokenWithSpan
func NewAttachedToken(token TokenWithSpan) AttachedToken <span class="cov0" title="0">{
        return AttachedToken{Token: token}
}</span>

// Empty returns a new Empty AttachedToken
func (a AttachedToken) Empty() AttachedToken <span class="cov0" title="0">{
        return AttachedToken{Token: NewTokenWithSpanEOF()}
}</span>

// String implements fmt.Stringer
func (a AttachedToken) String() string <span class="cov0" title="0">{
        return a.Token.String()
}</span>

// GoString implements fmt.GoStringer
func (a AttachedToken) GoString() string <span class="cov0" title="0">{
        return fmt.Sprintf("AttachedToken{%#v}", a.Token)
}</span>

// Equal implements equality comparison
// Note: ALL AttachedTokens are equal
func (a AttachedToken) Equal(other AttachedToken) bool <span class="cov0" title="0">{
        return true
}</span>

// Compare implements comparison
// Note: ALL AttachedTokens are equal
func (a AttachedToken) Compare(other AttachedToken) int <span class="cov0" title="0">{
        return 0
}</span>

// Hash implements hashing
// Note: ALL AttachedTokens have the same hash
func (a AttachedToken) Hash(h hash.Hash) {<span class="cov0" title="0">
        // Do nothing - all AttachedTokens have the same hash
}</span>

// UnwrapToken returns the underlying TokenWithSpan
func (a AttachedToken) UnwrapToken() TokenWithSpan <span class="cov0" title="0">{
        return a.Token
}</span>

// WrapToken wraps a TokenWithSpan in an AttachedToken
func WrapToken(token TokenWithSpan) AttachedToken <span class="cov0" title="0">{
        return AttachedToken{Token: token}
}</span>

// TokenWithSpan represents a token with its source location span
type TokenWithSpan struct {
        Token Token
        Span  Span
}

// NewTokenWithSpan creates a new TokenWithSpan
func NewTokenWithSpan(token Token, span Span) TokenWithSpan <span class="cov0" title="0">{
        return TokenWithSpan{
                Token: token,
                Span:  span,
        }
}</span>

// NewTokenWithSpanEOF creates a new EOF TokenWithSpan
func NewTokenWithSpanEOF() TokenWithSpan <span class="cov0" title="0">{
        return TokenWithSpan{
                Token: Token{Type: EOF},
                Span:  Span{},
        }
}</span>

// String implements fmt.Stringer
func (t TokenWithSpan) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%v @ %v", t.Token, t.Span)
}</span>

// GoString implements fmt.GoStringer
func (t TokenWithSpan) GoString() string <span class="cov0" title="0">{
        return fmt.Sprintf("TokenWithSpan{Token: %#v, Span: %#v}", t.Token, t.Span)
}</span>

// Token represents a lexical token
type Token struct {
        Type TokenType
        // Add other token fields as needed
}

// TokenType represents the type of a token
type TokenType int

// Token types
const (
        EOF TokenType = iota
        Comma
        Period
        // Add other token types as needed
)

// String implements fmt.Stringer
func (t Token) String() string <span class="cov0" title="0">{
        switch t.Type </span>{
        case EOF:<span class="cov0" title="0">
                return "EOF"</span>
        case Comma:<span class="cov0" title="0">
                return ","</span>
        case Period:<span class="cov0" title="0">
                return "."</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("TokenType(%d)", t.Type)</span>
        }
}

// Span represents a source location span
type Span struct {
        Start Location
        End   Location
}

// String implements fmt.Stringer
func (s Span) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%v-%v", s.Start, s.End)
}</span>

// Location represents a source location
type Location struct {
        Line   int
        Column int
}

// String implements fmt.Stringer
func (l Location) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%d:%d", l.Line, l.Column)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package ast

import (
        "fmt"
)

// CreateTableBuilder helps in building and accessing a create table statement with more ease.
// Example:
//
//        builder := NewCreateTableBuilder(ObjectName{Idents: []Ident{{Value: "table_name"}}}).
//            SetIfNotExists(true).
//            SetColumns([]ColumnDef{{
//                Name:     Ident{Value: "c1"},
//                DataType: &amp;DataType{Variant: &amp;Int32Type{}},
//            }})
type CreateTableBuilder struct {
        OrReplace             bool
        Temporary             bool
        External              bool
        Global                *bool
        IfNotExists           bool
        Transient             bool
        Volatile              bool
        Iceberg               bool
        Name                  ObjectName
        Columns               []ColumnDef
        Constraints           []TableConstraint
        HiveDistribution      HiveDistributionStyle
        HiveFormats           *HiveFormat
        TableProperties       []SqlOption
        WithOptions           []SqlOption
        FileFormat            *FileFormat
        Location              *string
        Query                 *Query
        WithoutRowID          bool
        Like                  *ObjectName
        Clone                 *ObjectName
        Engine                *TableEngine
        Comment               *CommentDef
        AutoIncrementOffset   *uint32
        DefaultCharset        *string
        Collation             *string
        OnCommit              *OnCommit
        OnCluster             *Ident
        PrimaryKey            *Expr
        OrderBy               *OneOrManyWithParens[Expr]
        PartitionBy           *Expr
        ClusterBy             *WrappedCollection[[]Ident]
        ClusteredBy           *ClusteredBy
        Options               *[]SqlOption
        Strict                bool
        CopyGrants            bool
        EnableSchemaEvolution *bool
        ChangeTracking        *bool
        DataRetentionDays     *uint64
        MaxDataExtensionDays  *uint64
        DefaultDDLCollation   *string
        AggregationPolicy     *ObjectName
        RowAccessPolicy       *RowAccessPolicy
        Tags                  *[]Tag
        BaseLocation          *string
        ExternalVolume        *string
        Catalog               *string
        CatalogSync           *string
        SerializationPolicy   *StorageSerializationPolicy
}

// NewCreateTableBuilder creates a new CreateTableBuilder with default values
func NewCreateTableBuilder(name ObjectName) *CreateTableBuilder <span class="cov0" title="0">{
        return &amp;CreateTableBuilder{
                Name:             name,
                HiveDistribution: HiveDistributionNone,
        }
}</span>

// Build converts the builder into a CreateTable statement
func (b *CreateTableBuilder) Build() *StatementImpl <span class="cov0" title="0">{
        return &amp;StatementImpl{
                Variant: &amp;CreateTable{
                        OrReplace:             b.OrReplace,
                        Temporary:             b.Temporary,
                        External:              b.External,
                        Global:                b.Global,
                        IfNotExists:           b.IfNotExists,
                        Transient:             b.Transient,
                        Volatile:              b.Volatile,
                        Iceberg:               b.Iceberg,
                        Name:                  b.Name,
                        Columns:               b.Columns,
                        Constraints:           b.Constraints,
                        HiveDistribution:      b.HiveDistribution,
                        HiveFormats:           b.HiveFormats,
                        TableProperties:       b.TableProperties,
                        WithOptions:           b.WithOptions,
                        FileFormat:            b.FileFormat,
                        Location:              b.Location,
                        Query:                 b.Query,
                        WithoutRowID:          b.WithoutRowID,
                        Like:                  b.Like,
                        Clone:                 b.Clone,
                        Engine:                b.Engine,
                        Comment:               b.Comment,
                        AutoIncrementOffset:   b.AutoIncrementOffset,
                        DefaultCharset:        b.DefaultCharset,
                        Collation:             b.Collation,
                        OnCommit:              b.OnCommit,
                        OnCluster:             b.OnCluster,
                        PrimaryKey:            b.PrimaryKey,
                        OrderBy:               b.OrderBy,
                        PartitionBy:           b.PartitionBy,
                        ClusterBy:             b.ClusterBy,
                        ClusteredBy:           b.ClusteredBy,
                        Options:               b.Options,
                        Strict:                b.Strict,
                        CopyGrants:            b.CopyGrants,
                        EnableSchemaEvolution: b.EnableSchemaEvolution,
                        ChangeTracking:        b.ChangeTracking,
                        DataRetentionDays:     b.DataRetentionDays,
                        MaxDataExtensionDays:  b.MaxDataExtensionDays,
                        DefaultDDLCollation:   b.DefaultDDLCollation,
                        AggregationPolicy:     b.AggregationPolicy,
                        RowAccessPolicy:       b.RowAccessPolicy,
                        Tags:                  b.Tags,
                        BaseLocation:          b.BaseLocation,
                        ExternalVolume:        b.ExternalVolume,
                        Catalog:               b.Catalog,
                        CatalogSync:           b.CatalogSync,
                        SerializationPolicy:   b.SerializationPolicy,
                },
        }
}</span>

// FromStatement attempts to create a CreateTableBuilder from a Statement
func FromStatement(stmt *StatementImpl) (*CreateTableBuilder, error) <span class="cov0" title="0">{
        if createTable, ok := stmt.Variant.(*CreateTable); ok </span><span class="cov0" title="0">{
                return &amp;CreateTableBuilder{
                        OrReplace:             createTable.OrReplace,
                        Temporary:             createTable.Temporary,
                        External:              createTable.External,
                        Global:                createTable.Global,
                        IfNotExists:           createTable.IfNotExists,
                        Transient:             createTable.Transient,
                        Volatile:              createTable.Volatile,
                        Iceberg:               createTable.Iceberg,
                        Name:                  createTable.Name,
                        Columns:               createTable.Columns,
                        Constraints:           createTable.Constraints,
                        HiveDistribution:      createTable.HiveDistribution,
                        HiveFormats:           createTable.HiveFormats,
                        TableProperties:       createTable.TableProperties,
                        WithOptions:           createTable.WithOptions,
                        FileFormat:            createTable.FileFormat,
                        Location:              createTable.Location,
                        Query:                 createTable.Query,
                        WithoutRowID:          createTable.WithoutRowID,
                        Like:                  createTable.Like,
                        Clone:                 createTable.Clone,
                        Engine:                createTable.Engine,
                        Comment:               createTable.Comment,
                        AutoIncrementOffset:   createTable.AutoIncrementOffset,
                        DefaultCharset:        createTable.DefaultCharset,
                        Collation:             createTable.Collation,
                        OnCommit:              createTable.OnCommit,
                        OnCluster:             createTable.OnCluster,
                        PrimaryKey:            createTable.PrimaryKey,
                        OrderBy:               createTable.OrderBy,
                        PartitionBy:           createTable.PartitionBy,
                        ClusterBy:             createTable.ClusterBy,
                        ClusteredBy:           createTable.ClusteredBy,
                        Options:               createTable.Options,
                        Strict:                createTable.Strict,
                        CopyGrants:            createTable.CopyGrants,
                        EnableSchemaEvolution: createTable.EnableSchemaEvolution,
                        ChangeTracking:        createTable.ChangeTracking,
                        DataRetentionDays:     createTable.DataRetentionDays,
                        MaxDataExtensionDays:  createTable.MaxDataExtensionDays,
                        DefaultDDLCollation:   createTable.DefaultDDLCollation,
                        AggregationPolicy:     createTable.AggregationPolicy,
                        RowAccessPolicy:       createTable.RowAccessPolicy,
                        Tags:                  createTable.Tags,
                        BaseLocation:          createTable.BaseLocation,
                        ExternalVolume:        createTable.ExternalVolume,
                        Catalog:               createTable.Catalog,
                        CatalogSync:           createTable.CatalogSync,
                        SerializationPolicy:   createTable.SerializationPolicy,
                }, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("expected create table statement, but received: %v", stmt)</span>
}

// Fluent builder methods
func (b *CreateTableBuilder) SetOrReplace(v bool) *CreateTableBuilder      <span class="cov0" title="0">{ b.OrReplace = v; return b }</span>
func (b *CreateTableBuilder) SetTemporary(v bool) *CreateTableBuilder      <span class="cov0" title="0">{ b.Temporary = v; return b }</span>
func (b *CreateTableBuilder) SetExternal(v bool) *CreateTableBuilder       <span class="cov0" title="0">{ b.External = v; return b }</span>
func (b *CreateTableBuilder) SetGlobal(v *bool) *CreateTableBuilder        <span class="cov0" title="0">{ b.Global = v; return b }</span>
func (b *CreateTableBuilder) SetIfNotExists(v bool) *CreateTableBuilder    <span class="cov0" title="0">{ b.IfNotExists = v; return b }</span>
func (b *CreateTableBuilder) SetTransient(v bool) *CreateTableBuilder      <span class="cov0" title="0">{ b.Transient = v; return b }</span>
func (b *CreateTableBuilder) SetVolatile(v bool) *CreateTableBuilder       <span class="cov0" title="0">{ b.Volatile = v; return b }</span>
func (b *CreateTableBuilder) SetIceberg(v bool) *CreateTableBuilder        <span class="cov0" title="0">{ b.Iceberg = v; return b }</span>
func (b *CreateTableBuilder) SetColumns(v []ColumnDef) *CreateTableBuilder <span class="cov0" title="0">{ b.Columns = v; return b }</span>
func (b *CreateTableBuilder) SetConstraints(v []TableConstraint) *CreateTableBuilder <span class="cov0" title="0">{
        b.Constraints = v
        return b
}</span>
func (b *CreateTableBuilder) SetHiveDistribution(v HiveDistributionStyle) *CreateTableBuilder <span class="cov0" title="0">{
        b.HiveDistribution = v
        return b
}</span>
func (b *CreateTableBuilder) SetHiveFormats(v *HiveFormat) *CreateTableBuilder <span class="cov0" title="0">{
        b.HiveFormats = v
        return b
}</span>
func (b *CreateTableBuilder) SetTableProperties(v []SqlOption) *CreateTableBuilder <span class="cov0" title="0">{
        b.TableProperties = v
        return b
}</span>
func (b *CreateTableBuilder) SetWithOptions(v []SqlOption) *CreateTableBuilder <span class="cov0" title="0">{
        b.WithOptions = v
        return b
}</span>
func (b *CreateTableBuilder) SetFileFormat(v *FileFormat) *CreateTableBuilder <span class="cov0" title="0">{
        b.FileFormat = v
        return b
}</span>
func (b *CreateTableBuilder) SetLocation(v *string) *CreateTableBuilder <span class="cov0" title="0">{ b.Location = v; return b }</span>
func (b *CreateTableBuilder) SetQuery(v *Query) *CreateTableBuilder     <span class="cov0" title="0">{ b.Query = v; return b }</span>
func (b *CreateTableBuilder) SetWithoutRowID(v bool) *CreateTableBuilder <span class="cov0" title="0">{
        b.WithoutRowID = v
        return b
}</span>
func (b *CreateTableBuilder) SetLike(v *ObjectName) *CreateTableBuilder    <span class="cov0" title="0">{ b.Like = v; return b }</span>
func (b *CreateTableBuilder) SetClone(v *ObjectName) *CreateTableBuilder   <span class="cov0" title="0">{ b.Clone = v; return b }</span>
func (b *CreateTableBuilder) SetEngine(v *TableEngine) *CreateTableBuilder <span class="cov0" title="0">{ b.Engine = v; return b }</span>
func (b *CreateTableBuilder) SetComment(v *CommentDef) *CreateTableBuilder <span class="cov0" title="0">{ b.Comment = v; return b }</span>
func (b *CreateTableBuilder) SetAutoIncrementOffset(v *uint32) *CreateTableBuilder <span class="cov0" title="0">{
        b.AutoIncrementOffset = v
        return b
}</span>
func (b *CreateTableBuilder) SetDefaultCharset(v *string) *CreateTableBuilder <span class="cov0" title="0">{
        b.DefaultCharset = v
        return b
}</span>
func (b *CreateTableBuilder) SetCollation(v *string) *CreateTableBuilder  <span class="cov0" title="0">{ b.Collation = v; return b }</span>
func (b *CreateTableBuilder) SetOnCommit(v *OnCommit) *CreateTableBuilder <span class="cov0" title="0">{ b.OnCommit = v; return b }</span>
func (b *CreateTableBuilder) SetOnCluster(v *Ident) *CreateTableBuilder   <span class="cov0" title="0">{ b.OnCluster = v; return b }</span>
func (b *CreateTableBuilder) SetPrimaryKey(v *Expr) *CreateTableBuilder   <span class="cov0" title="0">{ b.PrimaryKey = v; return b }</span>
func (b *CreateTableBuilder) SetOrderBy(v *OneOrManyWithParens[Expr]) *CreateTableBuilder <span class="cov0" title="0">{
        b.OrderBy = v
        return b
}</span>
func (b *CreateTableBuilder) SetPartitionBy(v *Expr) *CreateTableBuilder <span class="cov0" title="0">{ b.PartitionBy = v; return b }</span>
func (b *CreateTableBuilder) SetClusterBy(v *WrappedCollection[[]Ident]) *CreateTableBuilder <span class="cov0" title="0">{
        b.ClusterBy = v
        return b
}</span>
func (b *CreateTableBuilder) SetClusteredBy(v *ClusteredBy) *CreateTableBuilder <span class="cov0" title="0">{
        b.ClusteredBy = v
        return b
}</span>
func (b *CreateTableBuilder) SetOptions(v *[]SqlOption) *CreateTableBuilder <span class="cov0" title="0">{ b.Options = v; return b }</span>
func (b *CreateTableBuilder) SetStrict(v bool) *CreateTableBuilder          <span class="cov0" title="0">{ b.Strict = v; return b }</span>
func (b *CreateTableBuilder) SetCopyGrants(v bool) *CreateTableBuilder      <span class="cov0" title="0">{ b.CopyGrants = v; return b }</span>
func (b *CreateTableBuilder) SetEnableSchemaEvolution(v *bool) *CreateTableBuilder <span class="cov0" title="0">{
        b.EnableSchemaEvolution = v
        return b
}</span>
func (b *CreateTableBuilder) SetChangeTracking(v *bool) *CreateTableBuilder <span class="cov0" title="0">{
        b.ChangeTracking = v
        return b
}</span>
func (b *CreateTableBuilder) SetDataRetentionDays(v *uint64) *CreateTableBuilder <span class="cov0" title="0">{
        b.DataRetentionDays = v
        return b
}</span>
func (b *CreateTableBuilder) SetMaxDataExtensionDays(v *uint64) *CreateTableBuilder <span class="cov0" title="0">{
        b.MaxDataExtensionDays = v
        return b
}</span>
func (b *CreateTableBuilder) SetDefaultDDLCollation(v *string) *CreateTableBuilder <span class="cov0" title="0">{
        b.DefaultDDLCollation = v
        return b
}</span>
func (b *CreateTableBuilder) SetAggregationPolicy(v *ObjectName) *CreateTableBuilder <span class="cov0" title="0">{
        b.AggregationPolicy = v
        return b
}</span>
func (b *CreateTableBuilder) SetRowAccessPolicy(v *RowAccessPolicy) *CreateTableBuilder <span class="cov0" title="0">{
        b.RowAccessPolicy = v
        return b
}</span>
func (b *CreateTableBuilder) SetTags(v *[]Tag) *CreateTableBuilder <span class="cov0" title="0">{ b.Tags = v; return b }</span>
func (b *CreateTableBuilder) SetBaseLocation(v *string) *CreateTableBuilder <span class="cov0" title="0">{
        b.BaseLocation = v
        return b
}</span>
func (b *CreateTableBuilder) SetExternalVolume(v *string) *CreateTableBuilder <span class="cov0" title="0">{
        b.ExternalVolume = v
        return b
}</span>
func (b *CreateTableBuilder) SetCatalog(v *string) *CreateTableBuilder <span class="cov0" title="0">{ b.Catalog = v; return b }</span>
func (b *CreateTableBuilder) SetCatalogSync(v *string) *CreateTableBuilder <span class="cov0" title="0">{
        b.CatalogSync = v
        return b
}</span>
func (b *CreateTableBuilder) SetSerializationPolicy(v *StorageSerializationPolicy) *CreateTableBuilder <span class="cov0" title="0">{
        b.SerializationPolicy = v
        return b
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package ast

import (
        "fmt"
        "strings"
)

// StageParamsObject represents parameters for stage operations in data loading
type StageParamsObject struct {
        URL                *string
        Encryption         DataLoadingOptions
        Endpoint           *string
        StorageIntegration *string
        Credentials        DataLoadingOptions
}

// String implements the Stringer interface for StageParamsObject
func (s *StageParamsObject) String() string <span class="cov0" title="0">{
        var parts []string

        if s.URL != nil </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("URL='%s'", *s.URL))
        }</span>
        <span class="cov0" title="0">if s.StorageIntegration != nil </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("STORAGE_INTEGRATION=%s", *s.StorageIntegration))
        }</span>
        <span class="cov0" title="0">if s.Endpoint != nil </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("ENDPOINT='%s'", *s.Endpoint))
        }</span>
        <span class="cov0" title="0">if len(s.Credentials.Options) &gt; 0 </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("CREDENTIALS=(%s)", s.Credentials.String()))
        }</span>
        <span class="cov0" title="0">if len(s.Encryption.Options) &gt; 0 </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("ENCRYPTION=(%s)", s.Encryption.String()))
        }</span>

        <span class="cov0" title="0">return strings.Join(parts, " ")</span>
}

// DataLoadingOptions represents a collection of data loading options
type DataLoadingOptions struct {
        Options []DataLoadingOption
}

// String implements the Stringer interface for DataLoadingOptions
func (d *DataLoadingOptions) String() string <span class="cov0" title="0">{
        var parts []string
        for _, opt := range d.Options </span><span class="cov0" title="0">{
                parts = append(parts, opt.String())
        }</span>
        <span class="cov0" title="0">return strings.Join(parts, " ")</span>
}

// DataLoadingOptionType represents the type of a data loading option
type DataLoadingOptionType int

const (
        DataLoadingOptionTypeString DataLoadingOptionType = iota
        DataLoadingOptionTypeBoolean
        DataLoadingOptionTypeEnum
        DataLoadingOptionTypeNumber
)

// DataLoadingOption represents a single data loading option
type DataLoadingOption struct {
        OptionName string
        OptionType DataLoadingOptionType
        Value      string
}

// String implements the Stringer interface for DataLoadingOption
func (d *DataLoadingOption) String() string <span class="cov0" title="0">{
        switch d.OptionType </span>{
        case DataLoadingOptionTypeString:<span class="cov0" title="0">
                return fmt.Sprintf("%s='%s'", d.OptionName, d.Value)</span>
        case DataLoadingOptionTypeEnum,
                DataLoadingOptionTypeBoolean,
                DataLoadingOptionTypeNumber:<span class="cov0" title="0">
                return fmt.Sprintf("%s=%s", d.OptionName, d.Value)</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%s=%s", d.OptionName, d.Value)</span>
        }
}

// StageLoadSelectItem represents a select item in stage loading operations
type StageLoadSelectItem struct {
        Alias      *Ident
        FileColNum int32
        Element    *Ident
        ItemAs     *Ident
}

// String implements the Stringer interface for StageLoadSelectItem
func (s *StageLoadSelectItem) String() string <span class="cov0" title="0">{
        var result strings.Builder

        if s.Alias != nil </span><span class="cov0" title="0">{
                result.WriteString(s.Alias.String())
                result.WriteString(".")
        }</span>
        <span class="cov0" title="0">result.WriteString(fmt.Sprintf("$%d", s.FileColNum))
        if s.Element != nil </span><span class="cov0" title="0">{
                result.WriteString(":")
                result.WriteString(s.Element.String())
        }</span>
        <span class="cov0" title="0">if s.ItemAs != nil </span><span class="cov0" title="0">{
                result.WriteString(" AS ")
                result.WriteString(s.ItemAs.String())
        }</span>

        <span class="cov0" title="0">return result.String()</span>
}

// FileStagingCommand represents a file staging command
type FileStagingCommand struct {
        Stage   ObjectName
        Pattern *string
}

// String implements the Stringer interface for FileStagingCommand
func (f *FileStagingCommand) String() string <span class="cov0" title="0">{
        var result strings.Builder

        result.WriteString(f.Stage.String())
        if f.Pattern != nil </span><span class="cov0" title="0">{
                result.WriteString(fmt.Sprintf(" PATTERN='%s'", *f.Pattern))
        }</span>

        <span class="cov0" title="0">return result.String()</span>
}

// Helper functions for creating options

// NewStringOption creates a new string-type DataLoadingOption
func NewStringOption(name, value string) DataLoadingOption <span class="cov0" title="0">{
        return DataLoadingOption{
                OptionName: name,
                OptionType: DataLoadingOptionTypeString,
                Value:      value,
        }
}</span>

// NewBooleanOption creates a new boolean-type DataLoadingOption
func NewBooleanOption(name string, value bool) DataLoadingOption <span class="cov0" title="0">{
        return DataLoadingOption{
                OptionName: name,
                OptionType: DataLoadingOptionTypeBoolean,
                Value:      fmt.Sprintf("%v", value),
        }
}</span>

// NewEnumOption creates a new enum-type DataLoadingOption
func NewEnumOption(name, value string) DataLoadingOption <span class="cov0" title="0">{
        return DataLoadingOption{
                OptionName: name,
                OptionType: DataLoadingOptionTypeEnum,
                Value:      value,
        }
}</span>

// NewNumberOption creates a new number-type DataLoadingOption
func NewNumberOption(name string, value interface{}) DataLoadingOption <span class="cov0" title="0">{
        return DataLoadingOption{
                OptionName: name,
                OptionType: DataLoadingOptionTypeNumber,
                Value:      fmt.Sprintf("%v", value),
        }
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package ast

import (
        "fmt"
        "strings"
)

// EnumMember represents a member of an ENUM type
type EnumMember struct {
        Name  string
        Value Expression
}

func (e *EnumMember) String() string <span class="cov0" title="0">{
        if e.Value != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("'%s' = %s", escapeString(e.Name), e.Value.TokenLiteral())
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("'%s'", escapeString(e.Name))</span>
}

// DataType represents SQL data types
type DataType struct {
        Type DataTypeVariant
}

// DataTypeVariant represents the different variants of SQL data types
type DataTypeVariant interface {
        fmt.Stringer
        isDataType()
}

// CharacterLength represents character length information
type CharacterLength struct {
        Length uint64
        Unit   *CharLengthUnits
}

func (c *CharacterLength) String() string <span class="cov0" title="0">{
        if c.Unit != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d %s", c.Length, c.Unit)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%d", c.Length)</span>
}

// CharLengthUnits represents possible units for characters
type CharLengthUnits int

const (
        Characters CharLengthUnits = iota
        Octets
)

func (u CharLengthUnits) String() string <span class="cov0" title="0">{
        switch u </span>{
        case Characters:<span class="cov0" title="0">
                return "CHARACTERS"</span>
        case Octets:<span class="cov0" title="0">
                return "OCTETS"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// BinaryLength represents binary length information
type BinaryLength struct {
        Length uint64
        IsMax  bool
}

func (b *BinaryLength) String() string <span class="cov0" title="0">{
        if b.IsMax </span><span class="cov0" title="0">{
                return "MAX"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%d", b.Length)</span>
}

// TimezoneInfo represents timezone information for temporal types
type TimezoneInfo int

const (
        NoTimezone TimezoneInfo = iota
        WithTimeZone
        WithoutTimeZone
        Tz
)

func (t TimezoneInfo) String() string <span class="cov0" title="0">{
        switch t </span>{
        case NoTimezone:<span class="cov0" title="0">
                return ""</span>
        case WithTimeZone:<span class="cov0" title="0">
                return " WITH TIME ZONE"</span>
        case WithoutTimeZone:<span class="cov0" title="0">
                return " WITHOUT TIME ZONE"</span>
        case Tz:<span class="cov0" title="0">
                return "TZ"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// ExactNumberInfo represents precision and scale information
type ExactNumberInfo struct {
        Precision *uint64
        Scale     *uint64
}

func (e *ExactNumberInfo) String() string <span class="cov0" title="0">{
        if e.Precision == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if e.Scale == nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("(%d)", *e.Precision)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("(%d,%d)", *e.Precision, *e.Scale)</span>
}

// ArrayElemTypeDef represents array element type definition
type ArrayElemTypeDef struct {
        Type     *DataType
        Size     *uint64
        Brackets ArrayBracketType
}

type ArrayBracketType int

const (
        NoBrackets ArrayBracketType = iota
        AngleBrackets
        SquareBrackets
        Parentheses
)

func (a *ArrayElemTypeDef) String() string <span class="cov0" title="0">{
        if a.Type == nil </span><span class="cov0" title="0">{
                return "ARRAY"
        }</span>

        <span class="cov0" title="0">switch a.Brackets </span>{
        case AngleBrackets:<span class="cov0" title="0">
                return fmt.Sprintf("ARRAY&lt;%s&gt;", a.Type)</span>
        case SquareBrackets:<span class="cov0" title="0">
                if a.Size != nil </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%s[%d]", a.Type, *a.Size)
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%s[]", a.Type)</span>
        case Parentheses:<span class="cov0" title="0">
                return fmt.Sprintf("Array(%s)", a.Type)</span>
        default:<span class="cov0" title="0">
                return "ARRAY"</span>
        }
}

// StructBracketKind represents the type of brackets used in STRUCT type
type StructBracketKind int

const (
        ParenthesesBrackets StructBracketKind = iota
        AngleBracketsBrackets
)

// Helper function to escape strings
func escapeString(s string) string <span class="cov0" title="0">{
        return strings.ReplaceAll(s, "'", "''")
}</span>

// Basic data types
type (
        TableType struct {
                Columns []*ColumnDef
        }

        CharacterType struct {
                Length *CharacterLength
        }

        VarcharType struct {
                Length *CharacterLength
        }

        NumericType struct {
                Info *ExactNumberInfo
        }

        IntegerType struct {
                Length   *uint64
                Unsigned bool
        }

        FloatType struct {
                Length *uint64
        }

        BooleanType struct{}

        DateType struct{}

        TimeType struct {
                Precision *uint64
                Timezone  TimezoneInfo
        }

        TimestampType struct {
                Precision *uint64
                Timezone  TimezoneInfo
        }

        ArrayType struct {
                ElementType *ArrayElemTypeDef
        }

        EnumType struct {
                Values []EnumMember
                Bits   *uint8
        }

        SetType struct {
                Values []string
        }

        JsonType struct{}

        BinaryType struct {
                Length *BinaryLength
        }

        CustomType struct {
                Name      ObjectName
                Modifiers []string
        }
)

// Implement DataTypeVariant interface
func (*TableType) isDataType()     {<span class="cov0" title="0">}</span>
func (*CharacterType) isDataType() {<span class="cov0" title="0">}</span>
func (*VarcharType) isDataType()   {<span class="cov0" title="0">}</span>
func (*NumericType) isDataType()   {<span class="cov0" title="0">}</span>
func (*IntegerType) isDataType()   {<span class="cov0" title="0">}</span>
func (*FloatType) isDataType()     {<span class="cov0" title="0">}</span>
func (*BooleanType) isDataType()   {<span class="cov0" title="0">}</span>
func (*DateType) isDataType()      {<span class="cov0" title="0">}</span>
func (*TimeType) isDataType()      {<span class="cov0" title="0">}</span>
func (*TimestampType) isDataType() {<span class="cov0" title="0">}</span>
func (*ArrayType) isDataType()     {<span class="cov0" title="0">}</span>
func (*EnumType) isDataType()      {<span class="cov0" title="0">}</span>
func (*SetType) isDataType()       {<span class="cov0" title="0">}</span>
func (*JsonType) isDataType()      {<span class="cov0" title="0">}</span>
func (*BinaryType) isDataType()    {<span class="cov0" title="0">}</span>
func (*CustomType) isDataType()    {<span class="cov0" title="0">}</span>

// String implementations for data types
func (t *TableType) String() string <span class="cov0" title="0">{
        var cols []string
        for _, col := range t.Columns </span><span class="cov0" title="0">{
                cols = append(cols, col.String())
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("TABLE(%s)", strings.Join(cols, ", "))</span>
}

func (t *CharacterType) String() string <span class="cov0" title="0">{
        if t.Length == nil </span><span class="cov0" title="0">{
                return "CHARACTER"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("CHARACTER(%s)", t.Length)</span>
}

func (t *VarcharType) String() string <span class="cov0" title="0">{
        if t.Length == nil </span><span class="cov0" title="0">{
                return "VARCHAR"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("VARCHAR(%s)", t.Length)</span>
}

func (t *NumericType) String() string <span class="cov0" title="0">{
        if t.Info == nil </span><span class="cov0" title="0">{
                return "NUMERIC"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("NUMERIC%s", t.Info)</span>
}

func (t *IntegerType) String() string <span class="cov0" title="0">{
        var result string
        if t.Length == nil </span><span class="cov0" title="0">{
                result = "INTEGER"
        }</span> else<span class="cov0" title="0"> {
                result = fmt.Sprintf("INTEGER(%d)", *t.Length)
        }</span>
        <span class="cov0" title="0">if t.Unsigned </span><span class="cov0" title="0">{
                result += " UNSIGNED"
        }</span>
        <span class="cov0" title="0">return result</span>
}

func (t *FloatType) String() string <span class="cov0" title="0">{
        if t.Length == nil </span><span class="cov0" title="0">{
                return "FLOAT"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("FLOAT(%d)", *t.Length)</span>
}

func (*BooleanType) String() string <span class="cov0" title="0">{ return "BOOLEAN" }</span>
func (*DateType) String() string    <span class="cov0" title="0">{ return "DATE" }</span>

func (t *TimeType) String() string <span class="cov0" title="0">{
        var result string
        if t.Precision == nil </span><span class="cov0" title="0">{
                result = "TIME"
        }</span> else<span class="cov0" title="0"> {
                result = fmt.Sprintf("TIME(%d)", *t.Precision)
        }</span>
        <span class="cov0" title="0">if t.Timezone != NoTimezone </span><span class="cov0" title="0">{
                result += t.Timezone.String()
        }</span>
        <span class="cov0" title="0">return result</span>
}

func (t *TimestampType) String() string <span class="cov0" title="0">{
        var result string
        if t.Precision == nil </span><span class="cov0" title="0">{
                result = "TIMESTAMP"
        }</span> else<span class="cov0" title="0"> {
                result = fmt.Sprintf("TIMESTAMP(%d)", *t.Precision)
        }</span>
        <span class="cov0" title="0">if t.Timezone != NoTimezone </span><span class="cov0" title="0">{
                result += t.Timezone.String()
        }</span>
        <span class="cov0" title="0">return result</span>
}

func (t *ArrayType) String() string <span class="cov0" title="0">{
        if t.ElementType == nil </span><span class="cov0" title="0">{
                return "ARRAY"
        }</span>
        <span class="cov0" title="0">return t.ElementType.String()</span>
}

func (t *EnumType) String() string <span class="cov0" title="0">{
        var values []string
        for _, v := range t.Values </span><span class="cov0" title="0">{
                values = append(values, v.String())
        }</span>
        <span class="cov0" title="0">var result string
        if t.Bits != nil </span><span class="cov0" title="0">{
                result = fmt.Sprintf("ENUM%d", *t.Bits)
        }</span> else<span class="cov0" title="0"> {
                result = "ENUM"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s(%s)", result, strings.Join(values, ", "))</span>
}

func (t *SetType) String() string <span class="cov0" title="0">{
        var values []string
        for _, v := range t.Values </span><span class="cov0" title="0">{
                values = append(values, fmt.Sprintf("'%s'", escapeString(v)))
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("SET(%s)", strings.Join(values, ", "))</span>
}

func (*JsonType) String() string <span class="cov0" title="0">{ return "JSON" }</span>

func (t *BinaryType) String() string <span class="cov0" title="0">{
        if t.Length == nil </span><span class="cov0" title="0">{
                return "BINARY"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("BINARY(%s)", t.Length)</span>
}

func (t *CustomType) String() string <span class="cov0" title="0">{
        if len(t.Modifiers) == 0 </span><span class="cov0" title="0">{
                return t.Name.String()
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s(%s)", t.Name, strings.Join(t.Modifiers, ", "))</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package ast

import (
        "fmt"
        "reflect"
        "strings"
)

// StructField represents a field in a struct type
type StructField struct {
        Name string
        Type string
        Tags map[string]string
}

// ParseStructTags parses struct field tags into a map
func ParseStructTags(tag string) map[string]string <span class="cov0" title="0">{
        tags := make(map[string]string)
        for _, t := range strings.Split(tag, " ") </span><span class="cov0" title="0">{
                if t == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">parts := strings.SplitN(t, ":", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">key := strings.Trim(parts[0], `"`)
                value := strings.Trim(parts[1], `"`)
                tags[key] = value</span>
        }
        <span class="cov0" title="0">return tags</span>
}

// GetStructFields returns the fields of a struct type
func GetStructFields(t reflect.Type) []StructField <span class="cov0" title="0">{
        fields := make([]StructField, 0)
        for i := 0; i &lt; t.NumField(); i++ </span><span class="cov0" title="0">{
                f := t.Field(i)
                field := StructField{
                        Name: f.Name,
                        Type: f.Type.String(),
                        Tags: ParseStructTags(string(f.Tag)),
                }
                fields = append(fields, field)
        }</span>
        <span class="cov0" title="0">return fields</span>
}

// String returns a string representation of a ColumnDef
func (c *ColumnDef) String() string <span class="cov0" title="0">{
        var b strings.Builder
        b.WriteString(c.Name)
        b.WriteString(" ")
        b.WriteString(c.Type)
        for _, constraint := range c.Constraints </span><span class="cov0" title="0">{
                b.WriteString(" ")
                b.WriteString(constraint.String())
        }</span>
        <span class="cov0" title="0">return b.String()</span>
}

// String returns a string representation of a ReferenceDefinition
func (r *ReferenceDefinition) String() string <span class="cov0" title="0">{
        var b strings.Builder
        b.WriteString("REFERENCES ")
        b.WriteString(r.Table)
        if len(r.Columns) &gt; 0 </span><span class="cov0" title="0">{
                b.WriteString(" (")
                b.WriteString(strings.Join(r.Columns, ", "))
                b.WriteString(")")
        }</span>
        <span class="cov0" title="0">if r.OnDelete != "" </span><span class="cov0" title="0">{
                b.WriteString(" ON DELETE ")
                b.WriteString(r.OnDelete)
        }</span>
        <span class="cov0" title="0">if r.OnUpdate != "" </span><span class="cov0" title="0">{
                b.WriteString(" ON UPDATE ")
                b.WriteString(r.OnUpdate)
        }</span>
        <span class="cov0" title="0">if r.Match != "" </span><span class="cov0" title="0">{
                b.WriteString(" MATCH ")
                b.WriteString(r.Match)
        }</span>
        <span class="cov0" title="0">return b.String()</span>
}

// String returns a string representation of a ColumnConstraint
func (c *ColumnConstraint) String() string <span class="cov0" title="0">{
        var b strings.Builder
        b.WriteString(c.Type)
        if c.Default != nil </span><span class="cov0" title="0">{
                b.WriteString(" DEFAULT ")
                b.WriteString(fmt.Sprintf("%v", c.Default))
        }</span>
        <span class="cov0" title="0">if c.References != nil </span><span class="cov0" title="0">{
                b.WriteString(" ")
                b.WriteString(c.References.String())
        }</span>
        <span class="cov0" title="0">if c.Check != nil </span><span class="cov0" title="0">{
                b.WriteString(" CHECK (")
                b.WriteString(fmt.Sprintf("%v", c.Check))
                b.WriteString(")")
        }</span>
        <span class="cov0" title="0">if c.AutoIncrement </span><span class="cov0" title="0">{
                b.WriteString(" AUTO_INCREMENT")
        }</span>
        <span class="cov0" title="0">return b.String()</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package ast

// Select represents a SELECT statement
type Select struct {
        Distinct bool
        Columns  []Expression
        From     []TableReference
        Where    Expression
        GroupBy  []Expression
        Having   Expression
        OrderBy  []Expression
        Limit    *int64
        Offset   *int64
}

func (s *Select) statementNode()      {<span class="cov0" title="0">}</span>
func (s Select) TokenLiteral() string <span class="cov0" title="0">{ return "SELECT" }</span>
func (s Select) Children() []Node <span class="cov0" title="0">{
        children := make([]Node, 0)
        children = append(children, nodifyExpressions(s.Columns)...)
        for _, from := range s.From </span><span class="cov0" title="0">{
                children = append(children, &amp;from)
        }</span>
        <span class="cov0" title="0">if s.Where != nil </span><span class="cov0" title="0">{
                children = append(children, s.Where)
        }</span>
        <span class="cov0" title="0">children = append(children, nodifyExpressions(s.GroupBy)...)
        if s.Having != nil </span><span class="cov0" title="0">{
                children = append(children, s.Having)
        }</span>
        <span class="cov0" title="0">children = append(children, nodifyExpressions(s.OrderBy)...)
        return children</span>
}

// Insert represents an INSERT statement
type Insert struct {
        Table           TableReference
        Columns         []Expression
        Values          [][]Expression
        ReturningClause []Expression
}

func (i *Insert) statementNode()      {<span class="cov0" title="0">}</span>
func (i Insert) TokenLiteral() string <span class="cov0" title="0">{ return "INSERT" }</span>
func (i Insert) Children() []Node <span class="cov0" title="0">{
        children := make([]Node, 0)
        children = append(children, &amp;i.Table)
        children = append(children, nodifyExpressions(i.Columns)...)
        for _, row := range i.Values </span><span class="cov0" title="0">{
                children = append(children, nodifyExpressions(row)...)
        }</span>
        <span class="cov0" title="0">children = append(children, nodifyExpressions(i.ReturningClause)...)
        return children</span>
}

// Delete represents a DELETE statement
type Delete struct {
        Table           TableReference
        Where           Expression
        ReturningClause []Expression
}

func (d *Delete) statementNode()      {<span class="cov0" title="0">}</span>
func (d Delete) TokenLiteral() string <span class="cov0" title="0">{ return "DELETE" }</span>
func (d Delete) Children() []Node <span class="cov0" title="0">{
        children := make([]Node, 0)
        children = append(children, &amp;d.Table)
        if d.Where != nil </span><span class="cov0" title="0">{
                children = append(children, d.Where)
        }</span>
        <span class="cov0" title="0">children = append(children, nodifyExpressions(d.ReturningClause)...)
        return children</span>
}

// Update represents an UPDATE statement
type Update struct {
        Table           TableReference
        Updates         []UpdateExpression
        Where           Expression
        ReturningClause []Expression
}

func (u *Update) statementNode()      {<span class="cov0" title="0">}</span>
func (u Update) TokenLiteral() string <span class="cov0" title="0">{ return "UPDATE" }</span>
func (u Update) Children() []Node <span class="cov0" title="0">{
        children := make([]Node, 0)
        children = append(children, &amp;u.Table)
        for _, update := range u.Updates </span><span class="cov0" title="0">{
                children = append(children, &amp;update)
        }</span>
        <span class="cov0" title="0">if u.Where != nil </span><span class="cov0" title="0">{
                children = append(children, u.Where)
        }</span>
        <span class="cov0" title="0">children = append(children, nodifyExpressions(u.ReturningClause)...)
        return children</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package ast

import "fmt"

// FunctionDesc represents a function descriptor used in SQL statements
type FunctionDesc struct {
        Name      ObjectName
        Schema    string // Optional schema qualifier
        Arguments []string
}

func (f FunctionDesc) String() string <span class="cov8" title="1">{
        if len(f.Arguments) == 0 </span><span class="cov8" title="1">{
                if f.Schema != "" </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%s.%s", f.Schema, f.Name)
                }</span>
                <span class="cov8" title="1">return f.Name.String()</span>
        }

        <span class="cov0" title="0">if f.Schema != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s.%s(%s)", f.Schema, f.Name, f.Arguments)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s(%s)", f.Name, f.Arguments)</span>
}

// Implement Node interface
func (f FunctionDesc) Children() []Node     <span class="cov0" title="0">{ return nil }</span>
func (f FunctionDesc) TokenLiteral() string <span class="cov0" title="0">{ return f.String() }</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package ast

// ObjectName represents a qualified or unqualified object name
type ObjectName struct {
        Name string
}

func (o ObjectName) TokenLiteral() string <span class="cov0" title="0">{ return o.Name }</span>
func (o ObjectName) Children() []Node     <span class="cov0" title="0">{ return nil }</span>
func (o ObjectName) String() string       <span class="cov8" title="1">{ return o.Name }</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package ast

import (
        "fmt"
        "strings"
)

// UnaryOperator represents unary operators in SQL expressions
type UnaryOperator int

const (
        // Plus represents unary plus operator, e.g. +9
        Plus UnaryOperator = iota
        // Minus represents unary minus operator, e.g. -9
        Minus
        // Not represents logical NOT operator, e.g. NOT(true)
        Not
        // PGBitwiseNot represents PostgreSQL bitwise NOT operator, e.g. ~9
        PGBitwiseNot
        // PGSquareRoot represents PostgreSQL square root operator, e.g. |/9
        PGSquareRoot
        // PGCubeRoot represents PostgreSQL cube root operator, e.g. ||/27
        PGCubeRoot
        // PGPostfixFactorial represents PostgreSQL postfix factorial operator, e.g. 9!
        PGPostfixFactorial
        // PGPrefixFactorial represents PostgreSQL prefix factorial operator, e.g. !!9
        PGPrefixFactorial
        // PGAbs represents PostgreSQL absolute value operator, e.g. @ -9
        PGAbs
        // BangNot represents Hive-specific logical NOT operator, e.g. ! false
        BangNot
)

// String returns the string representation of the unary operator
func (op UnaryOperator) String() string <span class="cov0" title="0">{
        switch op </span>{
        case Plus:<span class="cov0" title="0">
                return "+"</span>
        case Minus:<span class="cov0" title="0">
                return "-"</span>
        case Not:<span class="cov0" title="0">
                return "NOT"</span>
        case PGBitwiseNot:<span class="cov0" title="0">
                return "~"</span>
        case PGSquareRoot:<span class="cov0" title="0">
                return "|/"</span>
        case PGCubeRoot:<span class="cov0" title="0">
                return "||/"</span>
        case PGPostfixFactorial:<span class="cov0" title="0">
                return "!"</span>
        case PGPrefixFactorial:<span class="cov0" title="0">
                return "!!"</span>
        case PGAbs:<span class="cov0" title="0">
                return "@"</span>
        case BangNot:<span class="cov0" title="0">
                return "!"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// BinaryOperator represents binary operators in SQL expressions
type BinaryOperator int

const (
        // BinaryOpNone represents no operator (zero value)
        BinaryOpNone BinaryOperator = iota
        // BinaryPlus represents addition operator, e.g. a + b
        BinaryPlus
        // BinaryMinus represents subtraction operator, e.g. a - b
        BinaryMinus
        // Multiply represents multiplication operator, e.g. a * b
        Multiply
        // Divide represents division operator, e.g. a / b
        Divide
        // Modulo represents modulo operator, e.g. a % b
        Modulo
        // StringConcat represents string/array concatenation operator, e.g. a || b
        StringConcat
        // Gt represents greater than operator, e.g. a &gt; b
        Gt
        // Lt represents less than operator, e.g. a &lt; b
        Lt
        // GtEq represents greater than or equal operator, e.g. a &gt;= b
        GtEq
        // LtEq represents less than or equal operator, e.g. a &lt;= b
        LtEq
        // Spaceship represents spaceship operator, e.g. a &lt;=&gt; b
        Spaceship
        // Eq represents equality operator, e.g. a = b
        Eq
        // NotEq represents inequality operator, e.g. a &lt;&gt; b
        NotEq
        // And represents logical AND operator, e.g. a AND b
        And
        // Or represents logical OR operator, e.g. a OR b
        Or
        // Xor represents logical XOR operator, e.g. a XOR b
        Xor
        // BitwiseOr represents bitwise OR operator, e.g. a | b
        BitwiseOr
        // BitwiseAnd represents bitwise AND operator, e.g. a &amp; b
        BitwiseAnd
        // BitwiseXor represents bitwise XOR operator, e.g. a ^ b
        BitwiseXor
        // DuckIntegerDivide represents DuckDB integer division operator, e.g. a // b
        DuckIntegerDivide
        // MyIntegerDivide represents MySQL DIV integer division operator
        MyIntegerDivide
        // PGBitwiseXor represents PostgreSQL bitwise XOR operator, e.g. a # b
        PGBitwiseXor
        // PGBitwiseShiftLeft represents PostgreSQL bitwise shift left operator, e.g. a &lt;&lt; b
        PGBitwiseShiftLeft
        // PGBitwiseShiftRight represents PostgreSQL bitwise shift right operator, e.g. a &gt;&gt; b
        PGBitwiseShiftRight
        // PGExp represents PostgreSQL exponentiation operator, e.g. a ^ b
        PGExp
        // PGOverlap represents PostgreSQL overlap operator, e.g. a &amp;&amp; b
        PGOverlap
        // PGRegexMatch represents PostgreSQL case-sensitive regex match operator, e.g. a ~ b
        PGRegexMatch
        // PGRegexIMatch represents PostgreSQL case-insensitive regex match operator, e.g. a ~* b
        PGRegexIMatch
        // PGRegexNotMatch represents PostgreSQL case-sensitive regex non-match operator, e.g. a !~ b
        PGRegexNotMatch
        // PGRegexNotIMatch represents PostgreSQL case-insensitive regex non-match operator, e.g. a !~* b
        PGRegexNotIMatch
        // PGLikeMatch represents PostgreSQL case-sensitive LIKE match operator, e.g. a ~~ b
        PGLikeMatch
        // PGILikeMatch represents PostgreSQL case-insensitive LIKE match operator, e.g. a ~~* b
        PGILikeMatch
        // PGNotLikeMatch represents PostgreSQL case-sensitive NOT LIKE match operator, e.g. a !~~ b
        PGNotLikeMatch
        // PGNotILikeMatch represents PostgreSQL case-insensitive NOT LIKE match operator, e.g. a !~~* b
        PGNotILikeMatch
        // PGStartsWith represents PostgreSQL starts-with operator, e.g. a ^@ b
        PGStartsWith
        // Arrow represents JSON field/array element access operator, e.g. a -&gt; b
        Arrow
        // LongArrow represents JSON field/array element access with text conversion operator, e.g. a -&gt;&gt; b
        LongArrow
        // HashArrow represents JSON path access operator, e.g. a #&gt; b
        HashArrow
        // HashLongArrow represents JSON path access with text conversion operator, e.g. a #&gt;&gt; b
        HashLongArrow
        // AtAt represents PostgreSQL text/JSON search operator, e.g. a @@ b
        AtAt
        // AtArrow represents PostgreSQL contains operator, e.g. a @&gt; b
        AtArrow
        // ArrowAt represents PostgreSQL contained by operator, e.g. a &lt;@ b
        ArrowAt
        // HashMinus represents PostgreSQL JSON delete operator, e.g. a #- b
        HashMinus
        // AtQuestion represents PostgreSQL JSON path exists operator, e.g. a @? b
        AtQuestion
        // Question represents PostgreSQL JSON key exists operator, e.g. a ? b
        Question
        // QuestionAnd represents PostgreSQL JSON all keys exist operator, e.g. a ?&amp; b
        QuestionAnd
        // QuestionPipe represents PostgreSQL JSON any key exists operator, e.g. a ?| b
        QuestionPipe
        // Overlaps represents SQL OVERLAPS operator for datetime periods
        Overlaps
)

// String returns the string representation of the binary operator
func (op BinaryOperator) String() string <span class="cov0" title="0">{
        switch op </span>{
        case BinaryPlus:<span class="cov0" title="0">
                return "+"</span>
        case BinaryMinus:<span class="cov0" title="0">
                return "-"</span>
        case Multiply:<span class="cov0" title="0">
                return "*"</span>
        case Divide:<span class="cov0" title="0">
                return "/"</span>
        case Modulo:<span class="cov0" title="0">
                return "%"</span>
        case StringConcat:<span class="cov0" title="0">
                return "||"</span>
        case Gt:<span class="cov0" title="0">
                return "&gt;"</span>
        case Lt:<span class="cov0" title="0">
                return "&lt;"</span>
        case GtEq:<span class="cov0" title="0">
                return "&gt;="</span>
        case LtEq:<span class="cov0" title="0">
                return "&lt;="</span>
        case Spaceship:<span class="cov0" title="0">
                return "&lt;=&gt;"</span>
        case Eq:<span class="cov0" title="0">
                return "="</span>
        case NotEq:<span class="cov0" title="0">
                return "&lt;&gt;"</span>
        case And:<span class="cov0" title="0">
                return "AND"</span>
        case Or:<span class="cov0" title="0">
                return "OR"</span>
        case Xor:<span class="cov0" title="0">
                return "XOR"</span>
        case BitwiseOr:<span class="cov0" title="0">
                return "|"</span>
        case BitwiseAnd:<span class="cov0" title="0">
                return "&amp;"</span>
        case BitwiseXor:<span class="cov0" title="0">
                return "^"</span>
        case DuckIntegerDivide:<span class="cov0" title="0">
                return "//"</span>
        case MyIntegerDivide:<span class="cov0" title="0">
                return "DIV"</span>
        case PGBitwiseXor:<span class="cov0" title="0">
                return "#"</span>
        case PGBitwiseShiftLeft:<span class="cov0" title="0">
                return "&lt;&lt;"</span>
        case PGBitwiseShiftRight:<span class="cov0" title="0">
                return "&gt;&gt;"</span>
        case PGExp:<span class="cov0" title="0">
                return "^"</span>
        case PGOverlap:<span class="cov0" title="0">
                return "&amp;&amp;"</span>
        case PGRegexMatch:<span class="cov0" title="0">
                return "~"</span>
        case PGRegexIMatch:<span class="cov0" title="0">
                return "~*"</span>
        case PGRegexNotMatch:<span class="cov0" title="0">
                return "!~"</span>
        case PGRegexNotIMatch:<span class="cov0" title="0">
                return "!~*"</span>
        case PGLikeMatch:<span class="cov0" title="0">
                return "~~"</span>
        case PGILikeMatch:<span class="cov0" title="0">
                return "~~*"</span>
        case PGNotLikeMatch:<span class="cov0" title="0">
                return "!~~"</span>
        case PGNotILikeMatch:<span class="cov0" title="0">
                return "!~~*"</span>
        case PGStartsWith:<span class="cov0" title="0">
                return "^@"</span>
        case Arrow:<span class="cov0" title="0">
                return "-&gt;"</span>
        case LongArrow:<span class="cov0" title="0">
                return "-&gt;&gt;"</span>
        case HashArrow:<span class="cov0" title="0">
                return "#&gt;"</span>
        case HashLongArrow:<span class="cov0" title="0">
                return "#&gt;&gt;"</span>
        case AtAt:<span class="cov0" title="0">
                return "@@"</span>
        case AtArrow:<span class="cov0" title="0">
                return "@&gt;"</span>
        case ArrowAt:<span class="cov0" title="0">
                return "&lt;@"</span>
        case HashMinus:<span class="cov0" title="0">
                return "#-"</span>
        case AtQuestion:<span class="cov0" title="0">
                return "@?"</span>
        case Question:<span class="cov0" title="0">
                return "?"</span>
        case QuestionAnd:<span class="cov0" title="0">
                return "?&amp;"</span>
        case QuestionPipe:<span class="cov0" title="0">
                return "?|"</span>
        case Overlaps:<span class="cov0" title="0">
                return "OVERLAPS"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// CustomBinaryOperator represents a custom binary operator (PostgreSQL-specific)
type CustomBinaryOperator struct {
        Parts []string
}

// String returns the string representation of the custom binary operator
func (op *CustomBinaryOperator) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("OPERATOR(%s)", strings.Join(op.Parts, "."))
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package ast

import (
        "sync"
)

var (
        // AST node pools
        astPool = sync.Pool{
                New: func() interface{} <span class="cov8" title="1">{
                        return &amp;AST{
                                Statements: make([]Statement, 0, 8), // Increased initial capacity
                        }
                }</span>,
        }

        // Statement pools
        selectStmtPool = sync.Pool{
                New: func() interface{} <span class="cov8" title="1">{
                        return &amp;SelectStatement{
                                Columns: make([]Expression, 0, 4),
                                OrderBy: make([]Expression, 0, 1),
                        }
                }</span>,
        }

        insertStmtPool = sync.Pool{
                New: func() interface{} <span class="cov0" title="0">{
                        return &amp;InsertStatement{
                                Columns: make([]Expression, 0, 4),
                                Values:  make([]Expression, 0, 4),
                        }
                }</span>,
        }

        updateStmtPool = sync.Pool{
                New: func() interface{} <span class="cov0" title="0">{
                        return &amp;UpdateStatement{
                                Updates: make([]UpdateExpression, 0, 4),
                        }
                }</span>,
        }

        deleteStmtPool = sync.Pool{
                New: func() interface{} <span class="cov0" title="0">{
                        return &amp;DeleteStatement{}
                }</span>,
        }

        // Expression pools
        identifierPool = sync.Pool{
                New: func() interface{} <span class="cov0" title="0">{
                        return &amp;Identifier{}
                }</span>,
        }

        binaryExprPool = sync.Pool{
                New: func() interface{} <span class="cov0" title="0">{
                        return &amp;BinaryExpression{}
                }</span>,
        }

        // Add a pool for LiteralValue to reduce allocations
        literalValuePool = sync.Pool{
                New: func() interface{} <span class="cov0" title="0">{
                        return &amp;LiteralValue{}
                }</span>,
        }

        updateExprPool = sync.Pool{
                New: func() interface{} <span class="cov0" title="0">{
                        return &amp;UpdateExpression{}
                }</span>,
        }

        // Slice pools
        exprSlicePool = sync.Pool{
                New: func() interface{} <span class="cov8" title="1">{
                        s := make([]Expression, 0, 16) // Double capacity for better performance
                        return &amp;s
                }</span>,
        }
)

// NewAST creates a new AST from the pool
func NewAST() *AST <span class="cov8" title="1">{
        return astPool.Get().(*AST)
}</span>

// ReleaseAST returns an AST to the pool
func ReleaseAST(ast *AST) <span class="cov8" title="1">{
        if ast == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Clean up all statements
        <span class="cov8" title="1">for i := range ast.Statements </span><span class="cov0" title="0">{
                switch stmt := ast.Statements[i].(type) </span>{
                case *SelectStatement:<span class="cov0" title="0">
                        PutSelectStatement(stmt)</span>
                case *InsertStatement:<span class="cov0" title="0">
                        PutInsertStatement(stmt)</span>
                case *UpdateStatement:<span class="cov0" title="0">
                        PutUpdateStatement(stmt)</span>
                case *DeleteStatement:<span class="cov0" title="0">
                        PutDeleteStatement(stmt)</span>
                }
                <span class="cov0" title="0">ast.Statements[i] = nil</span>
        }

        // Reset slice but keep capacity
        <span class="cov8" title="1">ast.Statements = ast.Statements[:0]

        // Return to pool
        astPool.Put(ast)</span>
}

// GetInsertStatement gets an InsertStatement from the pool
func GetInsertStatement() *InsertStatement <span class="cov0" title="0">{
        return insertStmtPool.Get().(*InsertStatement)
}</span>

// PutInsertStatement returns an InsertStatement to the pool
func PutInsertStatement(stmt *InsertStatement) <span class="cov0" title="0">{
        if stmt == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Clean up expressions
        <span class="cov0" title="0">for i := range stmt.Columns </span><span class="cov0" title="0">{
                PutExpression(stmt.Columns[i])
                stmt.Columns[i] = nil
        }</span>
        <span class="cov0" title="0">for i := range stmt.Values </span><span class="cov0" title="0">{
                PutExpression(stmt.Values[i])
                stmt.Values[i] = nil
        }</span>

        // Reset slices but keep capacity
        <span class="cov0" title="0">stmt.Columns = stmt.Columns[:0]
        stmt.Values = stmt.Values[:0]
        stmt.TableName = ""

        // Return to pool
        insertStmtPool.Put(stmt)</span>
}

// GetUpdateStatement gets an UpdateStatement from the pool
func GetUpdateStatement() *UpdateStatement <span class="cov0" title="0">{
        return updateStmtPool.Get().(*UpdateStatement)
}</span>

// PutUpdateStatement returns an UpdateStatement to the pool
func PutUpdateStatement(stmt *UpdateStatement) <span class="cov0" title="0">{
        if stmt == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Clean up expressions
        <span class="cov0" title="0">for i := range stmt.Updates </span><span class="cov0" title="0">{
                PutExpression(stmt.Updates[i].Column)
                PutExpression(stmt.Updates[i].Value)
                stmt.Updates[i].Column = nil
                stmt.Updates[i].Value = nil
        }</span>
        <span class="cov0" title="0">PutExpression(stmt.Where)

        // Reset fields
        stmt.Updates = stmt.Updates[:0]
        stmt.Where = nil
        stmt.TableName = ""

        // Return to pool
        updateStmtPool.Put(stmt)</span>
}

// GetDeleteStatement gets a DeleteStatement from the pool
func GetDeleteStatement() *DeleteStatement <span class="cov0" title="0">{
        return deleteStmtPool.Get().(*DeleteStatement)
}</span>

// PutDeleteStatement returns a DeleteStatement to the pool
func PutDeleteStatement(stmt *DeleteStatement) <span class="cov0" title="0">{
        if stmt == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Clean up expressions
        <span class="cov0" title="0">PutExpression(stmt.Where)

        // Reset fields
        stmt.Where = nil
        stmt.TableName = ""

        // Return to pool
        deleteStmtPool.Put(stmt)</span>
}

// GetUpdateExpression gets an UpdateExpression from the pool
func GetUpdateExpression() *UpdateExpression <span class="cov0" title="0">{
        return updateExprPool.Get().(*UpdateExpression)
}</span>

// PutUpdateExpression returns an UpdateExpression to the pool
func PutUpdateExpression(expr *UpdateExpression) <span class="cov0" title="0">{
        if expr == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Clean up expressions
        <span class="cov0" title="0">PutExpression(expr.Column)
        PutExpression(expr.Value)

        // Reset fields
        expr.Column = nil
        expr.Value = nil

        // Return to pool
        updateExprPool.Put(expr)</span>
}

// GetSelectStatement gets a SelectStatement from the pool
func GetSelectStatement() *SelectStatement <span class="cov8" title="1">{
        stmt := selectStmtPool.Get().(*SelectStatement)
        stmt.Columns = stmt.Columns[:0]
        stmt.OrderBy = stmt.OrderBy[:0]
        return stmt
}</span>

// PutSelectStatement returns a SelectStatement to the pool
func PutSelectStatement(stmt *SelectStatement) <span class="cov8" title="1">{
        if stmt == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Clean up resources
        <span class="cov8" title="1">for _, col := range stmt.Columns </span><span class="cov8" title="1">{
                PutExpression(col)
        }</span>
        <span class="cov8" title="1">for _, expr := range stmt.OrderBy </span><span class="cov0" title="0">{
                PutExpression(expr)
        }</span>
        <span class="cov8" title="1">if stmt.Where != nil </span><span class="cov8" title="1">{
                PutExpression(stmt.Where)
        }</span>

        // Reset fields
        <span class="cov8" title="1">stmt.Columns = stmt.Columns[:0]
        stmt.OrderBy = stmt.OrderBy[:0]
        stmt.TableName = ""
        stmt.Where = nil
        stmt.Limit = nil
        stmt.Offset = nil

        // Return to pool
        selectStmtPool.Put(stmt)</span>
}

// GetIdentifier gets an Identifier from the pool
func GetIdentifier() *Identifier <span class="cov8" title="1">{
        return identifierPool.Get().(*Identifier)
}</span>

// PutIdentifier returns an Identifier to the pool
func PutIdentifier(ident *Identifier) <span class="cov8" title="1">{
        if ident == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">ident.Name = ""
        identifierPool.Put(ident)</span>
}

// GetBinaryExpression gets a BinaryExpression from the pool
func GetBinaryExpression() *BinaryExpression <span class="cov8" title="1">{
        return binaryExprPool.Get().(*BinaryExpression)
}</span>

// PutBinaryExpression returns a BinaryExpression to the pool
func PutBinaryExpression(expr *BinaryExpression) <span class="cov8" title="1">{
        if expr == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">PutExpression(expr.Left)
        PutExpression(expr.Right)
        expr.Left = nil
        expr.Right = nil
        expr.Operator = ""
        binaryExprPool.Put(expr)</span>
}

// GetExpressionSlice gets a slice of Expression from the pool
func GetExpressionSlice() *[]Expression <span class="cov8" title="1">{
        slice := exprSlicePool.Get().(*[]Expression)
        *slice = (*slice)[:0]
        return slice
}</span>

// PutExpressionSlice returns a slice of Expression to the pool
func PutExpressionSlice(slice *[]Expression) <span class="cov8" title="1">{
        if slice == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">for i := range *slice </span><span class="cov8" title="1">{
                PutExpression((*slice)[i])
                (*slice)[i] = nil
        }</span>
        <span class="cov8" title="1">exprSlicePool.Put(slice)</span>
}

// GetLiteralValue gets a LiteralValue from the pool
func GetLiteralValue() *LiteralValue <span class="cov0" title="0">{
        return literalValuePool.Get().(*LiteralValue)
}</span>

// PutLiteralValue returns a LiteralValue to the pool
func PutLiteralValue(lit *LiteralValue) <span class="cov0" title="0">{
        if lit == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Reset fields
        <span class="cov0" title="0">lit.Value = ""
        lit.Type = ""

        // Return to pool
        literalValuePool.Put(lit)</span>
}

// PutExpression returns any Expression to the appropriate pool
func PutExpression(expr Expression) <span class="cov8" title="1">{
        if expr == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">switch e := expr.(type) </span>{
        case *Identifier:<span class="cov8" title="1">
                PutIdentifier(e)</span>
        case *BinaryExpression:<span class="cov8" title="1">
                PutBinaryExpression(e)</span>
        case *LiteralValue:<span class="cov0" title="0">
                PutLiteralValue(e)</span>
        }
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package ast

import "github.com/ajitpratap0/GoSQLX/pkg/models"

// Spanned represents an AST node that has source location information
type Spanned interface {
        // Span returns the source location span for this node
        Span() models.Span
}

// SpannedNode represents a basic AST node with source location information
type SpannedNode struct {
        span models.Span
}

// Span returns the source location span for this node
func (n *SpannedNode) Span() models.Span <span class="cov0" title="0">{
        return n.span
}</span>

// SetSpan sets the source location span for this node
func (n *SpannedNode) SetSpan(span models.Span) <span class="cov0" title="0">{
        n.span = span
}</span>

// UnionSpans returns the union of all spans in the given slice
func UnionSpans(spans []models.Span) models.Span <span class="cov0" title="0">{
        if len(spans) == 0 </span><span class="cov0" title="0">{
                return models.EmptySpan()
        }</span>
        <span class="cov0" title="0">result := spans[0]
        for i := 1; i &lt; len(spans); i++ </span><span class="cov0" title="0">{
                // Union the spans by taking the earliest start and latest end
                if spans[i].Start.Line &lt; result.Start.Line ||
                        (spans[i].Start.Line == result.Start.Line &amp;&amp; spans[i].Start.Column &lt; result.Start.Column) </span><span class="cov0" title="0">{
                        result.Start = spans[i].Start
                }</span>
                <span class="cov0" title="0">if spans[i].End.Line &gt; result.End.Line ||
                        (spans[i].End.Line == result.End.Line &amp;&amp; spans[i].End.Column &gt; result.End.Column) </span><span class="cov0" title="0">{
                        result.End = spans[i].End
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// Now let's implement Spanned for our core AST nodes

// Span returns the source location span for the AST
func (a *AST) Span() models.Span <span class="cov0" title="0">{
        if len(a.Statements) == 0 </span><span class="cov0" title="0">{
                return models.EmptySpan()
        }</span>
        <span class="cov0" title="0">spans := make([]models.Span, len(a.Statements))
        for i, stmt := range a.Statements </span><span class="cov0" title="0">{
                if spanned, ok := stmt.(Spanned); ok </span><span class="cov0" title="0">{
                        spans[i] = spanned.Span()
                }</span>
        }
        <span class="cov0" title="0">return UnionSpans(spans)</span>
}

// spanInfo stores source location information for AST nodes
var spanInfo = make(map[interface{}]models.Span)

// SetSpan sets the source location span for an AST node
func SetSpan(node interface{}, span models.Span) <span class="cov0" title="0">{
        spanInfo[node] = span
}</span>

// GetSpan gets the source location span for an AST node
func GetSpan(node interface{}) models.Span <span class="cov0" title="0">{
        if span, ok := spanInfo[node]; ok </span><span class="cov0" title="0">{
                return span
        }</span>
        <span class="cov0" title="0">return models.EmptySpan()</span>
}

// Span returns the source location span for the SelectStatement
func (s *SelectStatement) Span() models.Span <span class="cov0" title="0">{
        return GetSpan(s)
}</span>

// Span returns the source location span for the InsertStatement
func (i *InsertStatement) Span() models.Span <span class="cov0" title="0">{
        spans := make([]models.Span, 0)

        if i.With != nil </span><span class="cov0" title="0">{
                if spanned, ok := interface{}(i.With).(Spanned); ok </span><span class="cov0" title="0">{
                        spans = append(spans, spanned.Span())
                }</span>
        }

        <span class="cov0" title="0">for _, col := range i.Columns </span><span class="cov0" title="0">{
                if spanned, ok := col.(Spanned); ok </span><span class="cov0" title="0">{
                        spans = append(spans, spanned.Span())
                }</span>
        }

        <span class="cov0" title="0">for _, val := range i.Values </span><span class="cov0" title="0">{
                if spanned, ok := val.(Spanned); ok </span><span class="cov0" title="0">{
                        spans = append(spans, spanned.Span())
                }</span>
        }

        <span class="cov0" title="0">if i.Query != nil </span><span class="cov0" title="0">{
                if spanned, ok := interface{}(i.Query).(Spanned); ok </span><span class="cov0" title="0">{
                        spans = append(spans, spanned.Span())
                }</span>
        }

        <span class="cov0" title="0">for _, expr := range i.Returning </span><span class="cov0" title="0">{
                if spanned, ok := expr.(Spanned); ok </span><span class="cov0" title="0">{
                        spans = append(spans, spanned.Span())
                }</span>
        }

        <span class="cov0" title="0">return UnionSpans(spans)</span>
}

// Span returns the source location span for the UpdateStatement
func (u *UpdateStatement) Span() models.Span <span class="cov0" title="0">{
        return GetSpan(u)
}</span>

// Span returns the source location span for the DeleteStatement
func (d *DeleteStatement) Span() models.Span <span class="cov0" title="0">{
        return GetSpan(d)
}</span>

// Span returns the source location span for expressions
func (e *BinaryExpression) Span() models.Span <span class="cov0" title="0">{
        spans := make([]models.Span, 0)

        if e.Left != nil </span><span class="cov0" title="0">{
                if spanned, ok := e.Left.(Spanned); ok </span><span class="cov0" title="0">{
                        spans = append(spans, spanned.Span())
                }</span>
        }

        <span class="cov0" title="0">if e.Right != nil </span><span class="cov0" title="0">{
                if spanned, ok := e.Right.(Spanned); ok </span><span class="cov0" title="0">{
                        spans = append(spans, spanned.Span())
                }</span>
        }

        <span class="cov0" title="0">return UnionSpans(spans)</span>
}

func (e *UnaryExpression) Span() models.Span <span class="cov0" title="0">{
        if e.Expr != nil </span><span class="cov0" title="0">{
                if spanned, ok := e.Expr.(Spanned); ok </span><span class="cov0" title="0">{
                        return spanned.Span()
                }</span>
        }
        <span class="cov0" title="0">return models.EmptySpan()</span>
}

func (e *CastExpression) Span() models.Span <span class="cov0" title="0">{
        if e.Expr != nil </span><span class="cov0" title="0">{
                if spanned, ok := e.Expr.(Spanned); ok </span><span class="cov0" title="0">{
                        return spanned.Span()
                }</span>
        }
        <span class="cov0" title="0">return models.EmptySpan()</span>
}

func (e *FunctionCall) Span() models.Span <span class="cov0" title="0">{
        spans := make([]models.Span, 0)

        for _, arg := range e.Arguments </span><span class="cov0" title="0">{
                if spanned, ok := arg.(Spanned); ok </span><span class="cov0" title="0">{
                        spans = append(spans, spanned.Span())
                }</span>
        }

        <span class="cov0" title="0">return UnionSpans(spans)</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package ast

import (
        "fmt"
        "strings"
)

// TriggerObject specifies whether the trigger function should be fired once for every row
// affected by the trigger event, or just once per SQL statement.
type TriggerObject int

const (
        TriggerObjectRow TriggerObject = iota
        TriggerObjectStatement
)

func (t TriggerObject) String() string <span class="cov8" title="1">{
        switch t </span>{
        case TriggerObjectRow:<span class="cov8" title="1">
                return "ROW"</span>
        case TriggerObjectStatement:<span class="cov8" title="1">
                return "STATEMENT"</span>
        default:<span class="cov8" title="1">
                return "UNKNOWN"</span>
        }
}

// TriggerReferencingType indicates whether the following relation name is for
// the before-image transition relation or the after-image transition relation
type TriggerReferencingType int

const (
        TriggerReferencingOldTable TriggerReferencingType = iota
        TriggerReferencingNewTable
)

func (t TriggerReferencingType) String() string <span class="cov8" title="1">{
        switch t </span>{
        case TriggerReferencingOldTable:<span class="cov8" title="1">
                return "OLD TABLE"</span>
        case TriggerReferencingNewTable:<span class="cov8" title="1">
                return "NEW TABLE"</span>
        default:<span class="cov8" title="1">
                return "UNKNOWN"</span>
        }
}

// TriggerReferencing represents a declaration of relation names that provide access
// to the transition relations of the triggering statement
type TriggerReferencing struct {
        ReferType              TriggerReferencingType
        IsAs                   bool
        TransitionRelationName ObjectName
}

func (t TriggerReferencing) String() string <span class="cov8" title="1">{
        var as string
        if t.IsAs </span><span class="cov8" title="1">{
                as = " AS"
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s%s %s", t.ReferType, as, t.TransitionRelationName)</span>
}

// TriggerEvent describes trigger events
type TriggerEvent struct {
        Type    TriggerEventType
        Columns []Identifier // Only used for UPDATE events
}

type TriggerEventType int

const (
        TriggerEventInsert TriggerEventType = iota
        TriggerEventUpdate
        TriggerEventDelete
        TriggerEventTruncate
)

func (t TriggerEvent) String() string <span class="cov8" title="1">{
        switch t.Type </span>{
        case TriggerEventInsert:<span class="cov8" title="1">
                return "INSERT"</span>
        case TriggerEventUpdate:<span class="cov8" title="1">
                if len(t.Columns) == 0 </span><span class="cov8" title="1">{
                        return "UPDATE"
                }</span>
                <span class="cov8" title="1">cols := make([]string, len(t.Columns))
                for i, col := range t.Columns </span><span class="cov8" title="1">{
                        cols[i] = col.TokenLiteral()
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("UPDATE OF %s", strings.Join(cols, ", "))</span>
        case TriggerEventDelete:<span class="cov8" title="1">
                return "DELETE"</span>
        case TriggerEventTruncate:<span class="cov8" title="1">
                return "TRUNCATE"</span>
        default:<span class="cov8" title="1">
                return "UNKNOWN"</span>
        }
}

// TriggerPeriod represents when the trigger should be executed
type TriggerPeriod int

const (
        TriggerPeriodAfter TriggerPeriod = iota
        TriggerPeriodBefore
        TriggerPeriodInsteadOf
)

func (t TriggerPeriod) String() string <span class="cov8" title="1">{
        switch t </span>{
        case TriggerPeriodAfter:<span class="cov8" title="1">
                return "AFTER"</span>
        case TriggerPeriodBefore:<span class="cov8" title="1">
                return "BEFORE"</span>
        case TriggerPeriodInsteadOf:<span class="cov8" title="1">
                return "INSTEAD OF"</span>
        default:<span class="cov8" title="1">
                return "UNKNOWN"</span>
        }
}

// TriggerExecBodyType represents types of trigger body execution
type TriggerExecBodyType int

const (
        TriggerExecBodyFunction TriggerExecBodyType = iota
        TriggerExecBodyProcedure
)

func (t TriggerExecBodyType) String() string <span class="cov8" title="1">{
        switch t </span>{
        case TriggerExecBodyFunction:<span class="cov8" title="1">
                return "FUNCTION"</span>
        case TriggerExecBodyProcedure:<span class="cov8" title="1">
                return "PROCEDURE"</span>
        default:<span class="cov8" title="1">
                return "UNKNOWN"</span>
        }
}

// TriggerExecBody represents the execution body of a trigger
type TriggerExecBody struct {
        ExecType TriggerExecBodyType
        FuncDesc FunctionDesc
}

func (t TriggerExecBody) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s %s", t.ExecType, t.FuncDesc)
}</span>

// Implement Node interface for trigger types
func (t TriggerObject) Children() []Node          <span class="cov0" title="0">{ return nil }</span>
func (t TriggerObject) TokenLiteral() string      <span class="cov0" title="0">{ return t.String() }</span>
func (t TriggerReferencing) Children() []Node     <span class="cov0" title="0">{ return nil }</span>
func (t TriggerReferencing) TokenLiteral() string <span class="cov0" title="0">{ return t.String() }</span>
func (t TriggerEvent) Children() []Node           <span class="cov0" title="0">{ return nil }</span>
func (t TriggerEvent) TokenLiteral() string       <span class="cov0" title="0">{ return t.String() }</span>
func (t TriggerPeriod) Children() []Node          <span class="cov0" title="0">{ return nil }</span>
func (t TriggerPeriod) TokenLiteral() string      <span class="cov0" title="0">{ return t.String() }</span>
func (t TriggerExecBody) Children() []Node        <span class="cov0" title="0">{ return nil }</span>
func (t TriggerExecBody) TokenLiteral() string    <span class="cov0" title="0">{ return t.String() }</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package ast

// ColumnPosition represents the position of a column in a table
type ColumnPosition struct {
        First    bool
        After    *Ident
        Position int
}

// Partition represents table partitioning information
type Partition struct {
        Name    string
        Columns []*Ident
}

// DropBehavior specifies the behavior when dropping objects
type DropBehavior int

const (
        DropCascade DropBehavior = iota
        DropRestrict
)

// AlterColumnOperation represents operations that can be performed on columns
type AlterColumnOperation int

const (
        AlterColumnSetDefault AlterColumnOperation = iota
        AlterColumnDropDefault
        AlterColumnSetNotNull
        AlterColumnDropNotNull
)

// Make AlterColumnOperation implement Node interface
func (a *AlterColumnOperation) Children() []Node <span class="cov0" title="0">{ return nil }</span>
func (a *AlterColumnOperation) TokenLiteral() string <span class="cov0" title="0">{
        switch *a </span>{
        case AlterColumnSetDefault:<span class="cov0" title="0">
                return "SET DEFAULT"</span>
        case AlterColumnDropDefault:<span class="cov0" title="0">
                return "DROP DEFAULT"</span>
        case AlterColumnSetNotNull:<span class="cov0" title="0">
                return "SET NOT NULL"</span>
        case AlterColumnDropNotNull:<span class="cov0" title="0">
                return "DROP NOT NULL"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// HiveDistributionStyle represents Hive-specific distribution styles
type HiveDistributionStyle int

const (
        HiveDistributionNone HiveDistributionStyle = iota
        HiveDistributionHash
        HiveDistributionRandom
)

// HiveFormat represents Hive-specific storage formats
type HiveFormat int

const (
        HiveFormatNone HiveFormat = iota
        HiveFormatORC
        HiveFormatParquet
        HiveFormatAvro
)

// SqlOption represents SQL-specific options
type SqlOption struct {
        Name  string
        Value string
}

// FileFormat represents file format specifications
type FileFormat int

const (
        FileFormatNone FileFormat = iota
        FileFormatCSV
        FileFormatJSON
        FileFormatParquet
)

// Query represents a SQL query
type Query struct {
        Text string
}

func (q *Query) TokenLiteral() string <span class="cov0" title="0">{ return "QUERY" }</span>
func (q *Query) Children() []Node     <span class="cov0" title="0">{ return nil }</span>

// Setting represents a SET clause in an UPDATE statement
type Setting struct {
        Column *Ident
        Value  Expression
}

// Ident represents an identifier in SQL (table name, column name, etc.)
type Ident struct {
        Name string
}

func (i *Ident) String() string <span class="cov0" title="0">{ return i.Name }</span>

// Make Ident implement Expression interface
func (*Ident) expressionNode()        {<span class="cov0" title="0">}</span>
func (i *Ident) TokenLiteral() string <span class="cov0" title="0">{ return i.Name }</span>
func (i *Ident) Children() []Node     <span class="cov0" title="0">{ return nil }</span>

// InputFormatClause represents the format specification for input data
type InputFormatClause struct {
        Format  string
        Options map[string]string
}

// TableEngine represents the storage engine for a table
type TableEngine string

// CommentDef represents a comment on a database object
type CommentDef struct {
        Text string
}

func (c *CommentDef) TokenLiteral() string <span class="cov0" title="0">{ return "COMMENT" }</span>
func (c *CommentDef) Children() []Node     <span class="cov0" title="0">{ return nil }</span>

// OnCommit represents the ON COMMIT behavior for temporary tables
type OnCommit int

const (
        OnCommitNone OnCommit = iota
        OnCommitDelete
        OnCommitPreserve
)

// Expr represents a SQL expression
type Expr interface {
        Node
        exprNode()
}

// OneOrManyWithParens represents a list of items enclosed in parentheses
type OneOrManyWithParens[T any] struct {
        Items []T
}

func (o *OneOrManyWithParens[T]) TokenLiteral() string <span class="cov0" title="0">{ return "(" }</span>
func (o *OneOrManyWithParens[T]) Children() []Node <span class="cov0" title="0">{
        nodes := make([]Node, len(o.Items))
        for i, item := range o.Items </span><span class="cov0" title="0">{
                if node, ok := any(item).(Node); ok </span><span class="cov0" title="0">{
                        nodes[i] = node
                }</span>
        }
        <span class="cov0" title="0">return nodes</span>
}

// WrappedCollection represents a collection of items with optional wrapper
type WrappedCollection[T any] struct {
        Items   []T
        Wrapper string
}

func (w *WrappedCollection[T]) TokenLiteral() string <span class="cov0" title="0">{ return w.Wrapper }</span>
func (w *WrappedCollection[T]) Children() []Node <span class="cov0" title="0">{
        nodes := make([]Node, len(w.Items))
        for i, item := range w.Items </span><span class="cov0" title="0">{
                if node, ok := any(item).(Node); ok </span><span class="cov0" title="0">{
                        nodes[i] = node
                }</span>
        }
        <span class="cov0" title="0">return nodes</span>
}

// ClusteredBy represents CLUSTERED BY clause
type ClusteredBy struct {
        Columns []Node
        Buckets int
}

func (c *ClusteredBy) TokenLiteral() string <span class="cov0" title="0">{ return "CLUSTERED BY" }</span>
func (c *ClusteredBy) Children() []Node     <span class="cov0" title="0">{ return c.Columns }</span>

// RowAccessPolicy represents row-level access policy
type RowAccessPolicy struct {
        Name    string
        Filter  Expr
        Enabled bool
}

func (r *RowAccessPolicy) TokenLiteral() string <span class="cov0" title="0">{ return "ROW ACCESS POLICY" }</span>
func (r *RowAccessPolicy) Children() []Node <span class="cov0" title="0">{
        if r.Filter != nil </span><span class="cov0" title="0">{
                return []Node{r.Filter}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Tag represents a key-value metadata tag
type Tag struct {
        Key   string
        Value string
}

// StorageSerializationPolicy represents storage serialization policy
type StorageSerializationPolicy int

const (
        StorageSerializationNone StorageSerializationPolicy = iota
        StorageSerializationJSON
        StorageSerializationAvro
)

// StatementVariant represents a specific type of SQL statement
type StatementVariant interface {
        Node
        statementNode()
}

// StatementImpl represents a concrete implementation of a SQL statement
type StatementImpl struct {
        Variant StatementVariant
}

func (s *StatementImpl) TokenLiteral() string <span class="cov0" title="0">{ return s.Variant.TokenLiteral() }</span>
func (s *StatementImpl) Children() []Node     <span class="cov0" title="0">{ return []Node{s.Variant} }</span>
func (s *StatementImpl) statementNode()       {<span class="cov0" title="0">}</span>

// CreateTable represents a CREATE TABLE statement
type CreateTable struct {
        Name                  ObjectName
        Columns               []ColumnDef
        Constraints           []TableConstraint
        Options               *[]SqlOption
        IfNotExists           bool
        Temporary             bool
        External              bool
        Stored                bool
        Transient             bool
        OrReplace             bool
        Global                *bool
        Volatile              bool
        Iceberg               bool
        HiveDistribution      HiveDistributionStyle
        HiveFormats           *HiveFormat
        TableProperties       []SqlOption
        WithOptions           []SqlOption
        FileFormat            *FileFormat
        Location              *string
        Query                 *Query
        WithoutRowID          bool
        Like                  *ObjectName
        Clone                 *ObjectName
        Engine                *TableEngine
        Comment               *CommentDef
        AutoIncrementOffset   *uint32
        DefaultCharset        *string
        Collation             *string
        OnCommit              *OnCommit
        OnCluster             *Ident
        PrimaryKey            *Expr
        OrderBy               *OneOrManyWithParens[Expr]
        PartitionBy           *Expr
        ClusterBy             *WrappedCollection[[]Ident]
        ClusteredBy           *ClusteredBy
        Strict                bool
        CopyGrants            bool
        EnableSchemaEvolution *bool
        ChangeTracking        *bool
        DataRetentionDays     *uint64
        MaxDataExtensionDays  *uint64
        DefaultDDLCollation   *string
        AggregationPolicy     *ObjectName
        RowAccessPolicy       *RowAccessPolicy
        Tags                  *[]Tag
        BaseLocation          *string
        ExternalVolume        *string
        Catalog               *string
        CatalogSync           *string
        SerializationPolicy   *StorageSerializationPolicy
}

func (*CreateTable) statementNode() {<span class="cov0" title="0">}</span>
func (c *CreateTable) Children() []Node <span class="cov0" title="0">{
        nodes := []Node{c.Name}
        for _, col := range c.Columns </span><span class="cov0" title="0">{
                nodes = append(nodes, col)
        }</span>
        <span class="cov0" title="0">for _, con := range c.Constraints </span><span class="cov0" title="0">{
                nodes = append(nodes, con)
        }</span>
        <span class="cov0" title="0">if c.Query != nil </span><span class="cov0" title="0">{
                nodes = append(nodes, c.Query)
        }</span>
        <span class="cov0" title="0">if c.Like != nil </span><span class="cov0" title="0">{
                nodes = append(nodes, c.Like)
        }</span>
        <span class="cov0" title="0">if c.Clone != nil </span><span class="cov0" title="0">{
                nodes = append(nodes, c.Clone)
        }</span>
        <span class="cov0" title="0">if c.Comment != nil </span><span class="cov0" title="0">{
                nodes = append(nodes, c.Comment)
        }</span>
        <span class="cov0" title="0">if c.ClusteredBy != nil </span><span class="cov0" title="0">{
                nodes = append(nodes, c.ClusteredBy)
        }</span>
        <span class="cov0" title="0">if c.RowAccessPolicy != nil </span><span class="cov0" title="0">{
                nodes = append(nodes, c.RowAccessPolicy)
        }</span>
        <span class="cov0" title="0">return nodes</span>
}
func (c *CreateTable) TokenLiteral() string <span class="cov0" title="0">{ return "CREATE TABLE" }</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package ast

import (
        "fmt"
        "strings"
)

// Value represents primitive SQL values such as number and string
type Value struct {
        Type  ValueType
        Value interface{}
}

// ValueType represents the type of a SQL value
type ValueType int

const (
        NumberValue ValueType = iota
        SingleQuotedStringValue
        DollarQuotedStringValue
        TripleSingleQuotedStringValue
        TripleDoubleQuotedStringValue
        EscapedStringLiteralValue
        UnicodeStringLiteralValue
        SingleQuotedByteStringLiteralValue
        DoubleQuotedByteStringLiteralValue
        TripleSingleQuotedByteStringLiteralValue
        TripleDoubleQuotedByteStringLiteralValue
        SingleQuotedRawStringLiteralValue
        DoubleQuotedRawStringLiteralValue
        TripleSingleQuotedRawStringLiteralValue
        TripleDoubleQuotedRawStringLiteralValue
        NationalStringLiteralValue
        HexStringLiteralValue
        DoubleQuotedStringValue
        BooleanValue
        NullValue
        PlaceholderValue
)

// DollarQuotedString represents a dollar-quoted string with an optional tag
type DollarQuotedString struct {
        Value string
        Tag   string
}

func (v Value) String() string <span class="cov8" title="1">{
        switch v.Type </span>{
        case NumberValue:<span class="cov8" title="1">
                if n, ok := v.Value.(Number); ok </span><span class="cov8" title="1">{
                        if n.Long </span><span class="cov8" title="1">{
                                return fmt.Sprintf("%sL", n.Value)
                        }</span>
                        <span class="cov8" title="1">return n.Value</span>
                }
                <span class="cov0" title="0">return fmt.Sprintf("%v", v.Value)</span>
        case SingleQuotedStringValue:<span class="cov8" title="1">
                return fmt.Sprintf("'%s'", escapeSingleQuoteString(v.Value.(string)))</span>
        case DollarQuotedStringValue:<span class="cov8" title="1">
                dq := v.Value.(DollarQuotedString)
                if dq.Tag != "" </span><span class="cov8" title="1">{
                        return fmt.Sprintf("$%s$%s$%s$", dq.Tag, dq.Value, dq.Tag)
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("$$%s$$", dq.Value)</span>
        case TripleSingleQuotedStringValue:<span class="cov8" title="1">
                return fmt.Sprintf("'''%s'''", v.Value)</span>
        case TripleDoubleQuotedStringValue:<span class="cov8" title="1">
                return fmt.Sprintf(`"""%s"""`, v.Value)</span>
        case EscapedStringLiteralValue:<span class="cov8" title="1">
                return fmt.Sprintf("E'%s'", escapeEscapedString(v.Value.(string)))</span>
        case UnicodeStringLiteralValue:<span class="cov8" title="1">
                return fmt.Sprintf("U&amp;'%s'", escapeUnicodeString(v.Value.(string)))</span>
        case SingleQuotedByteStringLiteralValue:<span class="cov0" title="0">
                return fmt.Sprintf("B'%s'", v.Value)</span>
        case DoubleQuotedByteStringLiteralValue:<span class="cov0" title="0">
                return fmt.Sprintf(`B"%s"`, v.Value)</span>
        case TripleSingleQuotedByteStringLiteralValue:<span class="cov0" title="0">
                return fmt.Sprintf("B'''%s'''", v.Value)</span>
        case TripleDoubleQuotedByteStringLiteralValue:<span class="cov0" title="0">
                return fmt.Sprintf(`B"""%s"""`, v.Value)</span>
        case SingleQuotedRawStringLiteralValue:<span class="cov0" title="0">
                return fmt.Sprintf("R'%s'", v.Value)</span>
        case DoubleQuotedRawStringLiteralValue:<span class="cov0" title="0">
                return fmt.Sprintf(`R"%s"`, v.Value)</span>
        case TripleSingleQuotedRawStringLiteralValue:<span class="cov0" title="0">
                return fmt.Sprintf("R'''%s'''", v.Value)</span>
        case TripleDoubleQuotedRawStringLiteralValue:<span class="cov0" title="0">
                return fmt.Sprintf(`R"""%s"""`, v.Value)</span>
        case NationalStringLiteralValue:<span class="cov0" title="0">
                return fmt.Sprintf("N'%s'", v.Value)</span>
        case HexStringLiteralValue:<span class="cov0" title="0">
                return fmt.Sprintf("X'%s'", v.Value)</span>
        case DoubleQuotedStringValue:<span class="cov0" title="0">
                return fmt.Sprintf(`"%s"`, escapeDoubleQuoteString(v.Value.(string)))</span>
        case BooleanValue:<span class="cov8" title="1">
                return fmt.Sprintf("%v", v.Value)</span>
        case NullValue:<span class="cov8" title="1">
                return "NULL"</span>
        case PlaceholderValue:<span class="cov8" title="1">
                return v.Value.(string)</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%v", v.Value)</span>
        }
}

// Number represents a numeric value with a flag indicating if it's a long
type Number struct {
        Value string
        Long  bool
}

func (v Value) Children() []Node <span class="cov0" title="0">{
        return nil
}</span>

func (v Value) TokenLiteral() string <span class="cov0" title="0">{
        return v.String()
}</span>

func escapeSingleQuoteString(s string) string <span class="cov8" title="1">{
        return escapeQuotedString(s, '\'')
}</span>

func escapeDoubleQuoteString(s string) string <span class="cov0" title="0">{
        return escapeQuotedString(s, '"')
}</span>

func escapeQuotedString(s string, quote rune) string <span class="cov8" title="1">{
        var result strings.Builder
        prevChar := rune(0)
        chars := []rune(s)
        for i := 0; i &lt; len(chars); i++ </span><span class="cov8" title="1">{
                ch := chars[i]
                if ch == quote </span><span class="cov8" title="1">{
                        if prevChar == '\\' </span><span class="cov8" title="1">{
                                result.WriteRune(ch)
                                continue</span>
                        }
                        <span class="cov8" title="1">result.WriteRune(ch)
                        result.WriteRune(ch)</span>
                } else<span class="cov8" title="1"> {
                        result.WriteRune(ch)
                }</span>
                <span class="cov8" title="1">prevChar = ch</span>
        }
        <span class="cov8" title="1">return result.String()</span>
}

func escapeEscapedString(s string) string <span class="cov8" title="1">{
        var result strings.Builder
        for _, ch := range s </span><span class="cov8" title="1">{
                switch ch </span>{
                case '\'':<span class="cov8" title="1">
                        result.WriteString(`\'`)</span>
                case '\\':<span class="cov8" title="1">
                        result.WriteString(`\\`)</span>
                case '\n':<span class="cov8" title="1">
                        result.WriteString(`\n`)</span>
                case '\t':<span class="cov8" title="1">
                        result.WriteString(`\t`)</span>
                case '\r':<span class="cov8" title="1">
                        result.WriteString(`\r`)</span>
                default:<span class="cov8" title="1">
                        result.WriteRune(ch)</span>
                }
        }
        <span class="cov8" title="1">return result.String()</span>
}

func escapeUnicodeString(s string) string <span class="cov8" title="1">{
        var result strings.Builder
        for _, ch := range s </span><span class="cov8" title="1">{
                switch ch </span>{
                case '\'':<span class="cov8" title="1">
                        result.WriteString("''")</span>
                case '\\':<span class="cov8" title="1">
                        result.WriteString(`\\`)</span>
                default:<span class="cov8" title="1">
                        if ch &lt;= 127 </span><span class="cov8" title="1">{ // ASCII
                                result.WriteRune(ch)
                        }</span> else<span class="cov8" title="1"> {
                                codepoint := int(ch)
                                if codepoint &lt;= 0xFFFF </span><span class="cov8" title="1">{
                                        result.WriteString(fmt.Sprintf("\\%04X", codepoint))
                                }</span> else<span class="cov8" title="1"> {
                                        result.WriteString(fmt.Sprintf("\\+%06X", codepoint))
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return result.String()</span>
}

// DateTimeField represents date/time fields that can be extracted or used in operations
type DateTimeField int

const (
        Year DateTimeField = iota
        Years
        Month
        Months
        Week
        Weeks
        Day
        DayOfWeek
        DayOfYear
        Days
        Date
        Datetime
        Hour
        Hours
        Minute
        Minutes
        Second
        Seconds
        Century
        Decade
        Dow
        Doy
        Epoch
        Isodow
        IsoWeek
        Isoyear
        Julian
        Microsecond
        Microseconds
        Millenium
        Millennium
        Millisecond
        Milliseconds
        Nanosecond
        Nanoseconds
        Quarter
        Time
        Timezone
        TimezoneAbbr
        TimezoneHour
        TimezoneMinute
        TimezoneRegion
        NoDateTime
        CustomDateTime
)

func (d DateTimeField) String() string <span class="cov8" title="1">{
        switch d </span>{
        case Year:<span class="cov8" title="1">
                return "YEAR"</span>
        case Years:<span class="cov0" title="0">
                return "YEARS"</span>
        case Month:<span class="cov8" title="1">
                return "MONTH"</span>
        case Months:<span class="cov0" title="0">
                return "MONTHS"</span>
        case Week:<span class="cov8" title="1">
                return "WEEK"</span>
        case Weeks:<span class="cov0" title="0">
                return "WEEKS"</span>
        case Day:<span class="cov8" title="1">
                return "DAY"</span>
        case DayOfWeek:<span class="cov8" title="1">
                return "DAYOFWEEK"</span>
        case DayOfYear:<span class="cov8" title="1">
                return "DAYOFYEAR"</span>
        case Days:<span class="cov0" title="0">
                return "DAYS"</span>
        case Date:<span class="cov0" title="0">
                return "DATE"</span>
        case Datetime:<span class="cov0" title="0">
                return "DATETIME"</span>
        case Hour:<span class="cov8" title="1">
                return "HOUR"</span>
        case Hours:<span class="cov0" title="0">
                return "HOURS"</span>
        case Minute:<span class="cov8" title="1">
                return "MINUTE"</span>
        case Minutes:<span class="cov0" title="0">
                return "MINUTES"</span>
        case Second:<span class="cov8" title="1">
                return "SECOND"</span>
        case Seconds:<span class="cov0" title="0">
                return "SECONDS"</span>
        case Century:<span class="cov0" title="0">
                return "CENTURY"</span>
        case Decade:<span class="cov0" title="0">
                return "DECADE"</span>
        case Dow:<span class="cov0" title="0">
                return "DOW"</span>
        case Doy:<span class="cov0" title="0">
                return "DOY"</span>
        case Epoch:<span class="cov0" title="0">
                return "EPOCH"</span>
        case Isodow:<span class="cov0" title="0">
                return "ISODOW"</span>
        case IsoWeek:<span class="cov8" title="1">
                return "ISOWEEK"</span>
        case Isoyear:<span class="cov0" title="0">
                return "ISOYEAR"</span>
        case Julian:<span class="cov0" title="0">
                return "JULIAN"</span>
        case Microsecond:<span class="cov8" title="1">
                return "MICROSECOND"</span>
        case Microseconds:<span class="cov0" title="0">
                return "MICROSECONDS"</span>
        case Millenium:<span class="cov0" title="0">
                return "MILLENIUM"</span>
        case Millennium:<span class="cov0" title="0">
                return "MILLENNIUM"</span>
        case Millisecond:<span class="cov8" title="1">
                return "MILLISECOND"</span>
        case Milliseconds:<span class="cov0" title="0">
                return "MILLISECONDS"</span>
        case Nanosecond:<span class="cov8" title="1">
                return "NANOSECOND"</span>
        case Nanoseconds:<span class="cov0" title="0">
                return "NANOSECONDS"</span>
        case Quarter:<span class="cov8" title="1">
                return "QUARTER"</span>
        case Time:<span class="cov0" title="0">
                return "TIME"</span>
        case Timezone:<span class="cov8" title="1">
                return "TIMEZONE"</span>
        case TimezoneAbbr:<span class="cov0" title="0">
                return "TIMEZONE_ABBR"</span>
        case TimezoneHour:<span class="cov0" title="0">
                return "TIMEZONE_HOUR"</span>
        case TimezoneMinute:<span class="cov0" title="0">
                return "TIMEZONE_MINUTE"</span>
        case TimezoneRegion:<span class="cov0" title="0">
                return "TIMEZONE_REGION"</span>
        case NoDateTime:<span class="cov8" title="1">
                return "NODATETIME"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// NormalizationForm represents Unicode normalization forms
type NormalizationForm int

const (
        NFC NormalizationForm = iota
        NFD
        NFKC
        NFKD
)

func (n NormalizationForm) String() string <span class="cov8" title="1">{
        switch n </span>{
        case NFC:<span class="cov8" title="1">
                return "NFC"</span>
        case NFD:<span class="cov8" title="1">
                return "NFD"</span>
        case NFKC:<span class="cov8" title="1">
                return "NFKC"</span>
        case NFKD:<span class="cov8" title="1">
                return "NFKD"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// TrimWhereField represents the type of trimming operation
type TrimWhereField int

const (
        Both TrimWhereField = iota
        Leading
        Trailing
)

func (t TrimWhereField) String() string <span class="cov8" title="1">{
        switch t </span>{
        case Both:<span class="cov8" title="1">
                return "BOTH"</span>
        case Leading:<span class="cov8" title="1">
                return "LEADING"</span>
        case Trailing:<span class="cov8" title="1">
                return "TRAILING"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package ast

// Visitor defines an interface for traversing the AST.
// The Visit method is called for each node encountered by Walk.
// If the result visitor w is not nil, Walk visits each of the children
// of node with the visitor w, followed by a call of w.Visit(nil).
type Visitor interface {
        Visit(node Node) (w Visitor, err error)
}

// Walk traverses an AST in depth-first order: It starts by calling
// v.Visit(node); node must not be nil. If the visitor w returned by
// v.Visit(node) is not nil, Walk is invoked recursively with visitor
// w for each of the non-nil children of node, followed by a call of
// w.Visit(nil).
func Walk(v Visitor, node Node) error <span class="cov8" title="1">{
        if node == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">visitor, err := v.Visit(node)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if visitor == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, child := range node.Children() </span><span class="cov8" title="1">{
                if err := Walk(visitor, child); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">_, err = visitor.Visit(nil)
        return err</span>
}

// Inspector represents an AST visitor that can be used to traverse an AST
// and invoke a custom function for each node.
type Inspector func(Node) bool

// Visit implements the Visitor interface.
func (f Inspector) Visit(node Node) (Visitor, error) <span class="cov8" title="1">{
        if f(node) </span><span class="cov8" title="1">{
                return f, nil
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

// Inspect traverses an AST in depth-first order: It starts by calling
// f(node); node must not be nil. If f returns true, Inspect invokes f
// recursively for each of the non-nil children of node, followed by a
// call of f(nil).
func Inspect(node Node, f func(Node) bool) <span class="cov8" title="1">{
        _ = Walk(Inspector(f), node)
}</span>

// VisitFunc is a function type that can be used to implement custom visitors
// without creating a new type.
type VisitFunc func(Node) (Visitor, error)

// Visit implements the Visitor interface.
func (f VisitFunc) Visit(node Node) (Visitor, error) <span class="cov8" title="1">{
        return f(node)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package keywords

import (
        "strings"

        "github.com/ajitpratap0/GoSQLX/pkg/models"
)

// KeywordCategory represents a category of SQL keywords
type KeywordCategory map[string]models.TokenType

// Keywords holds all SQL keyword categories and configuration
type Keywords struct {
        // Keyword categories
        DMLKeywords      KeywordCategory
        CompoundKeywords KeywordCategory

        // Core keyword mapping and configuration
        keywordMap       map[string]Keyword
        reservedKeywords map[string]bool
        dialect          SQLDialect
        ignoreCase       bool
}

// NewKeywords creates a new Keywords instance
func NewKeywords() *Keywords <span class="cov0" title="0">{
        k := &amp;Keywords{
                DMLKeywords:      make(KeywordCategory),
                CompoundKeywords: make(KeywordCategory),
                keywordMap:       make(map[string]Keyword),
                reservedKeywords: make(map[string]bool),
                ignoreCase:       true,
        }
        k.initialize()
        return k
}</span>

// initialize sets up the initial keyword mappings
func (k *Keywords) initialize() <span class="cov0" title="0">{
        // Initialize DML keywords
        k.DMLKeywords = map[string]models.TokenType{
                "DISTINCT": models.TokenTypeKeyword,
                "ALL":      models.TokenTypeKeyword,
                "FETCH":    models.TokenTypeKeyword,
                "NEXT":     models.TokenTypeKeyword,
                "ROWS":     models.TokenTypeKeyword,
                "ONLY":     models.TokenTypeKeyword,
                "WITH":     models.TokenTypeKeyword,
                "TIES":     models.TokenTypeKeyword,
                "NULLS":    models.TokenTypeKeyword,
                "FIRST":    models.TokenTypeKeyword,
                "LAST":     models.TokenTypeKeyword,
        }

        // Initialize compound keywords
        k.CompoundKeywords = map[string]models.TokenType{
                "FULL JOIN":    models.TokenTypeKeyword,
                "CROSS JOIN":   models.TokenTypeKeyword,
                "NATURAL JOIN": models.TokenTypeKeyword,
                "GROUP BY":     models.TokenTypeKeyword,
                "ORDER BY":     models.TokenTypeKeyword,
                "LEFT JOIN":    models.TokenTypeKeyword,
        }

        // Add all keywords to the main keyword map
        for word, tokenType := range k.DMLKeywords </span><span class="cov0" title="0">{
                k.keywordMap[word] = Keyword{
                        Word:     word,
                        Type:     tokenType,
                        Reserved: true,
                }
                k.reservedKeywords[word] = true
        }</span>

        <span class="cov0" title="0">for word, tokenType := range k.CompoundKeywords </span><span class="cov0" title="0">{
                k.keywordMap[word] = Keyword{
                        Word:     word,
                        Type:     tokenType,
                        Reserved: true,
                }
                k.reservedKeywords[word] = true
        }</span>
}

// IsKeyword checks if a string is a keyword
func (k *Keywords) IsKeyword(s string) bool <span class="cov8" title="1">{
        if k.ignoreCase </span><span class="cov8" title="1">{
                s = strings.ToUpper(s)
        }</span>
        <span class="cov8" title="1">_, ok := k.keywordMap[s]
        return ok</span>
}

// GetKeywordType returns the token type for a keyword
func (k *Keywords) GetKeywordType(s string) models.TokenType <span class="cov0" title="0">{
        if k.ignoreCase </span><span class="cov0" title="0">{
                s = strings.ToUpper(s)
        }</span>
        <span class="cov0" title="0">if kw, ok := k.keywordMap[s]; ok </span><span class="cov0" title="0">{
                return kw.Type
        }</span>
        <span class="cov0" title="0">return models.TokenTypeWord</span>
}

// IsReserved checks if a keyword is reserved
func (k *Keywords) IsReserved(s string) bool <span class="cov8" title="1">{
        if k.ignoreCase </span><span class="cov8" title="1">{
                s = strings.ToUpper(s)
        }</span>
        <span class="cov8" title="1">return k.reservedKeywords[s]</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package keywords

import "github.com/ajitpratap0/GoSQLX/pkg/models"

// IsCompoundKeyword checks if a string is a compound keyword
func (k *Keywords) IsCompoundKeyword(s string) bool <span class="cov0" title="0">{
        _, ok := k.CompoundKeywords[s]
        return ok
}</span>

// GetCompoundKeywordType returns the token type for a compound keyword
func (k *Keywords) GetCompoundKeywordType(s string) (models.TokenType, bool) <span class="cov0" title="0">{
        t, ok := k.CompoundKeywords[s]
        return t, ok
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package keywords

import (
        "strings"

        "github.com/ajitpratap0/GoSQLX/pkg/models"
)

// SQLDialect represents different SQL dialects
type SQLDialect string

const (
        DialectUnknown    SQLDialect = "unknown"
        DialectGeneric    SQLDialect = "generic"
        DialectMySQL      SQLDialect = "mysql"
        DialectPostgreSQL SQLDialect = "postgresql"
        DialectSQLite     SQLDialect = "sqlite"
)

// GetCompoundKeywords returns the compound keywords map
func (k *Keywords) GetCompoundKeywords() KeywordCategory <span class="cov8" title="1">{
        return k.CompoundKeywords
}</span>

// IsCompoundKeywordStart checks if a word can start a compound keyword
func (k *Keywords) IsCompoundKeywordStart(word string) bool <span class="cov8" title="1">{
        if k.ignoreCase </span><span class="cov8" title="1">{
                word = strings.ToUpper(word)
        }</span>
        <span class="cov8" title="1">for compound := range k.CompoundKeywords </span><span class="cov8" title="1">{
                if strings.HasPrefix(compound, word+" ") </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// MySQL specific keywords
var MYSQL_SPECIFIC = []Keyword{
        {Word: "BINARY", Type: models.TokenTypeKeyword},
        {Word: "CHAR", Type: models.TokenTypeKeyword},
        {Word: "DATETIME", Type: models.TokenTypeKeyword},
        {Word: "DECIMAL", Type: models.TokenTypeKeyword},
        {Word: "UNSIGNED", Type: models.TokenTypeKeyword},
        {Word: "ZEROFILL", Type: models.TokenTypeKeyword},
        {Word: "FORCE", Type: models.TokenTypeKeyword},
        {Word: "IGNORE", Type: models.TokenTypeKeyword},
        {Word: "INDEX", Type: models.TokenTypeKeyword},
        {Word: "KEY", Type: models.TokenTypeKeyword},
        {Word: "KEYS", Type: models.TokenTypeKeyword},
        {Word: "KILL", Type: models.TokenTypeKeyword},
        {Word: "OPTION", Type: models.TokenTypeKeyword},
        {Word: "PURGE", Type: models.TokenTypeKeyword},
        {Word: "READ", Type: models.TokenTypeKeyword},
        {Word: "WRITE", Type: models.TokenTypeKeyword},
        {Word: "STATUS", Type: models.TokenTypeKeyword},
        {Word: "VARIABLES", Type: models.TokenTypeKeyword},
}

// PostgreSQL specific keywords
var POSTGRESQL_SPECIFIC = []Keyword{
        {Word: "MATERIALIZED", Type: models.TokenTypeKeyword},
        {Word: "ILIKE", Type: models.TokenTypeKeyword},
        {Word: "SIMILAR", Type: models.TokenTypeKeyword},
        {Word: "FREEZE", Type: models.TokenTypeKeyword},
        {Word: "ANALYSE", Type: models.TokenTypeKeyword},
        {Word: "ANALYZE", Type: models.TokenTypeKeyword},
        {Word: "CONCURRENTLY", Type: models.TokenTypeKeyword},
        {Word: "REINDEX", Type: models.TokenTypeKeyword},
        {Word: "TOAST", Type: models.TokenTypeKeyword},
        {Word: "NOWAIT", Type: models.TokenTypeKeyword},
        {Word: "RECURSIVE", Type: models.TokenTypeKeyword},
        {Word: "RETURNING", Type: models.TokenTypeKeyword},
}

// SQLite specific keywords
var SQLITE_SPECIFIC = []Keyword{
        {Word: "ABORT", Type: models.TokenTypeKeyword},
        {Word: "ACTION", Type: models.TokenTypeKeyword},
        {Word: "AFTER", Type: models.TokenTypeKeyword},
        {Word: "ATTACH", Type: models.TokenTypeKeyword},
        {Word: "AUTOINCREMENT", Type: models.TokenTypeKeyword},
        {Word: "CONFLICT", Type: models.TokenTypeKeyword},
        {Word: "DATABASE", Type: models.TokenTypeKeyword},
        {Word: "DETACH", Type: models.TokenTypeKeyword},
        {Word: "EXCLUSIVE", Type: models.TokenTypeKeyword},
        {Word: "INDEXED", Type: models.TokenTypeKeyword},
        {Word: "INSTEAD", Type: models.TokenTypeKeyword},
        {Word: "PLAN", Type: models.TokenTypeKeyword},
        {Word: "QUERY", Type: models.TokenTypeKeyword},
        {Word: "RAISE", Type: models.TokenTypeKeyword},
        {Word: "REPLACE", Type: models.TokenTypeKeyword},
        {Word: "TEMP", Type: models.TokenTypeKeyword},
        {Word: "TEMPORARY", Type: models.TokenTypeKeyword},
        {Word: "VACUUM", Type: models.TokenTypeKeyword},
        {Word: "VIRTUAL", Type: models.TokenTypeKeyword},
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package keywords

import "github.com/ajitpratap0/GoSQLX/pkg/models"

// IsDMLKeyword checks if a given string is a DML keyword
func (k *Keywords) IsDMLKeyword(s string) bool <span class="cov0" title="0">{
        _, ok := k.DMLKeywords[s]
        return ok
}</span>

// GetDMLKeywordType returns the token type for a DML keyword
func (k *Keywords) GetDMLKeywordType(s string) (models.TokenType, bool) <span class="cov0" title="0">{
        t, ok := k.DMLKeywords[s]
        return t, ok
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">// Package keywords provides SQL keyword definitions and categorization for multiple SQL dialects.
// It includes reserved words, DDL/DML keywords, dialect-specific extensions, and window function keywords.
package keywords

import (
        "strings"

        "github.com/ajitpratap0/GoSQLX/pkg/models"
)

// Reserved keywords that can't be used as table aliases
var RESERVED_FOR_TABLE_ALIAS = []Keyword{
        {Word: "AS", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "WITH", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "EXPLAIN", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "ANALYZE", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "SELECT", Type: models.TokenTypeSelect, Reserved: true, ReservedForTableAlias: true},
        {Word: "WHERE", Type: models.TokenTypeWhere, Reserved: true, ReservedForTableAlias: true},
        {Word: "GROUP", Type: models.TokenTypeGroup, Reserved: true, ReservedForTableAlias: true},
        {Word: "SORT", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "HAVING", Type: models.TokenTypeHaving, Reserved: true, ReservedForTableAlias: true},
        {Word: "ORDER", Type: models.TokenTypeOrder, Reserved: true, ReservedForTableAlias: true},
        {Word: "PIVOT", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "UNPIVOT", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "TOP", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "LATERAL", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "VIEW", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "LIMIT", Type: models.TokenTypeLimit, Reserved: true, ReservedForTableAlias: true},
        {Word: "OFFSET", Type: models.TokenTypeOffset, Reserved: true, ReservedForTableAlias: true},
        {Word: "FETCH", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "UNION", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "EXCEPT", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "INTERSECT", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "MINUS", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "ON", Type: models.TokenTypeOn, Reserved: true, ReservedForTableAlias: true},
        {Word: "JOIN", Type: models.TokenTypeJoin, Reserved: true, ReservedForTableAlias: true},
        {Word: "INNER", Type: models.TokenTypeInner, Reserved: true, ReservedForTableAlias: true},
        {Word: "CROSS", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "FULL", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "LEFT", Type: models.TokenTypeLeft, Reserved: true, ReservedForTableAlias: true},
        {Word: "RIGHT", Type: models.TokenTypeRight, Reserved: true, ReservedForTableAlias: true},
        {Word: "NATURAL", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "USING", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "CLUSTER", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "DISTRIBUTE", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "GLOBAL", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "ANTI", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "SEMI", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "RETURNING", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "ASOF", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "MATCH_CONDITION", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "OUTER", Type: models.TokenTypeOuter, Reserved: true, ReservedForTableAlias: true},
        {Word: "SET", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "QUALIFY", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "WINDOW", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "END", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "FOR", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "PARTITION", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "PREWHERE", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "SETTINGS", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "FORMAT", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "START", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "CONNECT", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "AND", Type: models.TokenTypeAnd, Reserved: true, ReservedForTableAlias: true},
        {Word: "LIKE", Type: models.TokenTypeLike, Reserved: true, ReservedForTableAlias: true},
        {Word: "ASC", Type: models.TokenTypeAsc, Reserved: true, ReservedForTableAlias: true},
        {Word: "MATCH_RECOGNIZE", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "SAMPLE", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "TABLESAMPLE", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "FROM", Type: models.TokenTypeFrom, Reserved: true, ReservedForTableAlias: true},
        {Word: "BY", Type: models.TokenTypeBy, Reserved: true, ReservedForTableAlias: true},
        {Word: "OR", Type: models.TokenTypeOr, Reserved: true, ReservedForTableAlias: true},
        {Word: "NOT", Type: models.TokenTypeNot, Reserved: true, ReservedForTableAlias: true},
        {Word: "IN", Type: models.TokenTypeIn, Reserved: true, ReservedForTableAlias: true},
        {Word: "COUNT", Type: models.TokenTypeCount, Reserved: true, ReservedForTableAlias: true},
        {Word: "SUM", Type: models.TokenTypeSum, Reserved: true, ReservedForTableAlias: true},
        {Word: "AVG", Type: models.TokenTypeAvg, Reserved: true, ReservedForTableAlias: true},
        {Word: "MIN", Type: models.TokenTypeMin, Reserved: true, ReservedForTableAlias: true},
        {Word: "MAX", Type: models.TokenTypeMax, Reserved: true, ReservedForTableAlias: true},
        // Window function keywords (Phase 2.5)
        {Word: "OVER", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "ROWS", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "RANGE", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "CURRENT", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "ROW", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "UNBOUNDED", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "PRECEDING", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
        {Word: "FOLLOWING", Type: models.TokenTypeKeyword, Reserved: true, ReservedForTableAlias: true},
}

var ADDITIONAL_KEYWORDS = []Keyword{
        {Word: "BETWEEN", Type: models.TokenTypeBetween, Reserved: true, ReservedForTableAlias: false},
        {Word: "IS", Type: models.TokenTypeIs, Reserved: true, ReservedForTableAlias: false},
        {Word: "NULL", Type: models.TokenTypeNull, Reserved: true, ReservedForTableAlias: false},
        {Word: "TRUE", Type: models.TokenTypeTrue, Reserved: true, ReservedForTableAlias: false},
        {Word: "FALSE", Type: models.TokenTypeFalse, Reserved: true, ReservedForTableAlias: false},
        {Word: "ASC", Type: models.TokenTypeAsc, Reserved: true, ReservedForTableAlias: false},
        {Word: "DESC", Type: models.TokenTypeDesc, Reserved: true, ReservedForTableAlias: false},
        {Word: "CASE", Type: models.TokenTypeCase, Reserved: true, ReservedForTableAlias: false},
        {Word: "WHEN", Type: models.TokenTypeWhen, Reserved: true, ReservedForTableAlias: false},
        {Word: "THEN", Type: models.TokenTypeThen, Reserved: true, ReservedForTableAlias: false},
        {Word: "ELSE", Type: models.TokenTypeElse, Reserved: true, ReservedForTableAlias: false},
        {Word: "END", Type: models.TokenTypeEnd, Reserved: true, ReservedForTableAlias: false},
        // Window function names (Phase 2.5)
        {Word: "ROW_NUMBER", Type: models.TokenTypeKeyword, Reserved: false, ReservedForTableAlias: false},
        {Word: "RANK", Type: models.TokenTypeKeyword, Reserved: false, ReservedForTableAlias: false},
        {Word: "DENSE_RANK", Type: models.TokenTypeKeyword, Reserved: false, ReservedForTableAlias: false},
        {Word: "NTILE", Type: models.TokenTypeKeyword, Reserved: false, ReservedForTableAlias: false},
        {Word: "LAG", Type: models.TokenTypeKeyword, Reserved: false, ReservedForTableAlias: false},
        {Word: "LEAD", Type: models.TokenTypeKeyword, Reserved: false, ReservedForTableAlias: false},
        {Word: "FIRST_VALUE", Type: models.TokenTypeKeyword, Reserved: false, ReservedForTableAlias: false},
        {Word: "LAST_VALUE", Type: models.TokenTypeKeyword, Reserved: false, ReservedForTableAlias: false},
}

// addKeywordsWithCategory is a helper method to add multiple keywords
// New creates a new Keywords instance with the specified dialect and case sensitivity
func New(dialect SQLDialect, ignoreCase bool) *Keywords <span class="cov8" title="1">{
        k := &amp;Keywords{
                reservedKeywords: make(map[string]bool),
                keywordMap:       make(map[string]Keyword),
                dialect:          dialect,
                ignoreCase:       true, // Always use case-insensitive comparison for SQL keywords
                CompoundKeywords: make(map[string]models.TokenType),
        }

        // Initialize compound keywords
        k.CompoundKeywords["GROUP BY"] = models.TokenTypeKeyword
        k.CompoundKeywords["ORDER BY"] = models.TokenTypeKeyword
        k.CompoundKeywords["LEFT JOIN"] = models.TokenTypeKeyword
        k.CompoundKeywords["FULL JOIN"] = models.TokenTypeKeyword
        k.CompoundKeywords["CROSS JOIN"] = models.TokenTypeKeyword
        k.CompoundKeywords["NATURAL JOIN"] = models.TokenTypeKeyword

        // Add standard keywords
        k.addKeywordsWithCategory(RESERVED_FOR_TABLE_ALIAS)
        k.addKeywordsWithCategory(ADDITIONAL_KEYWORDS)

        // Add dialect-specific keywords
        switch dialect </span>{
        case DialectMySQL:<span class="cov0" title="0">
                k.addKeywordsWithCategory(MYSQL_SPECIFIC)</span>
        case DialectPostgreSQL:<span class="cov0" title="0">
                k.addKeywordsWithCategory(POSTGRESQL_SPECIFIC)</span>
        case DialectSQLite:<span class="cov0" title="0">
                k.addKeywordsWithCategory(SQLITE_SPECIFIC)</span>
        }

        <span class="cov8" title="1">return k</span>
}

func (k *Keywords) addKeywordsWithCategory(keywords []Keyword) <span class="cov8" title="1">{
        for _, kw := range keywords </span><span class="cov8" title="1">{
                if !k.containsKeyword(kw.Word) </span><span class="cov8" title="1">{
                        if k.ignoreCase </span><span class="cov8" title="1">{
                                k.keywordMap[strings.ToUpper(kw.Word)] = kw
                                if kw.Reserved </span><span class="cov8" title="1">{
                                        k.reservedKeywords[strings.ToUpper(kw.Word)] = true
                                }</span>
                        } else<span class="cov0" title="0"> {
                                k.keywordMap[kw.Word] = kw
                                if kw.Reserved </span><span class="cov0" title="0">{
                                        k.reservedKeywords[kw.Word] = true
                                }</span>
                        }
                }
        }
}

// containsKeyword checks if a keyword already exists in the collection
func (k *Keywords) containsKeyword(word string) bool <span class="cov8" title="1">{
        if k.ignoreCase </span><span class="cov8" title="1">{
                _, exists := k.keywordMap[strings.ToUpper(word)]
                return exists
        }</span>
        <span class="cov0" title="0">_, exists := k.keywordMap[word]
        return exists</span>
}

// GetTokenType returns the token type for a given keyword
func (k *Keywords) GetTokenType(word string) models.TokenType <span class="cov8" title="1">{
        var key string
        if k.ignoreCase </span><span class="cov8" title="1">{
                key = strings.ToUpper(word)
        }</span> else<span class="cov0" title="0"> {
                key = word
        }</span>

        <span class="cov8" title="1">if kw, ok := k.keywordMap[key]; ok </span><span class="cov8" title="1">{
                return kw.Type
        }</span>
        <span class="cov8" title="1">return models.TokenTypeWord</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package keywords

import (
        "fmt"
        "log"
        "strings"
)

func (k *Keywords) AddKeyword(keyword Keyword) error <span class="cov0" title="0">{
        upperWord := strings.ToUpper(keyword.Word)
        if _, exists := k.keywordMap[upperWord]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("keyword '%s' already exists", keyword.Word)
        }</span>
        <span class="cov0" title="0">k.keywordMap[upperWord] = keyword
        if keyword.Reserved </span><span class="cov0" title="0">{
                k.reservedKeywords[upperWord] = true
        }</span>
        <span class="cov0" title="0">log.Printf("Added keyword: %s", keyword.Word)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package keywords

import "strings"

func (k *Keywords) GetKeyword(word string) (Keyword, bool) <span class="cov8" title="1">{
        keyword, ok := k.keywordMap[strings.ToUpper(word)]
        return keyword, ok
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package models

// TokenType represents different types of SQL tokens
type TokenType int

const (
        TokenTypeUnknown TokenType = iota

        // Basic token types
        TokenTypeIdentifier
        TokenTypeString
        TokenTypeOperator
        TokenTypeEquals
        TokenTypeLessThan
        TokenTypeGreaterThan
        TokenTypeLessEquals
        TokenTypeGreaterEquals
        TokenTypeNotEquals
        TokenTypeConcat
        TokenTypeCast
        TokenTypeDoubleArrow

        // Punctuation token types
        TokenTypeLeftParen
        TokenTypeRightParen
        TokenTypeLeftBracket
        TokenTypeRightBracket
        TokenTypeLeftBrace
        TokenTypeRightBrace
        TokenTypeDot

        // Join related token types
        TokenTypeFullJoin
        TokenTypeCrossJoin
        TokenTypeNaturalJoin
        TokenTypeUsing

        // DML related token types
        TokenTypeDistinct
        TokenTypeAll
        TokenTypeFetch
        TokenTypeNext
        TokenTypeRows
        TokenTypeOnly
        TokenTypeWith
        TokenTypeTies
        TokenTypeNulls
        TokenTypeFirst
        TokenTypeLast
)

// String returns the string representation of the token type
func (t TokenType) String() string <span class="cov0" title="0">{
        switch t </span>{
        case TokenTypeFullJoin:<span class="cov0" title="0">
                return "FULL JOIN"</span>
        case TokenTypeCrossJoin:<span class="cov0" title="0">
                return "CROSS JOIN"</span>
        case TokenTypeNaturalJoin:<span class="cov0" title="0">
                return "NATURAL JOIN"</span>
        case TokenTypeDistinct:<span class="cov0" title="0">
                return "DISTINCT"</span>
        case TokenTypeAll:<span class="cov0" title="0">
                return "ALL"</span>
        case TokenTypeFetch:<span class="cov0" title="0">
                return "FETCH"</span>
        case TokenTypeNext:<span class="cov0" title="0">
                return "NEXT"</span>
        case TokenTypeRows:<span class="cov0" title="0">
                return "ROWS"</span>
        case TokenTypeOnly:<span class="cov0" title="0">
                return "ONLY"</span>
        case TokenTypeWith:<span class="cov0" title="0">
                return "WITH"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// Package monitor provides performance monitoring and metrics collection for GoSQLX
package monitor

import (
        "sync"
        "sync/atomic"
        "time"
)

// MetricsSnapshot represents a snapshot of metrics without internal locks
type MetricsSnapshot struct {
        // Tokenizer metrics
        TokenizerCalls    int64
        TokenizerDuration time.Duration
        TokensProcessed   int64
        TokenizerErrors   int64

        // Parser metrics
        ParserCalls         int64
        ParserDuration      time.Duration
        StatementsProcessed int64
        ParserErrors        int64

        // Pool metrics
        PoolHits   int64
        PoolMisses int64
        PoolReuse  float64

        // Memory metrics
        AllocBytes  uint64
        TotalAllocs uint64
        LastGCPause time.Duration

        StartTime time.Time
}

// Metrics holds performance metrics for the tokenizer and parser
type Metrics struct {
        mu sync.RWMutex

        // Tokenizer metrics
        TokenizerCalls    int64
        TokenizerDuration time.Duration
        TokensProcessed   int64
        TokenizerErrors   int64

        // Parser metrics
        ParserCalls         int64
        ParserDuration      time.Duration
        StatementsProcessed int64
        ParserErrors        int64

        // Pool metrics
        PoolHits   int64
        PoolMisses int64
        PoolReuse  float64

        // Memory metrics
        AllocBytes  uint64
        TotalAllocs uint64
        LastGCPause time.Duration

        startTime time.Time
}

var (
        globalMetrics = &amp;Metrics{
                startTime: time.Now(),
        }
        enabled atomic.Bool
)

// Enable turns on metrics collection
func Enable() <span class="cov8" title="1">{
        enabled.Store(true)
}</span>

// Disable turns off metrics collection
func Disable() <span class="cov8" title="1">{
        enabled.Store(false)
}</span>

// IsEnabled returns whether metrics collection is enabled
func IsEnabled() bool <span class="cov8" title="1">{
        return enabled.Load()
}</span>

// RecordTokenizerCall records a tokenizer operation
func RecordTokenizerCall(duration time.Duration, tokens int, err error) <span class="cov8" title="1">{
        if !IsEnabled() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">atomic.AddInt64(&amp;globalMetrics.TokenizerCalls, 1)
        atomic.AddInt64(&amp;globalMetrics.TokensProcessed, int64(tokens))

        globalMetrics.mu.Lock()
        globalMetrics.TokenizerDuration += duration
        globalMetrics.mu.Unlock()

        if err != nil </span><span class="cov8" title="1">{
                atomic.AddInt64(&amp;globalMetrics.TokenizerErrors, 1)
        }</span>
}

// RecordParserCall records a parser operation
func RecordParserCall(duration time.Duration, err error) <span class="cov8" title="1">{
        if !IsEnabled() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">atomic.AddInt64(&amp;globalMetrics.ParserCalls, 1)

        globalMetrics.mu.Lock()
        globalMetrics.ParserDuration += duration
        globalMetrics.mu.Unlock()

        if err != nil </span><span class="cov8" title="1">{
                atomic.AddInt64(&amp;globalMetrics.ParserErrors, 1)
        }</span> else<span class="cov8" title="1"> {
                atomic.AddInt64(&amp;globalMetrics.StatementsProcessed, 1)
        }</span>
}

// RecordPoolHit records a successful pool retrieval
func RecordPoolHit() <span class="cov8" title="1">{
        if !IsEnabled() </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">atomic.AddInt64(&amp;globalMetrics.PoolHits, 1)</span>
}

// RecordPoolMiss records a pool miss (new allocation)
func RecordPoolMiss() <span class="cov8" title="1">{
        if !IsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">atomic.AddInt64(&amp;globalMetrics.PoolMisses, 1)</span>
}

// GetMetrics returns a copy of current metrics
func GetMetrics() MetricsSnapshot <span class="cov8" title="1">{
        globalMetrics.mu.RLock()
        defer globalMetrics.mu.RUnlock()

        m := MetricsSnapshot{
                TokenizerCalls:      atomic.LoadInt64(&amp;globalMetrics.TokenizerCalls),
                TokenizerDuration:   globalMetrics.TokenizerDuration,
                TokensProcessed:     atomic.LoadInt64(&amp;globalMetrics.TokensProcessed),
                TokenizerErrors:     atomic.LoadInt64(&amp;globalMetrics.TokenizerErrors),
                ParserCalls:         atomic.LoadInt64(&amp;globalMetrics.ParserCalls),
                ParserDuration:      globalMetrics.ParserDuration,
                StatementsProcessed: atomic.LoadInt64(&amp;globalMetrics.StatementsProcessed),
                ParserErrors:        atomic.LoadInt64(&amp;globalMetrics.ParserErrors),
                PoolHits:            atomic.LoadInt64(&amp;globalMetrics.PoolHits),
                PoolMisses:          atomic.LoadInt64(&amp;globalMetrics.PoolMisses),
                AllocBytes:          globalMetrics.AllocBytes,
                TotalAllocs:         globalMetrics.TotalAllocs,
                LastGCPause:         globalMetrics.LastGCPause,
                StartTime:           globalMetrics.startTime,
        }

        // Calculate pool reuse rate
        total := m.PoolHits + m.PoolMisses
        if total &gt; 0 </span><span class="cov8" title="1">{
                m.PoolReuse = float64(m.PoolHits) / float64(total) * 100
        }</span>

        <span class="cov8" title="1">return m</span>
}

// Reset clears all metrics
func Reset() <span class="cov8" title="1">{
        globalMetrics.mu.Lock()
        defer globalMetrics.mu.Unlock()

        // Reset individual fields without overwriting the mutex
        // Use atomic stores for fields that are accessed atomically elsewhere
        atomic.StoreInt64(&amp;globalMetrics.TokenizerCalls, 0)
        globalMetrics.TokenizerDuration = 0
        atomic.StoreInt64(&amp;globalMetrics.TokensProcessed, 0)
        atomic.StoreInt64(&amp;globalMetrics.TokenizerErrors, 0)
        atomic.StoreInt64(&amp;globalMetrics.ParserCalls, 0)
        globalMetrics.ParserDuration = 0
        atomic.StoreInt64(&amp;globalMetrics.StatementsProcessed, 0)
        atomic.StoreInt64(&amp;globalMetrics.ParserErrors, 0)
        atomic.StoreInt64(&amp;globalMetrics.PoolHits, 0)
        atomic.StoreInt64(&amp;globalMetrics.PoolMisses, 0)
        globalMetrics.PoolReuse = 0
        globalMetrics.AllocBytes = 0
        globalMetrics.TotalAllocs = 0
        globalMetrics.LastGCPause = 0
        globalMetrics.startTime = time.Now()
}</span>

// Uptime returns the duration since metrics were started or reset
func Uptime() time.Duration <span class="cov8" title="1">{
        globalMetrics.mu.RLock()
        defer globalMetrics.mu.RUnlock()
        return time.Since(globalMetrics.startTime)
}</span>

// Summary returns a performance summary
type Summary struct {
        Uptime              time.Duration
        TotalOperations     int64
        OperationsPerSecond float64
        TokensPerSecond     float64
        AvgTokenizerLatency time.Duration
        AvgParserLatency    time.Duration
        ErrorRate           float64
        PoolEfficiency      float64
}

// GetSummary returns a performance summary
func GetSummary() Summary <span class="cov8" title="1">{
        m := GetMetrics()
        uptime := Uptime()
        uptimeSeconds := uptime.Seconds()

        s := Summary{
                Uptime:          uptime,
                TotalOperations: m.TokenizerCalls + m.ParserCalls,
                PoolEfficiency:  m.PoolReuse,
        }

        if uptimeSeconds &gt; 0 </span><span class="cov8" title="1">{
                s.OperationsPerSecond = float64(s.TotalOperations) / uptimeSeconds
                s.TokensPerSecond = float64(m.TokensProcessed) / uptimeSeconds
        }</span>

        <span class="cov8" title="1">if m.TokenizerCalls &gt; 0 </span><span class="cov8" title="1">{
                s.AvgTokenizerLatency = m.TokenizerDuration / time.Duration(m.TokenizerCalls)
        }</span>

        <span class="cov8" title="1">if m.ParserCalls &gt; 0 </span><span class="cov8" title="1">{
                s.AvgParserLatency = m.ParserDuration / time.Duration(m.ParserCalls)
        }</span>

        <span class="cov8" title="1">totalCalls := m.TokenizerCalls + m.ParserCalls
        if totalCalls &gt; 0 </span><span class="cov8" title="1">{
                totalErrors := m.TokenizerErrors + m.ParserErrors
                s.ErrorRate = float64(totalErrors) / float64(totalCalls) * 100
        }</span>

        <span class="cov8" title="1">return s</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package parser

import (
        "github.com/ajitpratap0/GoSQLX/pkg/sql/ast"
        "github.com/ajitpratap0/GoSQLX/pkg/sql/token"
)

// parseAlterStatement parses ALTER statements
func (p *Parser) parseAlterStatement() (*ast.AlterStatement, error) <span class="cov0" title="0">{
        stmt := &amp;ast.AlterStatement{}

        // Parse the type of object being altered
        switch </span>{
        case p.matchToken(token.TABLE):<span class="cov0" title="0">
                stmt.Type = ast.AlterTypeTable
                return p.parseAlterTableStatement(stmt)</span>
        case p.matchToken(token.ROLE):<span class="cov0" title="0">
                stmt.Type = ast.AlterTypeRole
                return p.parseAlterRoleStatement(stmt)</span>
        case p.matchToken(token.POLICY):<span class="cov0" title="0">
                stmt.Type = ast.AlterTypePolicy
                return p.parseAlterPolicyStatement(stmt)</span>
        case p.matchToken(token.CONNECTOR):<span class="cov0" title="0">
                stmt.Type = ast.AlterTypeConnector
                return p.parseAlterConnectorStatement(stmt)</span>
        default:<span class="cov0" title="0">
                return nil, p.expectedError("TABLE, ROLE, POLICY, or CONNECTOR")</span>
        }
}

// parseAlterTableStatement parses ALTER TABLE statements
func (p *Parser) parseAlterTableStatement(stmt *ast.AlterStatement) (*ast.AlterStatement, error) <span class="cov0" title="0">{
        stmt.Name = p.parseIdentAsString()
        op := &amp;ast.AlterTableOperation{}

        switch </span>{
        case p.matchToken(token.ADD):<span class="cov0" title="0">
                if p.matchToken(token.COLUMN) </span><span class="cov0" title="0">{
                        op.Type = ast.AddColumn
                        colDef, err := p.parseColumnDef()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">op.ColumnDef = colDef</span>
                } else<span class="cov0" title="0"> if p.matchToken(token.CONSTRAINT) </span><span class="cov0" title="0">{
                        op.Type = ast.AddConstraint
                        constraint, err := p.parseTableConstraint()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">op.Constraint = constraint</span>
                } else<span class="cov0" title="0"> {
                        return nil, p.expectedError("COLUMN or CONSTRAINT")
                }</span>

        case p.matchToken(token.DROP):<span class="cov0" title="0">
                if p.matchToken(token.COLUMN) </span><span class="cov0" title="0">{
                        op.Type = ast.DropColumn
                        // Convert ast.Identifier to ast.Ident
                        ident := p.parseIdent()
                        op.ColumnName = &amp;ast.Ident{Name: ident.Name}
                        if p.matchToken(token.CASCADE) </span><span class="cov0" title="0">{
                                op.CascadeDrops = true
                        }</span>
                } else<span class="cov0" title="0"> if p.matchToken(token.CONSTRAINT) </span><span class="cov0" title="0">{
                        op.Type = ast.DropConstraint
                        // Convert ast.Identifier to ast.Ident
                        ident := p.parseIdent()
                        op.ConstraintName = &amp;ast.Ident{Name: ident.Name}
                        if p.matchToken(token.CASCADE) </span><span class="cov0" title="0">{
                                op.CascadeDrops = true
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, p.expectedError("COLUMN or CONSTRAINT")
                }</span>

        case p.matchToken(token.RENAME):<span class="cov0" title="0">
                if p.matchToken(token.TO) </span><span class="cov0" title="0">{
                        op.Type = ast.RenameTable
                        op.NewTableName = p.parseObjectName()
                }</span> else<span class="cov0" title="0"> if p.matchToken(token.COLUMN) </span><span class="cov0" title="0">{
                        op.Type = ast.RenameColumn
                        // Convert ast.Identifier to ast.Ident
                        ident := p.parseIdent()
                        op.ColumnName = &amp;ast.Ident{Name: ident.Name}
                        if !p.matchToken(token.TO) </span><span class="cov0" title="0">{
                                return nil, p.expectedError("TO")
                        }</span>
                        // Convert ast.Identifier to ast.Ident
                        <span class="cov0" title="0">newIdent := p.parseIdent()
                        op.NewColumnName = &amp;ast.Ident{Name: newIdent.Name}</span>
                } else<span class="cov0" title="0"> {
                        return nil, p.expectedError("TO or COLUMN")
                }</span>

        case p.matchToken(token.ALTER):<span class="cov0" title="0">
                if !p.matchToken(token.COLUMN) </span><span class="cov0" title="0">{
                        return nil, p.expectedError("COLUMN")
                }</span>
                <span class="cov0" title="0">op.Type = ast.AlterColumn
                // Convert ast.Identifier to ast.Ident
                ident := p.parseIdent()
                op.ColumnName = &amp;ast.Ident{Name: ident.Name}
                colDef, err := p.parseColumnDef()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">op.ColumnDef = colDef</span>

        default:<span class="cov0" title="0">
                return nil, p.expectedError("ADD, DROP, RENAME, or ALTER")</span>
        }

        <span class="cov0" title="0">stmt.Operation = op
        return stmt, nil</span>
}

// parseAlterRoleStatement parses ALTER ROLE statements
func (p *Parser) parseAlterRoleStatement(stmt *ast.AlterStatement) (*ast.AlterStatement, error) <span class="cov0" title="0">{
        stmt.Name = p.parseIdentAsString()
        op := &amp;ast.AlterRoleOperation{}

        switch </span>{
        case p.matchToken(token.RENAME):<span class="cov0" title="0">
                if !p.matchToken(token.TO) </span><span class="cov0" title="0">{
                        return nil, p.expectedError("TO")
                }</span>
                <span class="cov0" title="0">op.Type = ast.RenameRole
                op.NewName = p.parseIdentAsString()</span>

        case p.matchToken(token.ADD):<span class="cov0" title="0">
                if !p.matchToken(token.MEMBER) </span><span class="cov0" title="0">{
                        return nil, p.expectedError("MEMBER")
                }</span>
                <span class="cov0" title="0">op.Type = ast.AddMember
                op.MemberName = p.parseIdentAsString()</span>

        case p.matchToken(token.DROP):<span class="cov0" title="0">
                if !p.matchToken(token.MEMBER) </span><span class="cov0" title="0">{
                        return nil, p.expectedError("MEMBER")
                }</span>
                <span class="cov0" title="0">op.Type = ast.DropMember
                op.MemberName = p.parseIdentAsString()</span>

        case p.matchToken(token.SET):<span class="cov0" title="0">
                op.Type = ast.SetConfig
                op.ConfigName = p.parseIdentAsString()
                if p.matchToken(token.TO) || p.matchToken(token.EQUAL) </span><span class="cov0" title="0">{
                        expr, err := p.parseExpression()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">op.ConfigValue = expr</span>
                }

        case p.matchToken(token.RESET):<span class="cov0" title="0">
                op.Type = ast.ResetConfig
                if p.matchToken(token.ALL) </span><span class="cov0" title="0">{
                        op.ConfigName = "ALL"
                }</span> else<span class="cov0" title="0"> {
                        op.ConfigName = p.parseIdentAsString()
                }</span>

        case p.matchToken(token.WITH):<span class="cov0" title="0">
                op.Type = ast.WithOptions
                for </span><span class="cov0" title="0">{
                        option, err := p.parseRoleOption()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">op.Options = append(op.Options, *option)
                        if !p.matchToken(token.COMMA) </span><span class="cov0" title="0">{
                                break</span>
                        }
                }

        default:<span class="cov0" title="0">
                return nil, p.expectedError("RENAME, ADD MEMBER, DROP MEMBER, SET, RESET, or WITH")</span>
        }

        <span class="cov0" title="0">stmt.Operation = op
        return stmt, nil</span>
}

// parseAlterPolicyStatement parses ALTER POLICY statements
func (p *Parser) parseAlterPolicyStatement(stmt *ast.AlterStatement) (*ast.AlterStatement, error) <span class="cov0" title="0">{
        stmt.Name = p.parseIdentAsString()
        if !p.matchToken(token.ON) </span><span class="cov0" title="0">{
                return nil, p.expectedError("ON")
        }</span>
        <span class="cov0" title="0">p.parseIdentAsString() // table name

        op := &amp;ast.AlterPolicyOperation{}

        if p.matchToken(token.RENAME) </span><span class="cov0" title="0">{
                if !p.matchToken(token.TO) </span><span class="cov0" title="0">{
                        return nil, p.expectedError("TO")
                }</span>
                <span class="cov0" title="0">op.Type = ast.RenamePolicy
                op.NewName = p.parseIdentAsString()</span>
        } else<span class="cov0" title="0"> {
                op.Type = ast.ModifyPolicy
                if p.matchToken(token.TO) </span><span class="cov0" title="0">{
                        for </span><span class="cov0" title="0">{
                                op.To = append(op.To, p.parseIdentAsString())
                                if !p.matchToken(token.COMMA) </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                }
                <span class="cov0" title="0">if p.matchToken(token.USING) </span><span class="cov0" title="0">{
                        if !p.matchToken(token.LPAREN) </span><span class="cov0" title="0">{
                                return nil, p.expectedError("(")
                        }</span>
                        <span class="cov0" title="0">expr, err := p.parseExpression()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">op.Using = expr
                        if !p.matchToken(token.RPAREN) </span><span class="cov0" title="0">{
                                return nil, p.expectedError(")")
                        }</span>
                }
                <span class="cov0" title="0">if p.matchToken(token.WITH) &amp;&amp; p.matchToken(token.CHECK) </span><span class="cov0" title="0">{
                        if !p.matchToken(token.LPAREN) </span><span class="cov0" title="0">{
                                return nil, p.expectedError("(")
                        }</span>
                        <span class="cov0" title="0">expr, err := p.parseExpression()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">op.WithCheck = expr
                        if !p.matchToken(token.RPAREN) </span><span class="cov0" title="0">{
                                return nil, p.expectedError(")")
                        }</span>
                }
        }

        <span class="cov0" title="0">stmt.Operation = op
        return stmt, nil</span>
}

// parseAlterConnectorStatement parses ALTER CONNECTOR statements
func (p *Parser) parseAlterConnectorStatement(stmt *ast.AlterStatement) (*ast.AlterStatement, error) <span class="cov0" title="0">{
        stmt.Name = p.parseIdentAsString()
        if !p.matchToken(token.SET) </span><span class="cov0" title="0">{
                return nil, p.expectedError("SET")
        }</span>

        <span class="cov0" title="0">op := &amp;ast.AlterConnectorOperation{}

        switch </span>{
        case p.matchToken(token.DCPROPERTIES):<span class="cov0" title="0">
                if !p.matchToken(token.LPAREN) </span><span class="cov0" title="0">{
                        return nil, p.expectedError("(")
                }</span>
                <span class="cov0" title="0">op.Properties = make(map[string]string)
                for </span><span class="cov0" title="0">{
                        key := p.parseIdentAsString()
                        if !p.matchToken(token.EQUAL) </span><span class="cov0" title="0">{
                                return nil, p.expectedError("=")
                        }</span>
                        <span class="cov0" title="0">value := p.parseStringLiteral()
                        op.Properties[key] = value

                        if !p.matchToken(token.COMMA) </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !p.matchToken(token.RPAREN) </span><span class="cov0" title="0">{
                        return nil, p.expectedError(")")
                }</span>

        case p.matchToken(token.URL):<span class="cov0" title="0">
                op.URL = p.parseStringLiteral()</span>

        case p.matchToken(token.OWNER):<span class="cov0" title="0">
                owner := &amp;ast.AlterConnectorOwner{}
                if p.matchToken(token.USER) </span><span class="cov0" title="0">{
                        owner.IsUser = true
                }</span> else<span class="cov0" title="0"> if p.matchToken(token.ROLE) </span><span class="cov0" title="0">{
                        owner.IsUser = false
                }</span> else<span class="cov0" title="0"> {
                        return nil, p.expectedError("USER or ROLE")
                }</span>
                <span class="cov0" title="0">owner.Name = p.parseIdentAsString()
                op.Owner = owner</span>

        default:<span class="cov0" title="0">
                return nil, p.expectedError("DCPROPERTIES, URL, or OWNER")</span>
        }

        <span class="cov0" title="0">stmt.Operation = op
        return stmt, nil</span>
}

// parseRoleOption parses a role option
func (p *Parser) parseRoleOption() (*ast.RoleOption, error) <span class="cov0" title="0">{
        option := &amp;ast.RoleOption{}

        switch </span>{
        case p.matchToken(token.SUPERUSER), p.matchToken(token.NOSUPERUSER):<span class="cov0" title="0">
                option.Name = "SUPERUSER"
                option.Type = ast.SuperUser
                option.Value = p.currentToken.Type == token.SUPERUSER</span>

        case p.matchToken(token.CREATEDB), p.matchToken(token.NOCREATEDB):<span class="cov0" title="0">
                option.Name = "CREATEDB"
                option.Type = ast.CreateDB
                option.Value = p.currentToken.Type == token.CREATEDB</span>

        case p.matchToken(token.CREATEROLE), p.matchToken(token.NOCREATEROLE):<span class="cov0" title="0">
                option.Name = "CREATEROLE"
                option.Type = ast.CreateRole
                option.Value = p.currentToken.Type == token.CREATEROLE</span>

        case p.matchToken(token.LOGIN), p.matchToken(token.NOLOGIN):<span class="cov0" title="0">
                option.Name = "LOGIN"
                option.Type = ast.Login
                option.Value = p.currentToken.Type == token.LOGIN</span>

        case p.matchToken(token.PASSWORD):<span class="cov0" title="0">
                option.Name = "PASSWORD"
                option.Type = ast.Password
                if p.matchToken(token.NULL) </span><span class="cov0" title="0">{
                        option.Value = nil
                }</span> else<span class="cov0" title="0"> {
                        expr, err := p.parseExpression()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">option.Value = expr</span>
                }

        case p.matchToken(token.VALID):<span class="cov0" title="0">
                option.Name = "VALID"
                option.Type = ast.ValidUntil
                if !p.matchToken(token.UNTIL) </span><span class="cov0" title="0">{
                        return nil, p.expectedError("UNTIL")
                }</span>
                <span class="cov0" title="0">expr, err := p.parseExpression()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">option.Value = expr</span>

        default:<span class="cov0" title="0">
                return nil, p.expectedError("role option")</span>
        }

        <span class="cov0" title="0">return option, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Package parser provides a recursive descent SQL parser that converts tokens into an Abstract Syntax Tree (AST).
// It supports comprehensive SQL features including SELECT, INSERT, UPDATE, DELETE, DDL operations,
// Common Table Expressions (CTEs), set operations (UNION, EXCEPT, INTERSECT), and window functions.
//
// Phase 2 Features (v1.2.0+):
//   - Common Table Expressions (WITH clause) with recursive support
//   - Set operations: UNION, UNION ALL, EXCEPT, INTERSECT
//   - Multiple CTE definitions in single query
//   - CTE column specifications
//   - Left-associative set operation parsing
//   - Integration of CTEs with set operations
//
// Phase 2.5 Features (v1.3.0+):
//   - Window functions with OVER clause support
//   - PARTITION BY and ORDER BY in window specifications
//   - Window frame clauses (ROWS/RANGE with bounds)
//   - Ranking functions: ROW_NUMBER(), RANK(), DENSE_RANK(), NTILE()
//   - Analytic functions: LAG(), LEAD(), FIRST_VALUE(), LAST_VALUE()
//   - Function call parsing with parentheses and arguments
//   - Integration with existing SELECT statement parsing
package parser

import (
        "fmt"

        "github.com/ajitpratap0/GoSQLX/pkg/sql/ast"
        "github.com/ajitpratap0/GoSQLX/pkg/sql/token"
)

// Parser represents a SQL parser
type Parser struct {
        tokens       []token.Token
        currentPos   int
        currentToken token.Token
}

// Parse parses the tokens into an AST
func (p *Parser) Parse(tokens []token.Token) (*ast.AST, error) <span class="cov8" title="1">{
        p.tokens = tokens
        p.currentPos = 0
        if len(tokens) &gt; 0 </span><span class="cov8" title="1">{
                p.currentToken = tokens[0]
        }</span>

        // Get a pre-allocated AST from the pool
        <span class="cov8" title="1">result := ast.NewAST()

        // Pre-allocate statements slice based on a reasonable estimate
        estimatedStmts := 1 // Most SQL queries have just one statement
        if len(tokens) &gt; 100 </span><span class="cov0" title="0">{
                estimatedStmts = 2 // For larger inputs, allocate more
        }</span>
        <span class="cov8" title="1">result.Statements = make([]ast.Statement, 0, estimatedStmts)

        // Parse statements
        for p.currentPos &lt; len(tokens) &amp;&amp; p.currentToken.Type != "EOF" </span><span class="cov8" title="1">{
                stmt, err := p.parseStatement()
                if err != nil </span><span class="cov8" title="1">{
                        // Clean up the AST on error
                        ast.ReleaseAST(result)
                        return nil, err
                }</span>
                <span class="cov8" title="1">result.Statements = append(result.Statements, stmt)</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// Release releases any resources held by the parser
func (p *Parser) Release() <span class="cov8" title="1">{
        // Reset internal state to avoid memory leaks
        p.tokens = nil
        p.currentPos = 0
        p.currentToken = token.Token{}
}</span>

// parseStatement parses a single SQL statement
func (p *Parser) parseStatement() (ast.Statement, error) <span class="cov8" title="1">{
        switch p.currentToken.Type </span>{
        case "WITH":<span class="cov8" title="1">
                return p.parseWithStatement()</span>
        case "SELECT":<span class="cov8" title="1">
                p.advance() // Consume SELECT
                return p.parseSelectWithSetOperations()</span>
        case "INSERT":<span class="cov8" title="1">
                p.advance() // Consume INSERT
                return p.parseInsertStatement()</span>
        case "UPDATE":<span class="cov8" title="1">
                p.advance() // Consume UPDATE
                return p.parseUpdateStatement()</span>
        case "DELETE":<span class="cov8" title="1">
                p.advance() // Consume DELETE
                return p.parseDeleteStatement()</span>
        case "ALTER":<span class="cov0" title="0">
                p.advance() // Consume ALTER
                return p.parseAlterTableStmt()</span>
        default:<span class="cov8" title="1">
                return nil, p.expectedError("statement")</span>
        }
}

// NewParser creates a new parser
func NewParser() *Parser <span class="cov8" title="1">{
        return &amp;Parser{}
}</span>

// matchToken checks if the current token matches the expected type
func (p *Parser) matchToken(expected token.Type) bool <span class="cov0" title="0">{
        // Convert both to strings for comparison
        expectedStr := string(expected)
        currentStr := string(p.currentToken.Type)
        if currentStr == expectedStr </span><span class="cov0" title="0">{
                p.advance()
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

// advance moves to the next token
func (p *Parser) advance() <span class="cov8" title="1">{
        p.currentPos++
        if p.currentPos &lt; len(p.tokens) </span><span class="cov8" title="1">{
                p.currentToken = p.tokens[p.currentPos]
        }</span>
}

// expectedError returns an error for unexpected token
func (p *Parser) expectedError(expected string) error <span class="cov8" title="1">{
        return fmt.Errorf("expected %s, got %s", expected, p.currentToken.Type)
}</span>

// parseIdent parses an identifier
func (p *Parser) parseIdent() *ast.Identifier <span class="cov0" title="0">{
        if p.currentToken.Type != token.IDENT &amp;&amp; p.currentToken.Type != "IDENT" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">ident := &amp;ast.Identifier{Name: p.currentToken.Literal}
        p.advance()
        return ident</span>
}

// parseIdentAsString parses an identifier and returns its name as a string
func (p *Parser) parseIdentAsString() string <span class="cov0" title="0">{
        ident := p.parseIdent()
        if ident == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return ident.Name</span>
}

// parseObjectName parses an object name (possibly qualified)
func (p *Parser) parseObjectName() ast.ObjectName <span class="cov0" title="0">{
        ident := p.parseIdent()
        if ident == nil </span><span class="cov0" title="0">{
                return ast.ObjectName{}
        }</span>
        <span class="cov0" title="0">return ast.ObjectName{Name: ident.Name}</span>
}

// parseStringLiteral parses a string literal
func (p *Parser) parseStringLiteral() string <span class="cov0" title="0">{
        if p.currentToken.Type != token.STRING &amp;&amp; p.currentToken.Type != "STRING" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">value := p.currentToken.Literal
        p.advance()
        return value</span>
}

// parseExpression parses an expression
func (p *Parser) parseExpression() (ast.Expression, error) <span class="cov8" title="1">{
        // Parse the left side of the expression
        var left ast.Expression

        switch p.currentToken.Type </span>{
        case "IDENT":<span class="cov8" title="1">
                // Handle identifiers and function calls
                identName := p.currentToken.Literal
                p.advance()

                // Check for function call (identifier followed by parentheses)
                if p.currentToken.Type == "(" </span><span class="cov8" title="1">{
                        // This is a function call
                        funcCall, err := p.parseFunctionCall(identName)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">left = funcCall</span>
                } else<span class="cov8" title="1"> {
                        // Handle regular identifier or qualified identifier (table.column)
                        ident := &amp;ast.Identifier{Name: identName}

                        // Check for qualified identifier (table.column)
                        if p.currentToken.Type == "." </span><span class="cov8" title="1">{
                                p.advance() // Consume .
                                if p.currentToken.Type != "IDENT" </span><span class="cov0" title="0">{
                                        return nil, p.expectedError("identifier after .")
                                }</span>
                                // Create a qualified identifier
                                <span class="cov8" title="1">ident = &amp;ast.Identifier{
                                        Table: ident.Name,
                                        Name:  p.currentToken.Literal,
                                }
                                p.advance()</span>
                        }

                        <span class="cov8" title="1">left = ident</span>
                }

        case "STRING":<span class="cov8" title="1">
                // Handle string literals
                left = &amp;ast.LiteralValue{Value: p.currentToken.Literal, Type: "string"}
                p.advance()</span>

        case "INT":<span class="cov8" title="1">
                // Handle integer literals
                left = &amp;ast.LiteralValue{Value: p.currentToken.Literal, Type: "int"}
                p.advance()</span>

        case "FLOAT":<span class="cov0" title="0">
                // Handle float literals
                left = &amp;ast.LiteralValue{Value: p.currentToken.Literal, Type: "float"}
                p.advance()</span>

        case "TRUE", "FALSE":<span class="cov8" title="1">
                // Handle boolean literals
                left = &amp;ast.LiteralValue{Value: p.currentToken.Literal, Type: "bool"}
                p.advance()</span>

        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unexpected token: %s", p.currentToken.Type)</span>
        }

        // Check if this is a binary expression
        <span class="cov8" title="1">if p.currentToken.Type == "=" || p.currentToken.Type == "&lt;" ||
                p.currentToken.Type == "&gt;" || p.currentToken.Type == "!=" </span><span class="cov8" title="1">{
                // Save the operator
                operator := p.currentToken.Literal
                p.advance()

                // Parse the right side of the expression
                right, err := p.parseExpression()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Create a binary expression
                <span class="cov8" title="1">return &amp;ast.BinaryExpression{
                        Left:     left,
                        Operator: operator,
                        Right:    right,
                }, nil</span>
        }

        <span class="cov8" title="1">return left, nil</span>
}

// parseFunctionCall parses a function call with optional OVER clause for window functions.
//
// Examples:
//
//        COUNT(*) -&gt; regular aggregate function
//        ROW_NUMBER() OVER (ORDER BY id) -&gt; window function with OVER clause
//        SUM(salary) OVER (PARTITION BY dept ORDER BY date ROWS UNBOUNDED PRECEDING) -&gt; window function with frame
func (p *Parser) parseFunctionCall(funcName string) (*ast.FunctionCall, error) <span class="cov8" title="1">{
        // Expect opening parenthesis
        if p.currentToken.Type != "(" </span><span class="cov0" title="0">{
                return nil, p.expectedError("(")
        }</span>
        <span class="cov8" title="1">p.advance() // Consume (

        // Parse function arguments
        var arguments []ast.Expression
        var distinct bool

        // Check for DISTINCT keyword
        if p.currentToken.Type == "DISTINCT" </span><span class="cov0" title="0">{
                distinct = true
                p.advance()
        }</span>

        // Parse arguments if not empty
        <span class="cov8" title="1">if p.currentToken.Type != ")" </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        arg, err := p.parseExpression()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">arguments = append(arguments, arg)

                        // Check for comma or end of arguments
                        if p.currentToken.Type == "," </span><span class="cov8" title="1">{
                                p.advance() // Consume comma
                        }</span> else<span class="cov8" title="1"> if p.currentToken.Type == ")" </span><span class="cov8" title="1">{
                                break</span>
                        } else<span class="cov0" title="0"> {
                                return nil, p.expectedError(", or )")
                        }</span>
                }
        }

        // Expect closing parenthesis
        <span class="cov8" title="1">if p.currentToken.Type != ")" </span><span class="cov0" title="0">{
                return nil, p.expectedError(")")
        }</span>
        <span class="cov8" title="1">p.advance() // Consume )

        // Create function call
        funcCall := &amp;ast.FunctionCall{
                Name:      funcName,
                Arguments: arguments,
                Distinct:  distinct,
        }

        // Check for OVER clause (window function)
        if p.currentToken.Type == "OVER" </span><span class="cov8" title="1">{
                p.advance() // Consume OVER

                windowSpec, err := p.parseWindowSpec()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">funcCall.Over = windowSpec</span>
        }

        <span class="cov8" title="1">return funcCall, nil</span>
}

// parseWindowSpec parses a window specification (PARTITION BY, ORDER BY, frame clause)
func (p *Parser) parseWindowSpec() (*ast.WindowSpec, error) <span class="cov8" title="1">{
        // Expect opening parenthesis
        if p.currentToken.Type != "(" </span><span class="cov0" title="0">{
                return nil, p.expectedError("(")
        }</span>
        <span class="cov8" title="1">p.advance() // Consume (

        windowSpec := &amp;ast.WindowSpec{}

        // Parse PARTITION BY clause
        if p.currentToken.Type == "PARTITION" </span><span class="cov8" title="1">{
                p.advance() // Consume PARTITION
                if p.currentToken.Type != "BY" </span><span class="cov0" title="0">{
                        return nil, p.expectedError("BY after PARTITION")
                }</span>
                <span class="cov8" title="1">p.advance() // Consume BY

                // Parse partition expressions
                for </span><span class="cov8" title="1">{
                        expr, err := p.parseExpression()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">windowSpec.PartitionBy = append(windowSpec.PartitionBy, expr)

                        if p.currentToken.Type == "," </span><span class="cov0" title="0">{
                                p.advance() // Consume comma
                        }</span> else<span class="cov8" title="1"> {
                                break</span>
                        }
                }
        }

        // Parse ORDER BY clause
        <span class="cov8" title="1">if p.currentToken.Type == "ORDER" </span><span class="cov8" title="1">{
                p.advance() // Consume ORDER
                if p.currentToken.Type != "BY" </span><span class="cov0" title="0">{
                        return nil, p.expectedError("BY after ORDER")
                }</span>
                <span class="cov8" title="1">p.advance() // Consume BY

                // Parse order expressions
                for </span><span class="cov8" title="1">{
                        expr, err := p.parseExpression()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        // Check for ASC/DESC after the expression
                        <span class="cov8" title="1">if p.currentToken.Type == "ASC" || p.currentToken.Type == "DESC" </span><span class="cov8" title="1">{
                                p.advance() // Consume ASC/DESC (we don't store it in this simple implementation)
                        }</span>

                        <span class="cov8" title="1">windowSpec.OrderBy = append(windowSpec.OrderBy, expr)

                        if p.currentToken.Type == "," </span><span class="cov0" title="0">{
                                p.advance() // Consume comma
                        }</span> else<span class="cov8" title="1"> {
                                break</span>
                        }
                }
        }

        // Parse frame clause (ROWS/RANGE with bounds)
        <span class="cov8" title="1">if p.currentToken.Type == "ROWS" || p.currentToken.Type == "RANGE" </span><span class="cov8" title="1">{
                frameType := p.currentToken.Literal
                p.advance() // Consume ROWS/RANGE

                frameClause, err := p.parseWindowFrame(frameType)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">windowSpec.FrameClause = frameClause</span>
        }

        // Expect closing parenthesis
        <span class="cov8" title="1">if p.currentToken.Type != ")" </span><span class="cov0" title="0">{
                return nil, p.expectedError(")")
        }</span>
        <span class="cov8" title="1">p.advance() // Consume )

        return windowSpec, nil</span>
}

// parseWindowFrame parses a window frame clause
func (p *Parser) parseWindowFrame(frameType string) (*ast.WindowFrame, error) <span class="cov8" title="1">{
        frame := &amp;ast.WindowFrame{
                Type: frameType,
        }

        // Parse frame bounds
        if p.currentToken.Type == "BETWEEN" </span><span class="cov8" title="1">{
                p.advance() // Consume BETWEEN

                // Parse start bound
                startBound, err := p.parseFrameBound()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">frame.Start = *startBound

                // Expect AND
                if p.currentToken.Type != "AND" </span><span class="cov0" title="0">{
                        return nil, p.expectedError("AND")
                }</span>
                <span class="cov8" title="1">p.advance() // Consume AND

                // Parse end bound
                endBound, err := p.parseFrameBound()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">frame.End = endBound</span>
        } else<span class="cov8" title="1"> {
                // Single bound (implies CURRENT ROW as end)
                startBound, err := p.parseFrameBound()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">frame.Start = *startBound</span>
                // End is nil for single bound
        }

        <span class="cov8" title="1">return frame, nil</span>
}

// parseFrameBound parses a window frame bound
func (p *Parser) parseFrameBound() (*ast.WindowFrameBound, error) <span class="cov8" title="1">{
        bound := &amp;ast.WindowFrameBound{}

        if p.currentToken.Type == "UNBOUNDED" </span><span class="cov8" title="1">{
                p.advance() // Consume UNBOUNDED
                if p.currentToken.Type == "PRECEDING" </span><span class="cov8" title="1">{
                        bound.Type = "UNBOUNDED PRECEDING"
                        p.advance() // Consume PRECEDING
                }</span> else<span class="cov0" title="0"> if p.currentToken.Type == "FOLLOWING" </span><span class="cov0" title="0">{
                        bound.Type = "UNBOUNDED FOLLOWING"
                        p.advance() // Consume FOLLOWING
                }</span> else<span class="cov0" title="0"> {
                        return nil, p.expectedError("PRECEDING or FOLLOWING after UNBOUNDED")
                }</span>
        } else<span class="cov8" title="1"> if p.currentToken.Type == "CURRENT" </span><span class="cov8" title="1">{
                p.advance() // Consume CURRENT
                if p.currentToken.Type != "ROW" </span><span class="cov0" title="0">{
                        return nil, p.expectedError("ROW after CURRENT")
                }</span>
                <span class="cov8" title="1">bound.Type = "CURRENT ROW"
                p.advance()</span> // Consume ROW
        } else<span class="cov8" title="1"> {
                // Numeric bound
                expr, err := p.parseExpression()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">bound.Value = expr

                if p.currentToken.Type == "PRECEDING" </span><span class="cov8" title="1">{
                        bound.Type = "PRECEDING"
                        p.advance() // Consume PRECEDING
                }</span> else<span class="cov0" title="0"> if p.currentToken.Type == "FOLLOWING" </span><span class="cov0" title="0">{
                        bound.Type = "FOLLOWING"
                        p.advance() // Consume FOLLOWING
                }</span> else<span class="cov0" title="0"> {
                        return nil, p.expectedError("PRECEDING or FOLLOWING after numeric value")
                }</span>
        }

        <span class="cov8" title="1">return bound, nil</span>
}

// parseColumnDef parses a column definition
func (p *Parser) parseColumnDef() (*ast.ColumnDef, error) <span class="cov0" title="0">{
        name := p.parseIdent()
        if name == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected column name")
        }</span>

        <span class="cov0" title="0">dataType := p.parseIdent()
        if dataType == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected data type")
        }</span>

        <span class="cov0" title="0">colDef := &amp;ast.ColumnDef{
                Name: name.Name,
                Type: dataType.Name,
        }

        return colDef, nil</span>
}

// parseTableConstraint parses a table constraint
func (p *Parser) parseTableConstraint() (*ast.TableConstraint, error) <span class="cov0" title="0">{
        name := p.parseIdent()
        if name == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected constraint name")
        }</span>

        <span class="cov0" title="0">constraint := &amp;ast.TableConstraint{
                Name: name.Name,
        }

        return constraint, nil</span>
}

// parseSelectStatement parses a SELECT statement
func (p *Parser) parseSelectStatement() (ast.Statement, error) <span class="cov8" title="1">{
        // We've already consumed the SELECT token in matchToken

        // Parse columns
        columns := make([]ast.Expression, 0)
        for </span><span class="cov8" title="1">{
                // Handle * as a special case
                if p.currentToken.Type == "*" </span><span class="cov8" title="1">{
                        columns = append(columns, &amp;ast.Identifier{Name: "*"})
                        p.advance()
                }</span> else<span class="cov8" title="1"> {
                        // Use parseExpression to handle all types including function calls
                        expr, err := p.parseExpression()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">columns = append(columns, expr)</span>
                }

                // Check if there are more columns
                <span class="cov8" title="1">if p.currentToken.Type != "," </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">p.advance()</span> // Consume comma
        }

        // Parse FROM clause
        <span class="cov8" title="1">if p.currentToken.Type != "FROM" </span><span class="cov8" title="1">{
                return nil, p.expectedError("FROM")
        }</span>
        <span class="cov8" title="1">p.advance() // Consume FROM

        // Parse table name
        if p.currentToken.Type != "IDENT" </span><span class="cov0" title="0">{
                return nil, p.expectedError("table name")
        }</span>
        <span class="cov8" title="1">tableName := p.currentToken.Literal
        p.advance()

        // Create table reference
        tableRef := ast.TableReference{
                Name: tableName,
        }

        // Check for table alias
        if p.currentToken.Type == "IDENT" || p.currentToken.Type == "AS" </span><span class="cov8" title="1">{
                if p.currentToken.Type == "AS" </span><span class="cov8" title="1">{
                        p.advance() // Consume AS
                        if p.currentToken.Type != "IDENT" </span><span class="cov0" title="0">{
                                return nil, p.expectedError("alias after AS")
                        }</span>
                }
                <span class="cov8" title="1">if p.currentToken.Type == "IDENT" </span><span class="cov8" title="1">{
                        tableRef.Alias = p.currentToken.Literal
                        p.advance()
                }</span>
        }

        // Create tables list for FROM clause
        <span class="cov8" title="1">tables := []ast.TableReference{tableRef}

        // Parse JOIN clauses if present
        joins := []ast.JoinClause{}
        for p.isJoinKeyword() </span><span class="cov8" title="1">{
                // Determine JOIN type
                joinType := "INNER" // Default

                if p.currentToken.Type == "LEFT" </span><span class="cov8" title="1">{
                        joinType = "LEFT"
                        p.advance()
                        if p.currentToken.Type == "OUTER" </span><span class="cov8" title="1">{
                                p.advance() // Optional OUTER keyword
                        }</span>
                } else<span class="cov8" title="1"> if p.currentToken.Type == "RIGHT" </span><span class="cov8" title="1">{
                        joinType = "RIGHT"
                        p.advance()
                        if p.currentToken.Type == "OUTER" </span><span class="cov8" title="1">{
                                p.advance() // Optional OUTER keyword
                        }</span>
                } else<span class="cov8" title="1"> if p.currentToken.Type == "FULL" </span><span class="cov8" title="1">{
                        joinType = "FULL"
                        p.advance()
                        if p.currentToken.Type == "OUTER" </span><span class="cov8" title="1">{
                                p.advance() // Optional OUTER keyword
                        }</span>
                } else<span class="cov8" title="1"> if p.currentToken.Type == "INNER" </span><span class="cov8" title="1">{
                        joinType = "INNER"
                        p.advance()
                }</span> else<span class="cov8" title="1"> if p.currentToken.Type == "CROSS" </span><span class="cov8" title="1">{
                        joinType = "CROSS"
                        p.advance()
                }</span>

                // Expect JOIN keyword
                <span class="cov8" title="1">if p.currentToken.Type != "JOIN" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("expected JOIN after %s, got %s", joinType, p.currentToken.Type)
                }</span>
                <span class="cov8" title="1">p.advance() // Consume JOIN

                // Parse joined table name
                if p.currentToken.Type != "IDENT" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("expected table name after %s JOIN, got %s", joinType, p.currentToken.Type)
                }</span>
                <span class="cov8" title="1">joinedTableName := p.currentToken.Literal
                p.advance()

                // Create joined table reference
                joinedTableRef := ast.TableReference{
                        Name: joinedTableName,
                }

                // Check for table alias
                if p.currentToken.Type == "IDENT" || p.currentToken.Type == "AS" </span><span class="cov8" title="1">{
                        if p.currentToken.Type == "AS" </span><span class="cov8" title="1">{
                                p.advance() // Consume AS
                                if p.currentToken.Type != "IDENT" </span><span class="cov0" title="0">{
                                        return nil, p.expectedError("alias after AS")
                                }</span>
                        }
                        <span class="cov8" title="1">if p.currentToken.Type == "IDENT" </span><span class="cov8" title="1">{
                                joinedTableRef.Alias = p.currentToken.Literal
                                p.advance()
                        }</span>
                }

                // Parse join condition (ON or USING)
                <span class="cov8" title="1">var joinCondition ast.Expression

                // CROSS JOIN doesn't require ON clause
                if joinType != "CROSS" </span><span class="cov8" title="1">{
                        if p.currentToken.Type == "ON" </span><span class="cov8" title="1">{
                                p.advance() // Consume ON

                                // Parse join condition
                                cond, err := p.parseExpression()
                                if err != nil </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("error parsing ON condition for %s JOIN: %v", joinType, err)
                                }</span>
                                <span class="cov8" title="1">joinCondition = cond</span>
                        } else<span class="cov8" title="1"> if p.currentToken.Type == "USING" </span><span class="cov8" title="1">{
                                p.advance() // Consume USING

                                // Parse column list in parentheses
                                if p.currentToken.Type != "(" </span><span class="cov8" title="1">{
                                        return nil, p.expectedError("( after USING")
                                }</span>
                                <span class="cov8" title="1">p.advance()

                                // TODO: LIMITATION - Currently only supports single column in USING clause
                                // Future enhancement needed for multi-column support like USING (col1, col2, col3)
                                // This requires parsing comma-separated column list and storing as []Expression
                                // Priority: Medium (Phase 2 enhancement)
                                if p.currentToken.Type != "IDENT" </span><span class="cov8" title="1">{
                                        return nil, p.expectedError("column name in USING")
                                }</span>
                                <span class="cov8" title="1">joinCondition = &amp;ast.Identifier{Name: p.currentToken.Literal}
                                p.advance()

                                if p.currentToken.Type != ")" </span><span class="cov0" title="0">{
                                        return nil, p.expectedError(") after USING column")
                                }</span>
                                <span class="cov8" title="1">p.advance()</span>
                        } else<span class="cov8" title="1"> if joinType != "NATURAL" </span><span class="cov8" title="1">{
                                return nil, p.expectedError("ON or USING")
                        }</span>
                }

                // Create join clause with proper tree relationships
                // For SQL: FROM A JOIN B JOIN C (equivalent to (A JOIN B) JOIN C)
                <span class="cov8" title="1">var leftTable ast.TableReference
                if len(joins) == 0 </span><span class="cov8" title="1">{
                        // First join: A JOIN B
                        leftTable = tableRef
                }</span> else<span class="cov8" title="1"> {
                        // Subsequent joins: (previous result) JOIN C
                        // We represent this by using a synthetic table reference that indicates
                        // the left side is the result of previous joins
                        leftTable = ast.TableReference{
                                Name:  fmt.Sprintf("(%s_with_%d_joins)", tableRef.Name, len(joins)),
                                Alias: "",
                        }
                }</span>

                <span class="cov8" title="1">joinClause := ast.JoinClause{
                        Type:      joinType,
                        Left:      leftTable,
                        Right:     joinedTableRef,
                        Condition: joinCondition,
                }

                // Add join clause to joins list
                joins = append(joins, joinClause)</span>

                // Note: We don't update tableRef here as each JOIN in the list
                // represents a join with the accumulated result set
        }

        // Initialize SELECT statement
        <span class="cov8" title="1">selectStmt := &amp;ast.SelectStatement{
                Columns:   columns,
                From:      tables,
                Joins:     joins,
                TableName: tableName, // Add this for compatibility with tests
        }

        // Parse WHERE clause if present
        if p.currentToken.Type == "WHERE" </span><span class="cov8" title="1">{
                p.advance() // Consume WHERE

                // Parse WHERE condition
                whereClause, err := p.parseExpression()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Add WHERE clause to SELECT statement
                <span class="cov8" title="1">selectStmt.Where = whereClause</span>
        }

        // Parse ORDER BY clause if present
        <span class="cov8" title="1">if p.currentToken.Type == "ORDER" </span><span class="cov8" title="1">{
                p.advance() // Consume ORDER

                if p.currentToken.Type != "BY" </span><span class="cov0" title="0">{
                        return nil, p.expectedError("BY")
                }</span>
                <span class="cov8" title="1">p.advance() // Consume BY

                // Parse ORDER BY expression
                orderByExpr, err := p.parseExpression()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Check for direction (ASC/DESC)
                // Note: Direction is handled separately in the actual implementation
                <span class="cov8" title="1">if p.currentToken.Type == "DESC" </span><span class="cov8" title="1">{
                        p.advance() // Consume DESC
                }</span> else<span class="cov0" title="0"> if p.currentToken.Type == "ASC" </span><span class="cov0" title="0">{
                        p.advance() // Consume ASC
                }</span>

                // Add ORDER BY to SELECT statement
                <span class="cov8" title="1">selectStmt.OrderBy = []ast.Expression{orderByExpr}</span>
        }

        // Parse LIMIT clause if present
        <span class="cov8" title="1">if p.currentToken.Type == "LIMIT" </span><span class="cov8" title="1">{
                p.advance() // Consume LIMIT

                // Parse LIMIT value
                if p.currentToken.Type != "INT" </span><span class="cov0" title="0">{
                        return nil, p.expectedError("integer for LIMIT")
                }</span>

                // Convert string to int
                <span class="cov8" title="1">limitVal := 0
                _, _ = fmt.Sscanf(p.currentToken.Literal, "%d", &amp;limitVal)

                // Add LIMIT to SELECT statement
                selectStmt.Limit = &amp;limitVal
                p.advance()</span>
        }

        // Parse OFFSET clause if present
        <span class="cov8" title="1">if p.currentToken.Type == "OFFSET" </span><span class="cov8" title="1">{
                p.advance() // Consume OFFSET

                // Parse OFFSET value
                if p.currentToken.Type != "INT" </span><span class="cov0" title="0">{
                        return nil, p.expectedError("integer for OFFSET")
                }</span>

                // Convert string to int
                <span class="cov8" title="1">offsetVal := 0
                _, _ = fmt.Sscanf(p.currentToken.Literal, "%d", &amp;offsetVal)

                // Add OFFSET to SELECT statement
                selectStmt.Offset = &amp;offsetVal
                p.advance()</span>
        }

        <span class="cov8" title="1">return selectStmt, nil</span>
}

// parseSelectWithSetOperations parses SELECT statements that may have set operations.
// It supports UNION, UNION ALL, EXCEPT, and INTERSECT operations with proper left-associative parsing.
//
// Examples:
//
//        SELECT name FROM users UNION SELECT name FROM customers
//        SELECT id FROM orders UNION ALL SELECT id FROM invoices
//        SELECT product FROM inventory EXCEPT SELECT product FROM discontinued
//        SELECT a FROM t1 UNION SELECT b FROM t2 INTERSECT SELECT c FROM t3
func (p *Parser) parseSelectWithSetOperations() (ast.Statement, error) <span class="cov8" title="1">{
        // Parse the first SELECT statement
        leftStmt, err := p.parseSelectStatement()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Check for set operations (UNION, EXCEPT, INTERSECT)
        <span class="cov8" title="1">for p.currentToken.Type == "UNION" || p.currentToken.Type == "EXCEPT" || p.currentToken.Type == "INTERSECT" </span><span class="cov8" title="1">{
                // Parse the set operation type
                operationType := p.currentToken.Type
                p.advance()

                // Check for ALL keyword
                all := false
                if p.currentToken.Type == "ALL" </span><span class="cov8" title="1">{
                        all = true
                        p.advance()
                }</span>

                // Parse the right-hand SELECT statement
                <span class="cov8" title="1">if p.currentToken.Type != "SELECT" </span><span class="cov0" title="0">{
                        return nil, p.expectedError("SELECT after set operation")
                }</span>
                <span class="cov8" title="1">p.advance() // Consume SELECT

                rightStmt, err := p.parseSelectStatement()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error parsing right SELECT in set operation: %v", err)
                }</span>

                // Create the set operation with left as the accumulated result
                <span class="cov8" title="1">setOp := &amp;ast.SetOperation{
                        Left:     leftStmt,
                        Operator: string(operationType),
                        All:      all,
                        Right:    rightStmt,
                }

                leftStmt = setOp</span> // The result becomes the left side for any subsequent operations
        }

        <span class="cov8" title="1">return leftStmt, nil</span>
}

// parseInsertStatement parses an INSERT statement
func (p *Parser) parseInsertStatement() (ast.Statement, error) <span class="cov8" title="1">{
        // We've already consumed the INSERT token in matchToken

        // Parse INTO
        if p.currentToken.Type != "INTO" </span><span class="cov0" title="0">{
                return nil, p.expectedError("INTO")
        }</span>
        <span class="cov8" title="1">p.advance() // Consume INTO

        // Parse table name
        if p.currentToken.Type != "IDENT" </span><span class="cov0" title="0">{
                return nil, p.expectedError("table name")
        }</span>
        <span class="cov8" title="1">tableName := p.currentToken.Literal
        p.advance()

        // Parse column list if present
        columns := make([]ast.Expression, 0)
        if p.currentToken.Type == "(" </span><span class="cov8" title="1">{
                p.advance() // Consume (

                for </span><span class="cov8" title="1">{
                        // Parse column name
                        if p.currentToken.Type != "IDENT" </span><span class="cov0" title="0">{
                                return nil, p.expectedError("column name")
                        }</span>
                        <span class="cov8" title="1">columns = append(columns, &amp;ast.Identifier{Name: p.currentToken.Literal})
                        p.advance()

                        // Check if there are more columns
                        if p.currentToken.Type != "," </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">p.advance()</span> // Consume comma
                }

                <span class="cov8" title="1">if p.currentToken.Type != ")" </span><span class="cov0" title="0">{
                        return nil, p.expectedError(")")
                }</span>
                <span class="cov8" title="1">p.advance()</span> // Consume )
        }

        // Parse VALUES
        <span class="cov8" title="1">if p.currentToken.Type != "VALUES" </span><span class="cov0" title="0">{
                return nil, p.expectedError("VALUES")
        }</span>
        <span class="cov8" title="1">p.advance() // Consume VALUES

        // Parse value list
        values := make([]ast.Expression, 0)
        if p.currentToken.Type == "(" </span><span class="cov8" title="1">{
                p.advance() // Consume (

                for </span><span class="cov8" title="1">{
                        // Parse value
                        var expr ast.Expression
                        switch p.currentToken.Type </span>{
                        case "STRING":<span class="cov8" title="1">
                                expr = &amp;ast.LiteralValue{Value: p.currentToken.Literal, Type: "string"}
                                p.advance()</span>
                        case "INT":<span class="cov0" title="0">
                                expr = &amp;ast.LiteralValue{Value: p.currentToken.Literal, Type: "int"}
                                p.advance()</span>
                        case "FLOAT":<span class="cov0" title="0">
                                expr = &amp;ast.LiteralValue{Value: p.currentToken.Literal, Type: "float"}
                                p.advance()</span>
                        default:<span class="cov0" title="0">
                                return nil, fmt.Errorf("unexpected token for value: %s", p.currentToken.Type)</span>
                        }
                        <span class="cov8" title="1">values = append(values, expr)

                        // Check if there are more values
                        if p.currentToken.Type != "," </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">p.advance()</span> // Consume comma
                }

                <span class="cov8" title="1">if p.currentToken.Type != ")" </span><span class="cov0" title="0">{
                        return nil, p.expectedError(")")
                }</span>
                <span class="cov8" title="1">p.advance()</span> // Consume )
        }

        // Create INSERT statement
        <span class="cov8" title="1">return &amp;ast.InsertStatement{
                TableName: tableName,
                Columns:   columns,
                Values:    values,
        }, nil</span>
}

// parseUpdateStatement parses an UPDATE statement
func (p *Parser) parseUpdateStatement() (ast.Statement, error) <span class="cov8" title="1">{
        // We've already consumed the UPDATE token in matchToken

        // Parse table name
        if p.currentToken.Type != "IDENT" </span><span class="cov0" title="0">{
                return nil, p.expectedError("table name")
        }</span>
        <span class="cov8" title="1">tableName := p.currentToken.Literal
        p.advance()

        // Parse SET
        if p.currentToken.Type != "SET" </span><span class="cov0" title="0">{
                return nil, p.expectedError("SET")
        }</span>
        <span class="cov8" title="1">p.advance() // Consume SET

        // Parse assignments
        updates := make([]ast.UpdateExpression, 0)
        for </span><span class="cov8" title="1">{
                // Parse column name
                if p.currentToken.Type != "IDENT" </span><span class="cov0" title="0">{
                        return nil, p.expectedError("column name")
                }</span>
                <span class="cov8" title="1">columnName := p.currentToken.Literal
                p.advance()

                if p.currentToken.Type != "=" </span><span class="cov0" title="0">{
                        return nil, p.expectedError("=")
                }</span>
                <span class="cov8" title="1">p.advance() // Consume =

                // Parse value expression
                var expr ast.Expression
                switch p.currentToken.Type </span>{
                case "STRING":<span class="cov8" title="1">
                        expr = &amp;ast.LiteralValue{Value: p.currentToken.Literal, Type: "string"}
                        p.advance()</span>
                case "INT":<span class="cov0" title="0">
                        expr = &amp;ast.LiteralValue{Value: p.currentToken.Literal, Type: "int"}
                        p.advance()</span>
                case "FLOAT":<span class="cov0" title="0">
                        expr = &amp;ast.LiteralValue{Value: p.currentToken.Literal, Type: "float"}
                        p.advance()</span>
                case "TRUE", "FALSE":<span class="cov8" title="1">
                        expr = &amp;ast.LiteralValue{Value: p.currentToken.Literal, Type: "bool"}
                        p.advance()</span>
                default:<span class="cov0" title="0">
                        var err error
                        expr, err = p.parseExpression()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                // Create update expression
                <span class="cov8" title="1">columnExpr := &amp;ast.Identifier{Name: columnName}
                updateExpr := ast.UpdateExpression{
                        Column: columnExpr,
                        Value:  expr,
                }
                updates = append(updates, updateExpr)

                // Check if there are more assignments
                if p.currentToken.Type != "," </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov0" title="0">p.advance()</span> // Consume comma
        }

        // Parse WHERE clause if present
        <span class="cov8" title="1">var whereClause ast.Expression
        if p.currentToken.Type == "WHERE" </span><span class="cov8" title="1">{
                p.advance() // Consume WHERE
                var err error
                whereClause, err = p.parseExpression()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Create UPDATE statement
        <span class="cov8" title="1">return &amp;ast.UpdateStatement{
                TableName: tableName,
                Updates:   updates,
                Where:     whereClause,
        }, nil</span>
}

// parseDeleteStatement parses a DELETE statement
func (p *Parser) parseDeleteStatement() (ast.Statement, error) <span class="cov8" title="1">{
        // We've already consumed the DELETE token in matchToken

        // Parse FROM
        if p.currentToken.Type != "FROM" </span><span class="cov0" title="0">{
                return nil, p.expectedError("FROM")
        }</span>
        <span class="cov8" title="1">p.advance() // Consume FROM

        // Parse table name
        if p.currentToken.Type != "IDENT" </span><span class="cov0" title="0">{
                return nil, p.expectedError("table name")
        }</span>
        <span class="cov8" title="1">tableName := p.currentToken.Literal
        p.advance()

        // Parse WHERE clause if present
        var whereClause ast.Expression
        if p.currentToken.Type == "WHERE" </span><span class="cov8" title="1">{
                p.advance() // Consume WHERE
                var err error
                whereClause, err = p.parseExpression()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Create DELETE statement
        <span class="cov8" title="1">return &amp;ast.DeleteStatement{
                TableName: tableName,
                Where:     whereClause,
        }, nil</span>
}

// parseAlterTableStmt is a simplified version for the parser implementation
// It delegates to the more comprehensive parseAlterStatement in alter.go
func (p *Parser) parseAlterTableStmt() (ast.Statement, error) <span class="cov0" title="0">{
        // We've already consumed the ALTER token in matchToken
        // This is just a placeholder that delegates to the main implementation
        return p.parseAlterStatement()
}</span>

// isJoinKeyword checks if current token is a JOIN-related keyword
func (p *Parser) isJoinKeyword() bool <span class="cov8" title="1">{
        switch p.currentToken.Type </span>{
        case "JOIN", "INNER", "LEFT", "RIGHT", "FULL", "CROSS":<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// parseWithStatement parses a WITH statement (Common Table Expression).
// It supports both simple and recursive CTEs, multiple CTE definitions, and column specifications.
//
// Examples:
//
//        WITH sales_summary AS (SELECT region, total FROM sales) SELECT * FROM sales_summary
//        WITH RECURSIVE emp_tree AS (SELECT emp_id FROM employees) SELECT * FROM emp_tree
//        WITH first AS (SELECT * FROM t1), second AS (SELECT * FROM first) SELECT * FROM second
//        WITH summary(region, total) AS (SELECT region, SUM(amount) FROM sales GROUP BY region) SELECT * FROM summary
func (p *Parser) parseWithStatement() (ast.Statement, error) <span class="cov8" title="1">{
        // Consume WITH
        p.advance()

        // Check for RECURSIVE keyword
        recursive := false
        if p.currentToken.Type == "RECURSIVE" </span><span class="cov8" title="1">{
                recursive = true
                p.advance()
        }</span>

        // Parse Common Table Expressions
        <span class="cov8" title="1">ctes := []*ast.CommonTableExpr{}

        for </span><span class="cov8" title="1">{
                cte, err := p.parseCommonTableExpr()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error parsing CTE: %v", err)
                }</span>
                <span class="cov8" title="1">ctes = append(ctes, cte)

                // Check for more CTEs (comma-separated)
                if p.currentToken.Type == "," </span><span class="cov8" title="1">{
                        p.advance() // Consume comma
                        continue</span>
                }
                <span class="cov8" title="1">break</span>
        }

        // Create WITH clause
        <span class="cov8" title="1">withClause := &amp;ast.WithClause{
                Recursive: recursive,
                CTEs:      ctes,
        }

        // Parse the main statement that follows the WITH clause
        mainStmt, err := p.parseMainStatementAfterWith()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing statement after WITH: %v", err)
        }</span>

        // Attach WITH clause to the main statement
        <span class="cov8" title="1">switch stmt := mainStmt.(type) </span>{
        case *ast.SelectStatement:<span class="cov8" title="1">
                stmt.With = withClause
                return stmt, nil</span>
        case *ast.SetOperation:<span class="cov8" title="1">
                // For set operations, attach WITH to the left statement if it's a SELECT
                if leftSelect, ok := stmt.Left.(*ast.SelectStatement); ok </span><span class="cov8" title="1">{
                        leftSelect.With = withClause
                }</span>
                <span class="cov8" title="1">return stmt, nil</span>
        case *ast.InsertStatement:<span class="cov0" title="0">
                stmt.With = withClause
                return stmt, nil</span>
        case *ast.UpdateStatement:<span class="cov0" title="0">
                stmt.With = withClause
                return stmt, nil</span>
        case *ast.DeleteStatement:<span class="cov0" title="0">
                stmt.With = withClause
                return stmt, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("WITH clause not supported with statement type: %T", stmt)</span>
        }
}

// parseCommonTableExpr parses a single Common Table Expression.
// It handles CTE name, optional column list, AS keyword, and the CTE query in parentheses.
//
// Syntax: cte_name [(column_list)] AS (query)
func (p *Parser) parseCommonTableExpr() (*ast.CommonTableExpr, error) <span class="cov8" title="1">{
        // Parse CTE name
        if p.currentToken.Type != "IDENT" </span><span class="cov0" title="0">{
                return nil, p.expectedError("CTE name")
        }</span>
        <span class="cov8" title="1">name := p.currentToken.Literal
        p.advance()

        // Parse optional column list
        var columns []string
        if p.currentToken.Type == "(" </span><span class="cov8" title="1">{
                p.advance() // Consume (

                for </span><span class="cov8" title="1">{
                        if p.currentToken.Type != "IDENT" </span><span class="cov0" title="0">{
                                return nil, p.expectedError("column name")
                        }</span>
                        <span class="cov8" title="1">columns = append(columns, p.currentToken.Literal)
                        p.advance()

                        if p.currentToken.Type == "," </span><span class="cov8" title="1">{
                                p.advance() // Consume comma
                                continue</span>
                        }
                        <span class="cov8" title="1">break</span>
                }

                <span class="cov8" title="1">if p.currentToken.Type != ")" </span><span class="cov0" title="0">{
                        return nil, p.expectedError(")")
                }</span>
                <span class="cov8" title="1">p.advance()</span> // Consume )
        }

        // Parse AS keyword
        <span class="cov8" title="1">if p.currentToken.Type != "AS" </span><span class="cov0" title="0">{
                return nil, p.expectedError("AS")
        }</span>
        <span class="cov8" title="1">p.advance()

        // Parse the CTE query (must be in parentheses)
        if p.currentToken.Type != "(" </span><span class="cov0" title="0">{
                return nil, p.expectedError("( before CTE query")
        }</span>
        <span class="cov8" title="1">p.advance() // Consume (

        // Parse the inner statement
        stmt, err := p.parseStatement()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing CTE statement: %v", err)
        }</span>

        <span class="cov8" title="1">if p.currentToken.Type != ")" </span><span class="cov0" title="0">{
                return nil, p.expectedError(") after CTE query")
        }</span>
        <span class="cov8" title="1">p.advance() // Consume )

        return &amp;ast.CommonTableExpr{
                Name:      name,
                Columns:   columns,
                Statement: stmt,
        }, nil</span>
}

// parseMainStatementAfterWith parses the main statement after WITH clause.
// It supports SELECT, INSERT, UPDATE, and DELETE statements, routing them to the appropriate
// parsers while preserving set operation support for SELECT statements.
func (p *Parser) parseMainStatementAfterWith() (ast.Statement, error) <span class="cov8" title="1">{
        switch p.currentToken.Type </span>{
        case "SELECT":<span class="cov8" title="1">
                p.advance() // Consume SELECT
                return p.parseSelectWithSetOperations()</span>
        case "INSERT":<span class="cov0" title="0">
                p.advance() // Consume INSERT
                return p.parseInsertStatement()</span>
        case "UPDATE":<span class="cov0" title="0">
                p.advance() // Consume UPDATE
                return p.parseUpdateStatement()</span>
        case "DELETE":<span class="cov0" title="0">
                p.advance() // Consume DELETE
                return p.parseDeleteStatement()</span>
        default:<span class="cov0" title="0">
                return nil, p.expectedError("SELECT, INSERT, UPDATE, or DELETE after WITH")</span>
        }
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package token

import (
        "sync"
)

var tokenPool = sync.Pool{
        New: func() interface{} <span class="cov0" title="0">{
                return &amp;Token{}
        }</span>,
}

// Get retrieves a Token from the pool
func Get() *Token <span class="cov0" title="0">{
        token := tokenPool.Get().(*Token)
        token.Type = ""
        token.Literal = ""
        return token
}</span>

// Put returns a Token to the pool
func Put(t *Token) error <span class="cov0" title="0">{
        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">t.Type = ""
        t.Literal = ""
        tokenPool.Put(t)
        return nil</span>
}

// Reset resets a token's fields
func (t *Token) Reset() <span class="cov0" title="0">{
        t.Type = ""
        t.Literal = ""
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package token

// Type represents a token type
type Type string

// Token represents a lexical token
type Token struct {
        Type    Type
        Literal string
}

// Token types
const (
        // Special tokens
        ILLEGAL = Type("ILLEGAL")
        EOF     = Type("EOF")
        WS      = Type("WS")

        // Identifiers and literals
        IDENT  = Type("IDENT")  // column, table_name
        INT    = Type("INT")    // 12345
        FLOAT  = Type("FLOAT")  // 123.45
        STRING = Type("STRING") // "abc", 'abc'
        TRUE   = Type("TRUE")   // TRUE
        FALSE  = Type("FALSE")  // FALSE

        // Operators
        EQ       = Type("=")
        NEQ      = Type("!=")
        NOT_EQ   = Type("!=") // Alias for NEQ
        LT       = Type("&lt;")
        LTE      = Type("&lt;=")
        GT       = Type("&gt;")
        GTE      = Type("&gt;=")
        ASTERISK = Type("*")

        // Delimiters
        COMMA     = Type(",")
        SEMICOLON = Type(";")
        LPAREN    = Type("(")
        RPAREN    = Type(")")
        DOT       = Type(".")

        // Keywords
        SELECT = Type("SELECT")
        INSERT = Type("INSERT")
        UPDATE = Type("UPDATE")
        DELETE = Type("DELETE")
        FROM   = Type("FROM")
        WHERE  = Type("WHERE")
        ORDER  = Type("ORDER")
        BY     = Type("BY")
        GROUP  = Type("GROUP")
        HAVING = Type("HAVING")
        LIMIT  = Type("LIMIT")
        OFFSET = Type("OFFSET")
        AS     = Type("AS")
        AND    = Type("AND")
        OR     = Type("OR")
        IN     = Type("IN")
        NOT    = Type("NOT")
        NULL   = Type("NULL")
        ALL    = Type("ALL")
        ON     = Type("ON")
        INTO   = Type("INTO")
        VALUES = Type("VALUES")

        // Role keywords
        SUPERUSER    = Type("SUPERUSER")
        NOSUPERUSER  = Type("NOSUPERUSER")
        CREATEDB     = Type("CREATEDB")
        NOCREATEDB   = Type("NOCREATEDB")
        CREATEROLE   = Type("CREATEROLE")
        NOCREATEROLE = Type("NOCREATEROLE")
        LOGIN        = Type("LOGIN")
        NOLOGIN      = Type("NOLOGIN")

        // ALTER statement keywords
        ALTER        = Type("ALTER")
        TABLE        = Type("TABLE")
        ROLE         = Type("ROLE")
        POLICY       = Type("POLICY")
        CONNECTOR    = Type("CONNECTOR")
        ADD          = Type("ADD")
        DROP         = Type("DROP")
        COLUMN       = Type("COLUMN")
        CONSTRAINT   = Type("CONSTRAINT")
        RENAME       = Type("RENAME")
        TO           = Type("TO")
        SET          = Type("SET")
        RESET        = Type("RESET")
        MEMBER       = Type("MEMBER")
        OWNER        = Type("OWNER")
        USER         = Type("USER")
        URL          = Type("URL")
        DCPROPERTIES = Type("DCPROPERTIES")
        CASCADE      = Type("CASCADE")
        WITH         = Type("WITH")
        CHECK        = Type("CHECK")
        USING        = Type("USING")
        UNTIL        = Type("UNTIL")
        VALID        = Type("VALID")
        PASSWORD     = Type("PASSWORD")
        EQUAL        = Type("=")
)

// IsKeyword returns true if the token type is a keyword
func (t Type) IsKeyword() bool <span class="cov0" title="0">{
        switch t </span>{
        case SELECT, INSERT, UPDATE, DELETE, FROM, WHERE, ORDER, BY, GROUP, HAVING, LIMIT, OFFSET, AS, AND, OR, IN, NOT, NULL, INTO, VALUES, TRUE, FALSE, SET, ALTER, TABLE:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// IsOperator returns true if the token type is an operator
func (t Type) IsOperator() bool <span class="cov0" title="0">{
        switch t </span>{
        case EQ, NEQ, LT, LTE, GT, GTE, ASTERISK:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// IsLiteral returns true if the token type is a literal
func (t Type) IsLiteral() bool <span class="cov0" title="0">{
        switch t </span>{
        case IDENT, INT, FLOAT, STRING, TRUE, FALSE:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package tokenizer

import (
        "sync"
)

// BufferPool manages a pool of reusable byte buffers for token content
type BufferPool struct {
        pool sync.Pool
}

// NewBufferPool creates a new buffer pool with optimized initial capacity
func NewBufferPool() *BufferPool <span class="cov0" title="0">{
        return &amp;BufferPool{
                pool: sync.Pool{
                        New: func() interface{} </span><span class="cov0" title="0">{
                                // Pre-allocate buffer for common token sizes
                                b := make([]byte, 0, 128)
                                return &amp;b
                        }</span>,
                },
        }
}

// Get retrieves a buffer from the pool
func (p *BufferPool) Get() []byte <span class="cov0" title="0">{
        buf := p.pool.Get().(*[]byte)
        *buf = (*buf)[:0] // Reset length but keep capacity
        return *buf
}</span>

// Put returns a buffer to the pool
func (p *BufferPool) Put(buf []byte) <span class="cov0" title="0">{
        if cap(buf) &gt; 0 </span><span class="cov0" title="0">{
                p.pool.Put(&amp;buf)
        }</span>
}

// Grow ensures the buffer has enough capacity
func (p *BufferPool) Grow(buf []byte, n int) []byte <span class="cov0" title="0">{
        if cap(buf)-len(buf) &lt; n </span><span class="cov0" title="0">{
                // Create new buffer with doubled capacity
                newBuf := make([]byte, len(buf), 2*cap(buf)+n)
                copy(newBuf, buf)
                p.Put(buf) // Return old buffer to pool
                return newBuf
        }</span>
        <span class="cov0" title="0">return buf</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package tokenizer

import (
        "fmt"

        "github.com/ajitpratap0/GoSQLX/pkg/models"
)

// Error represents a tokenization error with location information
type Error struct {
        Message  string
        Location models.Location
}

func (e *Error) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s at line %d, column %d", e.Message, e.Location.Line, e.Location.Column)
}</span>

// NewError creates a new tokenization error
func NewError(message string, location models.Location) *Error <span class="cov0" title="0">{
        return &amp;Error{
                Message:  message,
                Location: location,
        }
}</span>

// ErrorUnexpectedChar creates an error for an unexpected character
func ErrorUnexpectedChar(ch byte, location models.Location) *Error <span class="cov0" title="0">{
        return NewError(fmt.Sprintf("unexpected character: %c", ch), location)
}</span>

// ErrorUnterminatedString creates an error for an unterminated string
func ErrorUnterminatedString(location models.Location) *Error <span class="cov0" title="0">{
        return NewError("unterminated string literal", location)
}</span>

// ErrorInvalidNumber creates an error for an invalid number format
func ErrorInvalidNumber(value string, location models.Location) *Error <span class="cov0" title="0">{
        return NewError(fmt.Sprintf("invalid number format: %s", value), location)
}</span>

// ErrorInvalidIdentifier creates an error for an invalid identifier
func ErrorInvalidIdentifier(value string, location models.Location) *Error <span class="cov0" title="0">{
        return NewError(fmt.Sprintf("invalid identifier: %s", value), location)
}</span>

// ErrorInvalidOperator creates an error for an invalid operator
func ErrorInvalidOperator(value string, location models.Location) *Error <span class="cov0" title="0">{
        return NewError(fmt.Sprintf("invalid operator: %s", value), location)
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package tokenizer

import (
        "bytes"
        "sync"

        "github.com/ajitpratap0/GoSQLX/pkg/metrics"
)

// bufferPool is used to reuse buffers during tokenization
var bufferPool = sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{
                // Increase initial capacity for better performance with typical SQL queries
                return bytes.NewBuffer(make([]byte, 0, 256))
        }</span>,
}

// getBuffer gets a buffer from the pool
func getBuffer() *bytes.Buffer <span class="cov8" title="1">{
        return bufferPool.Get().(*bytes.Buffer)
}</span>

// putBuffer returns a buffer to the pool
func putBuffer(buf *bytes.Buffer) <span class="cov8" title="1">{
        if buf != nil </span><span class="cov8" title="1">{
                buf.Reset()
                bufferPool.Put(buf)
        }</span>
}

// tokenizerPool allows reuse of Tokenizer instances
var tokenizerPool = sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{
                t, _ := New() // Error ignored as New() only errors on keyword initialization
                return t
        }</span>,
}

// GetTokenizer gets a Tokenizer from the pool
func GetTokenizer() *Tokenizer <span class="cov8" title="1">{
        t := tokenizerPool.Get().(*Tokenizer)

        // Record pool metrics
        metrics.RecordPoolGet(true) // Assume from pool (New() creates if empty)

        return t
}</span>

// PutTokenizer returns a Tokenizer to the pool
func PutTokenizer(t *Tokenizer) <span class="cov8" title="1">{
        if t != nil </span><span class="cov8" title="1">{
                t.Reset()
                tokenizerPool.Put(t)

                // Record pool return
                metrics.RecordPoolPut()
        }</span>
}

// Reset resets a Tokenizer's state for reuse
func (t *Tokenizer) Reset() <span class="cov8" title="1">{
        // Clear input reference to allow garbage collection
        t.input = nil

        // Reset position tracking
        t.pos = NewPosition(1, 0)
        t.lineStart = Position{}

        // Preserve lineStarts slice capacity but reset length
        if cap(t.lineStarts) &gt; 0 </span><span class="cov8" title="1">{
                t.lineStarts = t.lineStarts[:0]
                t.lineStarts = append(t.lineStarts, 0)
        }</span> else<span class="cov0" title="0"> {
                // Initialize if not yet allocated
                t.lineStarts = make([]int, 1, 16) // Start with reasonable capacity
                t.lineStarts[0] = 0
        }</span>

        <span class="cov8" title="1">t.line = 0

        // Don't reset keywords as they're constant
        t.debugLog = nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package tokenizer

import (
        "github.com/ajitpratap0/GoSQLX/pkg/models"
)

// Position tracks our scanning cursor with optimized tracking
// - Line is 1-based
// - Index is 0-based
// - Column is 1-based
// - LastNL tracks the last newline for efficient column calculation
type Position struct {
        Line   int
        Index  int
        Column int
        LastNL int // byte offset of last newline
}

// NewPosition builds a Position from raw info
func NewPosition(line, index int) Position <span class="cov8" title="1">{
        return Position{
                Line:   line,
                Index:  index,
                Column: 1,
        }
}</span>

// Location gives the models.Location for this position
func (p Position) Location(t *Tokenizer) models.Location <span class="cov0" title="0">{
        return t.getLocation(p.Index)
}</span>

// Advance moves us forward by the given rune, updating line/col efficiently
func (p *Position) AdvanceRune(r rune, size int) <span class="cov8" title="1">{
        if size == 0 </span><span class="cov0" title="0">{
                size = 1 // fallback to single byte
        }</span>

        // Move forward by the rune's size
        <span class="cov8" title="1">p.Index += size

        // Handle newlines
        if r == '\n' </span><span class="cov8" title="1">{
                p.Line++
                p.LastNL = p.Index
                p.Column = 1
        }</span> else<span class="cov8" title="1"> {
                p.Column++
        }</span>
}

// AdvanceN moves forward by n bytes
func (p *Position) AdvanceN(n int, lineStarts []int) <span class="cov0" title="0">{
        if n &lt;= 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // Update index
        <span class="cov0" title="0">p.Index += n

        // Find which line we're on
        for i := len(lineStarts) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                if p.Index &gt;= lineStarts[i] </span><span class="cov0" title="0">{
                        p.Line = i + 1
                        p.Column = p.Index - lineStarts[i] + 1
                        break</span>
                }
        }
}

// Clone makes a copy of Position
func (p Position) Clone() Position <span class="cov8" title="1">{
        return Position{
                Line:   p.Line,
                Index:  p.Index,
                Column: p.Column,
        }
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package tokenizer

import (
        "bytes"
        "fmt"
        "unicode/utf8"

        "github.com/ajitpratap0/GoSQLX/pkg/models"
)

// StringLiteralReader handles reading of string literals with proper escape sequence handling
type StringLiteralReader struct {
        input []byte
        pos   *Position
        quote rune
}

// NewStringLiteralReader creates a new StringLiteralReader
func NewStringLiteralReader(input []byte, pos *Position, quote rune) *StringLiteralReader <span class="cov0" title="0">{
        return &amp;StringLiteralReader{
                input: input,
                pos:   pos,
                quote: quote,
        }
}</span>

// ReadStringLiteral reads a string literal with proper escape sequence handling
func (r *StringLiteralReader) ReadStringLiteral() (models.Token, error) <span class="cov0" title="0">{
        // Normalize the quote character
        r.quote = normalizeQuote(r.quote)
        var buf bytes.Buffer
        startPos := r.pos.Clone()

        // Skip the opening quote
        r.pos.Index++
        r.pos.Column++

        for r.pos.Index &lt; len(r.input) </span><span class="cov0" title="0">{
                ch, size := utf8.DecodeRune(r.input[r.pos.Index:])
                ch = normalizeQuote(ch)

                if ch == '\\' </span><span class="cov0" title="0">{
                        // Handle escape sequences
                        if err := r.handleEscapeSequence(&amp;buf); err != nil </span><span class="cov0" title="0">{
                                return models.Token{}, TokenizerError{
                                        Message:  fmt.Sprintf("invalid escape sequence at line %d, column %d", r.pos.Line, r.pos.Column),
                                        Location: models.Location{Line: r.pos.Line, Column: r.pos.Column},
                                }
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">if ch == '\n' </span><span class="cov0" title="0">{
                        return models.Token{}, TokenizerError{
                                Message:  fmt.Sprintf("unterminated string literal starting at line %d, column %d", startPos.Line, startPos.Column),
                                Location: models.Location{Line: startPos.Line, Column: startPos.Column},
                        }
                }</span>

                <span class="cov0" title="0">if ch == r.quote </span><span class="cov0" title="0">{
                        // Check for double quotes (escaped quotes)
                        if r.pos.Index+size &lt; len(r.input) </span><span class="cov0" title="0">{
                                nextR, nextSize := utf8.DecodeRune(r.input[r.pos.Index+size:])
                                nextR = normalizeQuote(nextR)
                                if nextR == r.quote </span><span class="cov0" title="0">{
                                        // Include one quote and skip the other
                                        buf.WriteRune(ch)
                                        r.pos.Index += size + nextSize
                                        r.pos.Column += 2
                                        continue</span>
                                }
                        }
                        // End of string
                        <span class="cov0" title="0">r.pos.Index += size
                        r.pos.Column++
                        return models.Token{
                                Type:  models.TokenTypeSingleQuotedString,
                                Value: buf.String(),
                        }, nil</span>
                }

                // Handle regular characters
                <span class="cov0" title="0">buf.WriteRune(ch)
                r.pos.Index += size
                r.pos.Column++</span>
        }

        <span class="cov0" title="0">return models.Token{}, TokenizerError{
                Message:  fmt.Sprintf("unterminated string literal starting at line %d, column %d", startPos.Line, startPos.Column),
                Location: models.Location{Line: startPos.Line, Column: startPos.Column},
        }</span>
}

// handleEscapeSequence processes escape sequences in string literals
func (r *StringLiteralReader) handleEscapeSequence(buf *bytes.Buffer) error <span class="cov0" title="0">{
        // Skip the backslash
        r.pos.Index++
        r.pos.Column++

        if r.pos.Index &gt;= len(r.input) </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected end of input after escape character")
        }</span>

        <span class="cov0" title="0">ch := r.input[r.pos.Index]
        r.pos.Index++
        r.pos.Column++

        switch ch </span>{
        case 'n':<span class="cov0" title="0">
                buf.WriteByte('\n')</span>
        case 'r':<span class="cov0" title="0">
                buf.WriteByte('\r')</span>
        case 't':<span class="cov0" title="0">
                buf.WriteByte('\t')</span>
        case '\\':<span class="cov0" title="0">
                buf.WriteByte('\\')</span>
        case '\'':<span class="cov0" title="0">
                buf.WriteByte('\'')</span>
        case '"':<span class="cov0" title="0">
                buf.WriteByte('"')</span>
        case 'u':<span class="cov0" title="0">
                return r.handleUnicodeEscape(buf)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid escape sequence '\\%c'", ch)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// handleUnicodeEscape handles \uXXXX Unicode escape sequences
func (r *StringLiteralReader) handleUnicodeEscape(buf *bytes.Buffer) error <span class="cov0" title="0">{
        if r.pos.Index+4 &gt; len(r.input) </span><span class="cov0" title="0">{
                return fmt.Errorf("incomplete Unicode escape sequence")
        }</span>

        <span class="cov0" title="0">var value rune
        for i := 0; i &lt; 4; i++ </span><span class="cov0" title="0">{
                ch := r.input[r.pos.Index+i]
                var digit rune
                switch </span>{
                case ch &gt;= '0' &amp;&amp; ch &lt;= '9':<span class="cov0" title="0">
                        digit = rune(ch - '0')</span>
                case ch &gt;= 'a' &amp;&amp; ch &lt;= 'f':<span class="cov0" title="0">
                        digit = rune(ch-'a') + 10</span>
                case ch &gt;= 'A' &amp;&amp; ch &lt;= 'F':<span class="cov0" title="0">
                        digit = rune(ch-'A') + 10</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("invalid Unicode escape sequence")</span>
                }
                <span class="cov0" title="0">value = value*16 + digit</span>
        }

        <span class="cov0" title="0">buf.WriteRune(value)
        r.pos.Index += 4
        r.pos.Column += 4
        return nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">// Package tokenizer provides a high-performance SQL tokenizer with zero-copy operations
package tokenizer

import (
        "bytes"
        "fmt"
        "strings"
        "time"
        "unicode/utf8"

        "github.com/ajitpratap0/GoSQLX/pkg/metrics"
        "github.com/ajitpratap0/GoSQLX/pkg/models"
        "github.com/ajitpratap0/GoSQLX/pkg/sql/keywords"
)

// keywordTokenTypes maps SQL keywords to their token types for fast lookup
var keywordTokenTypes = map[string]models.TokenType{
        "SELECT":    models.TokenTypeSelect,
        "FROM":      models.TokenTypeFrom,
        "WHERE":     models.TokenTypeWhere,
        "GROUP":     models.TokenTypeGroup,
        "ORDER":     models.TokenTypeOrder,
        "HAVING":    models.TokenTypeHaving,
        "JOIN":      models.TokenTypeJoin,
        "INNER":     models.TokenTypeInner,
        "LEFT":      models.TokenTypeLeft,
        "RIGHT":     models.TokenTypeRight,
        "OUTER":     models.TokenTypeOuter,
        "ON":        models.TokenTypeOn,
        "AND":       models.TokenTypeAnd,
        "OR":        models.TokenTypeOr,
        "NOT":       models.TokenTypeNot,
        "AS":        models.TokenTypeAs,
        "BY":        models.TokenTypeBy,
        "IN":        models.TokenTypeIn,
        "LIKE":      models.TokenTypeLike,
        "BETWEEN":   models.TokenTypeBetween,
        "IS":        models.TokenTypeIs,
        "NULL":      models.TokenTypeNull,
        "TRUE":      models.TokenTypeTrue,
        "FALSE":     models.TokenTypeFalse,
        "CASE":      models.TokenTypeCase,
        "WHEN":      models.TokenTypeWhen,
        "THEN":      models.TokenTypeThen,
        "ELSE":      models.TokenTypeElse,
        "END":       models.TokenTypeEnd,
        "ASC":       models.TokenTypeAsc,
        "DESC":      models.TokenTypeDesc,
        "LIMIT":     models.TokenTypeLimit,
        "OFFSET":    models.TokenTypeOffset,
        "COUNT":     models.TokenTypeCount,
        "FULL":      models.TokenTypeKeyword,
        "CROSS":     models.TokenTypeKeyword,
        "USING":     models.TokenTypeKeyword,
        "WITH":      models.TokenTypeKeyword,
        "RECURSIVE": models.TokenTypeKeyword,
        "UNION":     models.TokenTypeKeyword,
        "EXCEPT":    models.TokenTypeKeyword,
        "INTERSECT": models.TokenTypeKeyword,
        "ALL":       models.TokenTypeKeyword,
        "SUM":       models.TokenTypeSum,
        "AVG":       models.TokenTypeAvg,
        "MIN":       models.TokenTypeMin,
        "MAX":       models.TokenTypeMax,
}

// Tokenizer provides high-performance SQL tokenization with zero-copy operations
type Tokenizer struct {
        input      []byte
        pos        Position
        lineStart  Position
        lineStarts []int
        line       int
        keywords   *keywords.Keywords
        debugLog   DebugLogger
}

// TokenizerError is a simple error wrapper
type TokenizerError struct {
        Message  string
        Location models.Location
}

func (e TokenizerError) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>

// SetDebugLogger sets a debug logger for verbose tracing
func (t *Tokenizer) SetDebugLogger(logger DebugLogger) <span class="cov0" title="0">{
        t.debugLog = logger
}</span>

// New creates a new Tokenizer with default configuration
func New() (*Tokenizer, error) <span class="cov8" title="1">{
        kw := keywords.NewKeywords()
        return &amp;Tokenizer{
                keywords:   kw,
                pos:        NewPosition(1, 0),
                lineStarts: []int{0},
        }, nil
}</span>

// NewWithKeywords initializes a Tokenizer with custom keywords
func NewWithKeywords(kw *keywords.Keywords) (*Tokenizer, error) <span class="cov0" title="0">{
        if kw == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("keywords cannot be nil")
        }</span>

        <span class="cov0" title="0">return &amp;Tokenizer{
                keywords:   kw,
                pos:        NewPosition(1, 0),
                lineStarts: []int{0},
        }, nil</span>
}

// Tokenize processes the input and returns tokens
func (t *Tokenizer) Tokenize(input []byte) ([]models.TokenWithSpan, error) <span class="cov8" title="1">{
        // Record start time for metrics
        startTime := time.Now()

        // Reset state
        t.Reset()
        t.input = input

        // Pre-allocate line starts slice - reuse if possible
        estimatedLines := len(input)/50 + 1 // Estimate 50 chars per line + 1 for initial 0
        if cap(t.lineStarts) &lt; estimatedLines </span><span class="cov8" title="1">{
                t.lineStarts = make([]int, 0, estimatedLines)
        }</span> else<span class="cov8" title="1"> {
                t.lineStarts = t.lineStarts[:0]
        }</span>
        <span class="cov8" title="1">t.lineStarts = append(t.lineStarts, 0)

        // Pre-scan input to build line start indices
        for i := 0; i &lt; len(t.input); i++ </span><span class="cov8" title="1">{
                if t.input[i] == '\n' </span><span class="cov8" title="1">{
                        t.lineStarts = append(t.lineStarts, i+1)
                }</span>
        }

        // Pre-allocate token slice with better capacity estimation
        // More accurate estimation based on typical SQL token density
        <span class="cov8" title="1">estimatedTokens := len(input) / 4
        if estimatedTokens &lt; 16 </span><span class="cov8" title="1">{
                estimatedTokens = 16 // At least 16 tokens
        }</span>
        <span class="cov8" title="1">tokens := make([]models.TokenWithSpan, 0, estimatedTokens)

        // Get a buffer from the pool for string operations
        buf := getBuffer()
        defer putBuffer(buf)

        var tokenErr error
        func() </span><span class="cov8" title="1">{
                // Ensure proper cleanup even if we panic
                defer func() </span><span class="cov8" title="1">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                tokenErr = fmt.Errorf("panic during tokenization: %v", r)
                        }</span>
                }()

                <span class="cov8" title="1">for t.pos.Index &lt; len(t.input) </span><span class="cov8" title="1">{
                        t.skipWhitespace()

                        if t.pos.Index &gt;= len(t.input) </span><span class="cov8" title="1">{
                                break</span>
                        }

                        <span class="cov8" title="1">startPos := t.pos

                        token, err := t.nextToken()
                        if err != nil </span><span class="cov8" title="1">{
                                tokenErr = TokenizerError{
                                        Message:  err.Error(),
                                        Location: t.toSQLPosition(startPos),
                                }
                                return
                        }</span>

                        <span class="cov8" title="1">tokens = append(tokens, models.TokenWithSpan{
                                Token: token,
                                Start: t.toSQLPosition(startPos),
                                End:   t.getCurrentPosition(),
                        })</span>
                }
        }()

        <span class="cov8" title="1">if tokenErr != nil </span><span class="cov8" title="1">{
                // Record metrics for failed tokenization
                duration := time.Since(startTime)
                metrics.RecordTokenization(duration, len(input), tokenErr)
                return nil, tokenErr
        }</span>

        // Add EOF token
        <span class="cov8" title="1">tokens = append(tokens, models.TokenWithSpan{
                Token: models.Token{Type: models.TokenTypeEOF},
                Start: t.getCurrentPosition(),
                End:   t.getCurrentPosition(),
        })

        // Record metrics for successful tokenization
        duration := time.Since(startTime)
        metrics.RecordTokenization(duration, len(input), nil)

        return tokens, nil</span>
}

// skipWhitespace advances past any whitespace
func (t *Tokenizer) skipWhitespace() <span class="cov8" title="1">{
        for t.pos.Index &lt; len(t.input) </span><span class="cov8" title="1">{
                r, size := utf8.DecodeRune(t.input[t.pos.Index:])
                if r == ' ' || r == '\t' || r == '\n' || r == '\r' </span><span class="cov8" title="1">{
                        t.pos.AdvanceRune(r, size)
                        continue</span>
                }
                <span class="cov8" title="1">break</span>
        }
}

// nextToken picks out the next token from the input
func (t *Tokenizer) nextToken() (models.Token, error) <span class="cov8" title="1">{
        if t.pos.Index &gt;= len(t.input) </span><span class="cov0" title="0">{
                return models.Token{Type: models.TokenTypeEOF}, nil
        }</span>

        // Fast path for common cases
        <span class="cov8" title="1">r, _ := utf8.DecodeRune(t.input[t.pos.Index:])
        switch </span>{
        case isIdentifierStart(r):<span class="cov8" title="1">
                return t.readIdentifier()</span>
        case r &gt;= '0' &amp;&amp; r &lt;= '9':<span class="cov8" title="1">
                return t.readNumber(nil)</span>
        case r == '"' || isUnicodeQuote(r):<span class="cov8" title="1">
                return t.readQuotedIdentifier()</span>
        case r == '`':<span class="cov0" title="0">
                // MySQL-style backtick identifier
                return t.readBacktickIdentifier()</span>
        case r == '\'' || r == '\u2018' || r == '\u2019' || r == '\u00AB' || r == '\u00BB':<span class="cov8" title="1">
                return t.readQuotedString(r)</span>
        }

        // Slower path for punctuation and operators
        <span class="cov8" title="1">return t.readPunctuation()</span>
}

// isIdentifierStart checks if a rune can start an identifier
func isIdentifierStart(r rune) bool <span class="cov8" title="1">{
        return isUnicodeIdentifierStart(r)
}</span>

// readIdentifier reads an identifier (e.g. foo or foo.bar)
func (t *Tokenizer) readIdentifier() (models.Token, error) <span class="cov8" title="1">{
        start := t.pos.Index
        r, size := utf8.DecodeRune(t.input[t.pos.Index:])
        t.pos.AdvanceRune(r, size)

        // Read until we hit a non-identifier character
        for t.pos.Index &lt; len(t.input) </span><span class="cov8" title="1">{
                r, size = utf8.DecodeRune(t.input[t.pos.Index:])
                if !isIdentifierChar(r) </span><span class="cov8" title="1">{
                        _ = size // Mark as intentionally unused
                        break</span>
                }
                <span class="cov8" title="1">t.pos.AdvanceRune(r, size)</span>
        }

        <span class="cov8" title="1">ident := string(t.input[start:t.pos.Index])
        word := &amp;models.Word{
                Value: ident,
        }

        // Determine token type based on whether it's a keyword
        upperIdent := strings.ToUpper(ident)
        tokenType, isKeyword := keywordTokenTypes[upperIdent]
        if !isKeyword </span><span class="cov8" title="1">{
                tokenType = models.TokenTypeIdentifier
        }</span>

        // Check if this could be the start of a compound keyword
        <span class="cov8" title="1">if isCompoundKeywordStart(upperIdent) </span><span class="cov8" title="1">{
                // Save current position
                savePos := t.pos.Clone()

                // Skip whitespace
                t.skipWhitespace()

                if t.pos.Index &lt; len(t.input) </span><span class="cov8" title="1">{
                        // Try to read the next word
                        nextStart := t.pos.Index
                        r, size := utf8.DecodeRune(t.input[t.pos.Index:])
                        if isIdentifierStart(r) </span><span class="cov8" title="1">{
                                t.pos.AdvanceRune(r, size)

                                // Read until we hit a non-identifier character
                                for t.pos.Index &lt; len(t.input) </span><span class="cov8" title="1">{
                                        r, size = utf8.DecodeRune(t.input[t.pos.Index:])
                                        if !isIdentifierChar(r) </span><span class="cov8" title="1">{
                                                _ = size // Mark as intentionally unused
                                                break</span>
                                        }
                                        <span class="cov8" title="1">t.pos.AdvanceRune(r, size)</span>
                                }

                                <span class="cov8" title="1">nextIdent := string(t.input[nextStart:t.pos.Index])
                                compoundKeyword := ident + " " + nextIdent
                                upperCompound := strings.ToUpper(compoundKeyword)

                                // Check if it's a valid compound keyword
                                if compoundType, ok := compoundKeywordTypes[upperCompound]; ok </span><span class="cov8" title="1">{
                                        return models.Token{
                                                Type:  compoundType,
                                                Word:  word,
                                                Value: compoundKeyword,
                                        }, nil
                                }</span>
                        }
                }

                // Not a compound keyword, restore position
                <span class="cov0" title="0">t.pos = savePos</span>
        }

        <span class="cov8" title="1">return models.Token{
                Type:  tokenType,
                Word:  word,
                Value: ident,
        }, nil</span>
}

// compoundKeywordStarts is a set of keywords that can start compound keywords
var compoundKeywordStarts = map[string]bool{
        "GROUP":   true,
        "ORDER":   true,
        "LEFT":    true,
        "RIGHT":   true,
        "INNER":   true,
        "OUTER":   true,
        "CROSS":   true,
        "NATURAL": true,
        "FULL":    true,
}

// compoundKeywordTypes maps compound SQL keywords to their token types
var compoundKeywordTypes = map[string]models.TokenType{
        "GROUP BY":         models.TokenTypeGroupBy,
        "ORDER BY":         models.TokenTypeOrderBy,
        "LEFT JOIN":        models.TokenTypeLeftJoin,
        "RIGHT JOIN":       models.TokenTypeRightJoin,
        "INNER JOIN":       models.TokenTypeInnerJoin,
        "OUTER JOIN":       models.TokenTypeOuterJoin,
        "FULL JOIN":        models.TokenTypeKeyword,
        "CROSS JOIN":       models.TokenTypeKeyword,
        "LEFT OUTER JOIN":  models.TokenTypeKeyword,
        "RIGHT OUTER JOIN": models.TokenTypeKeyword,
        "FULL OUTER JOIN":  models.TokenTypeKeyword,
}

// Helper function to check if a word can start a compound keyword
func isCompoundKeywordStart(word string) bool <span class="cov8" title="1">{
        return compoundKeywordStarts[word]
}</span>

// readQuotedIdentifier reads something like "MyColumn" with support for Unicode quotes
func (t *Tokenizer) readQuotedIdentifier() (models.Token, error) <span class="cov8" title="1">{
        // Get and normalize opening quote
        r, size := utf8.DecodeRune(t.input[t.pos.Index:])
        quote := normalizeQuote(r)
        startPos := t.pos.Clone()

        // Skip opening quote
        t.pos.AdvanceRune(r, size)

        var buf bytes.Buffer
        for t.pos.Index &lt; len(t.input) </span><span class="cov8" title="1">{
                r, size := utf8.DecodeRune(t.input[t.pos.Index:])
                r = normalizeQuote(r)

                if r == quote </span><span class="cov8" title="1">{
                        // Check for escaped quote
                        if t.pos.Index+size &lt; len(t.input) </span><span class="cov8" title="1">{
                                nextR, nextSize := utf8.DecodeRune(t.input[t.pos.Index+size:])
                                nextR = normalizeQuote(nextR)
                                if nextR == quote </span><span class="cov0" title="0">{
                                        // Include one quote and skip the other
                                        buf.WriteRune(r)
                                        t.pos.Index += size + nextSize
                                        t.pos.Column += 2
                                        continue</span>
                                }
                        }

                        // End of quoted identifier
                        <span class="cov8" title="1">t.pos.Index += size
                        t.pos.Column++

                        word := &amp;models.Word{
                                Value:      buf.String(),
                                QuoteStyle: quote,
                        }

                        // Double-quoted strings are identifiers in SQL
                        return models.Token{
                                Type:  models.TokenTypeDoubleQuotedString,
                                Word:  word,
                                Value: buf.String(),
                                Quote: quote,
                        }, nil</span>
                }

                <span class="cov8" title="1">if r == '\n' </span><span class="cov0" title="0">{
                        return models.Token{}, TokenizerError{
                                Message:  fmt.Sprintf("unterminated quoted identifier starting at line %d, column %d", startPos.Line, startPos.Column),
                                Location: models.Location{Line: startPos.Line, Column: startPos.Column},
                        }
                }</span>

                // Handle regular characters
                <span class="cov8" title="1">buf.WriteRune(r)
                t.pos.Index += size
                t.pos.Column++</span>
        }

        <span class="cov0" title="0">return models.Token{}, TokenizerError{
                Message:  fmt.Sprintf("unterminated quoted identifier starting at line %d, column %d", startPos.Line, startPos.Column),
                Location: models.Location{Line: startPos.Line, Column: startPos.Column},
        }</span>
}

// readBacktickIdentifier reads MySQL-style backtick identifiers
func (t *Tokenizer) readBacktickIdentifier() (models.Token, error) <span class="cov0" title="0">{
        startPos := t.pos.Clone()

        // Skip opening backtick
        t.pos.Index++
        t.pos.Column++

        var buf bytes.Buffer
        for t.pos.Index &lt; len(t.input) </span><span class="cov0" title="0">{
                ch := t.input[t.pos.Index]

                if ch == '`' </span><span class="cov0" title="0">{
                        // Check for escaped backtick
                        if t.pos.Index+1 &lt; len(t.input) &amp;&amp; t.input[t.pos.Index+1] == '`' </span><span class="cov0" title="0">{
                                // Include one backtick and skip the other
                                buf.WriteByte('`')
                                t.pos.Index += 2
                                t.pos.Column += 2
                                continue</span>
                        }

                        // End of backtick identifier
                        <span class="cov0" title="0">t.pos.Index++
                        t.pos.Column++

                        return models.Token{
                                Type:  models.TokenTypeIdentifier, // Backtick identifiers are identifiers
                                Value: buf.String(),
                        }, nil</span>
                }

                <span class="cov0" title="0">if ch == '\n' </span><span class="cov0" title="0">{
                        t.pos.Line++
                        t.pos.Column = 1
                }</span> else<span class="cov0" title="0"> {
                        t.pos.Column++
                }</span>

                <span class="cov0" title="0">buf.WriteByte(ch)
                t.pos.Index++</span>
        }

        <span class="cov0" title="0">return models.Token{}, TokenizerError{
                Message:  fmt.Sprintf("unterminated backtick identifier starting at line %d, column %d", startPos.Line, startPos.Column),
                Location: models.Location{Line: startPos.Line, Column: startPos.Column},
        }</span>
}

// readQuotedString handles the actual scanning of a single/double-quoted string
func (t *Tokenizer) readQuotedString(quote rune) (models.Token, error) <span class="cov8" title="1">{
        // Store start position for error reporting
        startPos := t.pos

        // Check for triple quotes
        if t.pos.Index+2 &lt; len(t.input) </span><span class="cov8" title="1">{
                next1, _ := utf8.DecodeRune(t.input[t.pos.Index+1:])
                next2, _ := utf8.DecodeRune(t.input[t.pos.Index+2:])
                if next1 == quote &amp;&amp; next2 == quote </span><span class="cov0" title="0">{
                        return t.readTripleQuotedString(quote)
                }</span>
        }

        // Get opening quote and remember the original quote character
        <span class="cov8" title="1">r, size := utf8.DecodeRune(t.input[t.pos.Index:])
        originalQuote := r
        quote = normalizeQuote(r)

        // Skip opening quote
        t.pos.AdvanceRune(r, size)

        var buf bytes.Buffer
        for t.pos.Index &lt; len(t.input) </span><span class="cov8" title="1">{
                r, size := utf8.DecodeRune(t.input[t.pos.Index:])
                r = normalizeQuote(r)

                if r == quote </span><span class="cov8" title="1">{
                        // Check for escaped quote
                        if t.pos.Index+size &lt; len(t.input) </span><span class="cov8" title="1">{
                                nextR, nextSize := utf8.DecodeRune(t.input[t.pos.Index+size:])
                                nextR = normalizeQuote(nextR)
                                if nextR == quote </span><span class="cov8" title="1">{
                                        // Include one quote and skip the other
                                        buf.WriteRune(r)
                                        t.pos.Index += size + nextSize
                                        t.pos.Column += 2
                                        continue</span>
                                }
                        }

                        // End of string
                        <span class="cov8" title="1">t.pos.Index += size
                        t.pos.Column++

                        value := buf.String()
                        // For test compatibility, use appropriate token types based on quote style
                        var tokenType models.TokenType
                        if originalQuote == '\'' || originalQuote == '\u2018' || originalQuote == '\u2019' ||
                                originalQuote == '«' || originalQuote == '»' </span><span class="cov8" title="1">{
                                tokenType = models.TokenTypeSingleQuotedString // 124
                        }</span> else<span class="cov0" title="0"> if originalQuote == '"' || originalQuote == '\u201C' || originalQuote == '\u201D' </span><span class="cov0" title="0">{
                                tokenType = models.TokenTypeDoubleQuotedString // 124
                        }</span> else<span class="cov0" title="0"> {
                                tokenType = models.TokenTypeString // 20
                        }</span>
                        <span class="cov8" title="1">return models.Token{
                                Type:  tokenType,
                                Value: value,
                                Quote: originalQuote,
                        }, nil</span>
                }

                <span class="cov8" title="1">if r == '\\' </span><span class="cov0" title="0">{
                        // Handle escape sequences
                        if err := t.handleEscapeSequence(&amp;buf); err != nil </span><span class="cov0" title="0">{
                                return models.Token{}, TokenizerError{
                                        Message:  fmt.Sprintf("invalid escape sequence at line %d, column %d", t.pos.Line, t.pos.Column),
                                        Location: models.Location{Line: t.pos.Line, Column: startPos.Column},
                                }
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov8" title="1">if r == '\n' </span><span class="cov8" title="1">{
                        buf.WriteRune(r)
                        t.pos.Index += size
                        t.pos.Line++
                        t.pos.Column = 1
                        continue</span>
                }

                // Handle regular characters
                <span class="cov8" title="1">buf.WriteRune(r)
                t.pos.Index += size
                t.pos.Column++</span>
        }

        <span class="cov8" title="1">return models.Token{}, TokenizerError{
                Message:  fmt.Sprintf("unterminated quoted string starting at line %d, column %d", startPos.Line, startPos.Column),
                Location: models.Location{Line: startPos.Line, Column: startPos.Column},
        }</span>
}

// readTripleQuotedString reads a triple-quoted string (e.g. "'abc"' or """abc""")
func (t *Tokenizer) readTripleQuotedString(quote rune) (models.Token, error) <span class="cov0" title="0">{
        // Store start position for error reporting
        startPos := t.pos

        // Skip opening triple quotes
        for i := 0; i &lt; 3; i++ </span><span class="cov0" title="0">{
                r, size := utf8.DecodeRune(t.input[t.pos.Index:])
                t.pos.AdvanceRune(r, size)
        }</span>

        <span class="cov0" title="0">var buf bytes.Buffer
        for t.pos.Index &lt; len(t.input) </span><span class="cov0" title="0">{
                // Check for closing triple quotes
                if t.pos.Index+2 &lt; len(t.input) </span><span class="cov0" title="0">{
                        r1, s1 := utf8.DecodeRune(t.input[t.pos.Index:])
                        r2, s2 := utf8.DecodeRune(t.input[t.pos.Index+s1:])
                        r3, s3 := utf8.DecodeRune(t.input[t.pos.Index+s1+s2:])
                        if r1 == quote &amp;&amp; r2 == quote &amp;&amp; r3 == quote </span><span class="cov0" title="0">{
                                // Skip closing quotes
                                t.pos.Index += s1 + s2 + s3
                                t.pos.Column += 3

                                value := buf.String()
                                if quote == '\'' </span><span class="cov0" title="0">{
                                        return models.Token{
                                                Type:  models.TokenTypeTripleSingleQuotedString,
                                                Value: value,
                                                Quote: quote,
                                        }, nil
                                }</span>
                                <span class="cov0" title="0">return models.Token{
                                        Type:  models.TokenTypeTripleDoubleQuotedString,
                                        Value: value,
                                        Quote: quote,
                                }, nil</span>
                        }
                }

                // Handle regular characters
                <span class="cov0" title="0">r, size := utf8.DecodeRune(t.input[t.pos.Index:])
                if r == '\n' </span><span class="cov0" title="0">{
                        buf.WriteRune(r)
                        t.pos.Index += size
                        t.pos.Line++
                        t.pos.Column = 1
                        continue</span>
                }

                <span class="cov0" title="0">buf.WriteRune(r)
                t.pos.Index += size
                t.pos.Column++</span>
        }

        <span class="cov0" title="0">return models.Token{}, TokenizerError{
                Message:  fmt.Sprintf("unterminated triple-quoted string starting at line %d, column %d", startPos.Line, startPos.Column),
                Location: models.Location{Line: startPos.Line, Column: startPos.Column},
        }</span>
}

// handleEscapeSequence handles escape sequences in string literals
func (t *Tokenizer) handleEscapeSequence(buf *bytes.Buffer) error <span class="cov0" title="0">{
        t.pos.Index++
        t.pos.Column++

        if t.pos.Index &gt;= len(t.input) </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected end of input after escape character")
        }</span>

        <span class="cov0" title="0">r, size := utf8.DecodeRune(t.input[t.pos.Index:])
        switch r </span>{
        case '\\', '"', '\'', '`':<span class="cov0" title="0">
                buf.WriteRune(r)</span>
        case 'n':<span class="cov0" title="0">
                buf.WriteRune('\n')</span>
        case 'r':<span class="cov0" title="0">
                buf.WriteRune('\r')</span>
        case 't':<span class="cov0" title="0">
                buf.WriteRune('\t')</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid escape sequence '\\%c'", r)</span>
        }

        <span class="cov0" title="0">t.pos.Index += size
        t.pos.Column++
        return nil</span>
}

// readNumber reads an integer/float
func (t *Tokenizer) readNumber(buf []byte) (models.Token, error) <span class="cov8" title="1">{
        var start int
        if buf == nil </span><span class="cov8" title="1">{
                start = t.pos.Index
        }</span> else<span class="cov0" title="0"> {
                start = t.pos.Index - len(buf)
        }</span>

        // Read integer part
        <span class="cov8" title="1">for t.pos.Index &lt; len(t.input) </span><span class="cov8" title="1">{
                r, size := utf8.DecodeRune(t.input[t.pos.Index:])
                if r &lt; '0' || r &gt; '9' </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">t.pos.AdvanceRune(r, size)</span>
        }

        <span class="cov8" title="1">if t.pos.Index &gt;= len(t.input) </span><span class="cov8" title="1">{
                return models.Token{
                        Type:  models.TokenTypeNumber,
                        Value: string(t.input[start:t.pos.Index]),
                }, nil
        }</span>

        // Look for decimal point
        <span class="cov8" title="1">r, size := utf8.DecodeRune(t.input[t.pos.Index:])
        if r == '.' </span><span class="cov8" title="1">{
                t.pos.AdvanceRune(r, size)

                // Must have at least one digit after decimal
                if t.pos.Index &gt;= len(t.input) </span><span class="cov0" title="0">{
                        return models.Token{}, fmt.Errorf("expected digit after decimal point")
                }</span>

                <span class="cov8" title="1">r, _ = utf8.DecodeRune(t.input[t.pos.Index:])
                if r &lt; '0' || r &gt; '9' </span><span class="cov0" title="0">{
                        return models.Token{}, fmt.Errorf("expected digit after decimal point")
                }</span>

                // Read fractional part
                <span class="cov8" title="1">for t.pos.Index &lt; len(t.input) </span><span class="cov8" title="1">{
                        r, size = utf8.DecodeRune(t.input[t.pos.Index:])
                        if r &lt; '0' || r &gt; '9' </span><span class="cov8" title="1">{
                                _ = size // Mark as intentionally unused
                                break</span>
                        }
                        <span class="cov8" title="1">t.pos.AdvanceRune(r, size)</span>
                }
        }

        // Look for exponent
        <span class="cov8" title="1">if t.pos.Index &lt; len(t.input) </span><span class="cov8" title="1">{
                r, size = utf8.DecodeRune(t.input[t.pos.Index:])
                if r == 'e' || r == 'E' </span><span class="cov8" title="1">{
                        t.pos.AdvanceRune(r, size)

                        // Optional sign
                        if t.pos.Index &lt; len(t.input) </span><span class="cov8" title="1">{
                                r, size = utf8.DecodeRune(t.input[t.pos.Index:])
                                if r == '+' || r == '-' </span><span class="cov8" title="1">{
                                        t.pos.AdvanceRune(r, size)
                                }</span>
                        }

                        // Must have at least one digit
                        <span class="cov8" title="1">if t.pos.Index &gt;= len(t.input) </span><span class="cov0" title="0">{
                                return models.Token{}, fmt.Errorf("expected digit in exponent")
                        }</span>

                        <span class="cov8" title="1">r, _ = utf8.DecodeRune(t.input[t.pos.Index:])
                        if r &lt; '0' || r &gt; '9' </span><span class="cov0" title="0">{
                                return models.Token{}, fmt.Errorf("expected digit in exponent")
                        }</span>

                        // Read exponent part
                        <span class="cov8" title="1">for t.pos.Index &lt; len(t.input) </span><span class="cov8" title="1">{
                                r, size = utf8.DecodeRune(t.input[t.pos.Index:])
                                if r &lt; '0' || r &gt; '9' </span><span class="cov0" title="0">{
                                        _ = size // Mark as intentionally unused
                                        break</span>
                                }
                                <span class="cov8" title="1">t.pos.AdvanceRune(r, size)</span>
                        }
                }
        }

        <span class="cov8" title="1">return models.Token{
                Type:  models.TokenTypeNumber,
                Value: string(t.input[start:t.pos.Index]),
        }, nil</span>
}

// readPunctuation picks out punctuation or operator tokens
func (t *Tokenizer) readPunctuation() (models.Token, error) <span class="cov8" title="1">{
        if t.pos.Index &gt;= len(t.input) </span><span class="cov0" title="0">{
                return models.Token{}, fmt.Errorf("unexpected end of input")
        }</span>
        <span class="cov8" title="1">r, size := utf8.DecodeRune(t.input[t.pos.Index:])
        switch r </span>{
        case '(':<span class="cov8" title="1">
                t.pos.AdvanceRune(r, size)
                return models.Token{Type: models.TokenTypeLeftParen, Value: "("}, nil</span>
        case ')':<span class="cov8" title="1">
                t.pos.AdvanceRune(r, size)
                return models.Token{Type: models.TokenTypeRightParen, Value: ")"}, nil</span>
        case '[':<span class="cov0" title="0">
                t.pos.AdvanceRune(r, size)
                return models.Token{Type: models.TokenTypeLBracket, Value: "["}, nil</span>
        case ']':<span class="cov0" title="0">
                t.pos.AdvanceRune(r, size)
                return models.Token{Type: models.TokenTypeRBracket, Value: "]"}, nil</span>
        case ',':<span class="cov8" title="1">
                t.pos.AdvanceRune(r, size)
                return models.Token{Type: models.TokenTypeComma, Value: ","}, nil</span>
        case ';':<span class="cov8" title="1">
                t.pos.AdvanceRune(r, size)
                return models.Token{Type: models.TokenTypeSemicolon, Value: ";"}, nil</span>
        case '.':<span class="cov0" title="0">
                t.pos.AdvanceRune(r, size)
                return models.Token{Type: models.TokenTypeDot, Value: "."}, nil</span>
        case '+':<span class="cov8" title="1">
                t.pos.AdvanceRune(r, size)
                return models.Token{Type: models.TokenTypePlus, Value: "+"}, nil</span>
        case '-':<span class="cov8" title="1">
                t.pos.AdvanceRune(r, size)
                if t.pos.Index &lt; len(t.input) </span><span class="cov8" title="1">{
                        nxtR, nxtSize := utf8.DecodeRune(t.input[t.pos.Index:])
                        if nxtR == '&gt;' </span><span class="cov8" title="1">{
                                t.pos.AdvanceRune(nxtR, nxtSize)
                                return models.Token{Type: models.TokenTypeArrow, Value: "-&gt;"}, nil
                        }</span>
                }
                <span class="cov0" title="0">return models.Token{Type: models.TokenTypeMinus, Value: "-"}, nil</span>
        case '*':<span class="cov8" title="1">
                t.pos.AdvanceRune(r, size)
                return models.Token{Type: models.TokenTypeMul, Value: "*"}, nil</span>
        case '/':<span class="cov8" title="1">
                t.pos.AdvanceRune(r, size)
                return models.Token{Type: models.TokenTypeDiv, Value: "/"}, nil</span>
        case '=':<span class="cov8" title="1">
                t.pos.AdvanceRune(r, size)
                if t.pos.Index &lt; len(t.input) </span><span class="cov8" title="1">{
                        nxtR, nxtSize := utf8.DecodeRune(t.input[t.pos.Index:])
                        if nxtR == '&gt;' </span><span class="cov8" title="1">{
                                t.pos.AdvanceRune(nxtR, nxtSize)
                                return models.Token{Type: models.TokenTypeRArrow, Value: "=&gt;"}, nil
                        }</span>
                }
                <span class="cov8" title="1">return models.Token{Type: models.TokenTypeEq, Value: "="}, nil</span>
        case '&lt;':<span class="cov0" title="0">
                t.pos.AdvanceRune(r, size)
                if t.pos.Index &lt; len(t.input) </span><span class="cov0" title="0">{
                        nxtR, nxtSize := utf8.DecodeRune(t.input[t.pos.Index:])
                        if nxtR == '=' </span><span class="cov0" title="0">{
                                t.pos.AdvanceRune(nxtR, nxtSize)
                                return models.Token{Type: models.TokenTypeLtEq, Value: "&lt;="}, nil
                        }</span> else<span class="cov0" title="0"> if nxtR == '&gt;' </span><span class="cov0" title="0">{
                                t.pos.AdvanceRune(nxtR, nxtSize)
                                return models.Token{Type: models.TokenTypeNeq, Value: "&lt;&gt;"}, nil
                        }</span>
                }
                <span class="cov0" title="0">return models.Token{Type: models.TokenTypeLt, Value: "&lt;"}, nil</span>
        case '&gt;':<span class="cov8" title="1">
                t.pos.AdvanceRune(r, size)
                if t.pos.Index &lt; len(t.input) </span><span class="cov8" title="1">{
                        nxtR, nxtSize := utf8.DecodeRune(t.input[t.pos.Index:])
                        if nxtR == '=' </span><span class="cov0" title="0">{
                                t.pos.AdvanceRune(nxtR, nxtSize)
                                return models.Token{Type: models.TokenTypeGtEq, Value: "&gt;="}, nil
                        }</span>
                }
                <span class="cov8" title="1">return models.Token{Type: models.TokenTypeGt, Value: "&gt;"}, nil</span>
        case '!':<span class="cov0" title="0">
                t.pos.AdvanceRune(r, size)
                if t.pos.Index &lt; len(t.input) </span><span class="cov0" title="0">{
                        nxtR, nxtSize := utf8.DecodeRune(t.input[t.pos.Index:])
                        if nxtR == '=' </span><span class="cov0" title="0">{
                                t.pos.AdvanceRune(nxtR, nxtSize)
                                return models.Token{Type: models.TokenTypeNeq, Value: "!="}, nil
                        }</span>
                }
                <span class="cov0" title="0">return models.Token{Type: models.TokenTypeExclamationMark, Value: "!"}, nil</span>
        case ':':<span class="cov8" title="1">
                t.pos.AdvanceRune(r, size)
                if t.pos.Index &lt; len(t.input) </span><span class="cov8" title="1">{
                        nxtR, nxtSize := utf8.DecodeRune(t.input[t.pos.Index:])
                        if nxtR == ':' </span><span class="cov8" title="1">{
                                t.pos.AdvanceRune(nxtR, nxtSize)
                                return models.Token{Type: models.TokenTypeDoubleColon, Value: "::"}, nil
                        }</span>
                }
                <span class="cov0" title="0">return models.Token{Type: models.TokenTypeColon, Value: ":"}, nil</span>
        case '%':<span class="cov8" title="1">
                t.pos.AdvanceRune(r, size)
                return models.Token{Type: models.TokenTypeMod, Value: "%"}, nil</span>
        case '|':<span class="cov8" title="1">
                t.pos.AdvanceRune(r, size)
                if t.pos.Index &lt; len(t.input) </span><span class="cov8" title="1">{
                        nxtR, nxtSize := utf8.DecodeRune(t.input[t.pos.Index:])
                        if nxtR == '|' </span><span class="cov8" title="1">{
                                t.pos.AdvanceRune(nxtR, nxtSize)
                                return models.Token{Type: models.TokenTypeStringConcat, Value: "||"}, nil
                        }</span>
                }
                <span class="cov0" title="0">return models.Token{Type: models.TokenTypePipe, Value: "|"}, nil</span>
        case '\'':<span class="cov0" title="0">
                return t.readQuotedString('\'')</span>
        case '&amp;':<span class="cov8" title="1">
                t.pos.AdvanceRune(r, size)
                // Check for &amp;&amp; (array overlap operator)
                if t.pos.Index &lt; len(t.input) </span><span class="cov8" title="1">{
                        nextR, nextSize := utf8.DecodeRune(t.input[t.pos.Index:])
                        if nextR == '&amp;' </span><span class="cov8" title="1">{
                                t.pos.AdvanceRune(nextR, nextSize)
                                return models.Token{Type: models.TokenTypeOverlap, Value: "&amp;&amp;"}, nil
                        }</span>
                }
                // Just a standalone &amp; symbol
                <span class="cov0" title="0">return models.Token{Type: models.TokenTypeAmpersand, Value: "&amp;"}, nil</span>
        case '@':<span class="cov8" title="1">
                t.pos.AdvanceRune(r, size)
                // Check for PostgreSQL array operators and parameter syntax
                if t.pos.Index &lt; len(t.input) </span><span class="cov8" title="1">{
                        nextR, nextSize := utf8.DecodeRune(t.input[t.pos.Index:])

                        // Check for @&gt; (contains operator)
                        if nextR == '&gt;' </span><span class="cov8" title="1">{
                                t.pos.AdvanceRune(nextR, nextSize)
                                return models.Token{Type: models.TokenTypeAtArrow, Value: "@&gt;"}, nil
                        }</span>

                        // Check for @@ (full text search operator)
                        <span class="cov8" title="1">if nextR == '@' </span><span class="cov8" title="1">{
                                t.pos.AdvanceRune(nextR, nextSize)
                                return models.Token{Type: models.TokenTypeAtAt, Value: "@@"}, nil
                        }</span>

                        // Check for parameter syntax (@variable)
                        <span class="cov8" title="1">if isIdentifierStart(nextR) </span><span class="cov8" title="1">{
                                // This is a parameter like @variable, read the identifier part
                                identToken, err := t.readIdentifier()
                                if err != nil </span><span class="cov0" title="0">{
                                        return models.Token{}, err
                                }</span>
                                <span class="cov8" title="1">return models.Token{
                                        Type:  models.TokenTypePlaceholder,
                                        Value: "@" + identToken.Value,
                                }, nil</span>
                        }
                }
                // Just a standalone @ symbol
                <span class="cov8" title="1">return models.Token{Type: models.TokenTypeAtSign, Value: "@"}, nil</span>
        }

        <span class="cov0" title="0">if isIdentifierStart(r) </span><span class="cov0" title="0">{
                return t.readIdentifier()
        }</span>

        <span class="cov0" title="0">return models.Token{}, fmt.Errorf("invalid character: %c", r)</span>
}

// toSQLPosition converts an internal Position =&gt; a models.Location
func (t *Tokenizer) toSQLPosition(pos Position) models.Location <span class="cov8" title="1">{
        // Find the line containing pos
        line := 1
        lineStart := 0

        // Find the line number using lineStarts
        for i := 0; i &lt; len(t.lineStarts); i++ </span><span class="cov8" title="1">{
                if t.lineStarts[i] &gt; pos.Index </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">line = i + 1
                lineStart = t.lineStarts[i]</span>
        }

        // Calculate column by counting characters from line start
        <span class="cov8" title="1">column := 0
        for i := lineStart; i &lt; pos.Index &amp;&amp; i &lt; len(t.input); i++ </span><span class="cov8" title="1">{
                if t.input[i] == '\t' </span><span class="cov0" title="0">{
                        column += 4 // Treat tab as 4 spaces
                }</span> else<span class="cov8" title="1"> if t.input[i] == ' ' </span><span class="cov8" title="1">{
                        column++
                }</span> else<span class="cov8" title="1"> if t.input[i] == '\'' </span><span class="cov8" title="1">{
                        // For string literals, point to the opening quote
                        if i &lt; pos.Index-1 </span><span class="cov8" title="1">{
                                column--
                        }</span>
                        <span class="cov8" title="1">column++</span>
                } else<span class="cov8" title="1"> {
                        column++
                }</span>
        }

        <span class="cov8" title="1">return models.Location{
                Line:   line,
                Column: column - 2, // Adjust for indentation
        }</span>
}

// getCurrentPosition returns the Location of the tokenizer's current byte index
func (t *Tokenizer) getCurrentPosition() models.Location <span class="cov8" title="1">{
        return t.toSQLPosition(t.pos)
}</span>

// getLocation produces 1-based {Line, Column} for a given byte offset
func (t *Tokenizer) getLocation(pos int) models.Location <span class="cov0" title="0">{
        // Find the line containing pos
        line := 1
        column := 1
        lineStart := 0

        // Find the line number and start of the line
        for i := 0; i &lt; pos &amp;&amp; i &lt; len(t.input); i++ </span><span class="cov0" title="0">{
                if t.input[i] == '\n' </span><span class="cov0" title="0">{
                        line++
                        lineStart = i + 1
                }</span>
        }

        // Calculate column as offset from line start
        <span class="cov0" title="0">if pos &gt;= lineStart </span><span class="cov0" title="0">{
                column = pos - lineStart + 1
        }</span>

        <span class="cov0" title="0">return models.Location{
                Line:   line,
                Column: column,
        }</span>
}

func isIdentifierChar(r rune) bool <span class="cov8" title="1">{
        return isUnicodeIdentifierPart(r)
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package tokenizer

import "unicode"

// isUnicodeIdentifierStart checks if a rune can start a Unicode identifier
func isUnicodeIdentifierStart(r rune) bool <span class="cov8" title="1">{
        return unicode.IsLetter(r) || r == '_'
}</span>

// isUnicodeIdentifierPart checks if a rune can be part of a Unicode identifier
func isUnicodeIdentifierPart(r rune) bool <span class="cov8" title="1">{
        return unicode.IsLetter(r) || unicode.IsDigit(r) || r == '_' ||
                unicode.Is(unicode.Mn, r) || // Non-spacing marks
                unicode.Is(unicode.Mc, r) || // Spacing combining marks
                unicode.Is(unicode.Nd, r) || // Decimal numbers
                unicode.Is(unicode.Pc, r) // Connector punctuation
}</span>

// isUnicodeQuote checks if a rune is a Unicode quote character (for identifiers)
func isUnicodeQuote(r rune) bool <span class="cov8" title="1">{
        // Only double quotes and their Unicode equivalents are for identifiers
        return r == '\u201C' || r == '\u201D'
}</span>

// normalizeQuote converts fancy Unicode quotes to standard ASCII quotes
func normalizeQuote(r rune) rune <span class="cov8" title="1">{
        switch r </span>{
        case '\u2018', '\u2019', '\u00AB', '\u00BB':<span class="cov8" title="1"> // Single quotes and guillemets
                return '\''</span>
        case '\u201C', '\u201D':<span class="cov8" title="1"> // Left and right double quotes
                return '"'</span>
        default:<span class="cov8" title="1">
                return r</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
